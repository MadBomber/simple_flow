{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"\\`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SimpleFlow","text":"![SimpleFlow Logo](assets/logo.svg)  **A lightweight, modular Ruby framework for building composable data processing pipelines with concurrent execution.**  [Get Started](getting-started/quick-start.md){ .md-button .md-button--primary } [View on GitHub](https://github.com/MadBomber/simple_flow){ .md-button }"},{"location":"#overview","title":"Overview","text":"<p>SimpleFlow provides a clean and flexible architecture for orchestrating multi-step workflows. It emphasizes simplicity, composability, and performance through fiber-based concurrent execution.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#concurrent-execution","title":"\ud83d\udd04 Concurrent Execution","text":"<p>Run independent steps in parallel using the Async gem for significant performance improvements.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  parallel do\n    step -&gt;(result) { fetch_orders(result) }\n    step -&gt;(result) { fetch_preferences(result) }\n    step -&gt;(result) { fetch_analytics(result) }\n  end\nend\n</code></pre>"},{"location":"#composable-pipelines","title":"\ud83d\udd17 Composable Pipelines","text":"<p>Build complex workflows from simple, reusable steps with an intuitive DSL.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { validate(result) }\n  step -&gt;(result) { transform(result) }\n  step -&gt;(result) { save(result) }\nend\n</code></pre>"},{"location":"#immutable-results","title":"\ud83d\udee1\ufe0f Immutable Results","text":"<p>Thread-safe result objects with context and error tracking throughout the pipeline.</p> <pre><code>result = SimpleFlow::Result.new(data)\n  .with_context(:user_id, 123)\n  .with_error(:validation, \"Invalid format\")\n  .continue(processed_data)\n</code></pre>"},{"location":"#middleware-support","title":"\ud83d\udd0c Middleware Support","text":"<p>Apply cross-cutting concerns like logging and instrumentation to all steps.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n  use_middleware SimpleFlow::MiddleWare::Instrumentation\n\n  step -&gt;(result) { process(result) }\nend\n</code></pre>"},{"location":"#flow-control","title":"\u26a1 Flow Control","text":"<p>Halt execution early or continue based on step outcomes with built-in mechanisms.</p> <pre><code>step -&gt;(result) {\n  if result.value &lt; 0\n    result.halt.with_error(:validation, \"Value must be positive\")\n  else\n    result.continue(result.value)\n  end\n}\n</code></pre>"},{"location":"#built-for-performance","title":"\ud83d\udcca Built for Performance","text":"<p>Fiber-based concurrency without threading overhead, ideal for I/O-bound operations.</p> <p>Performance Example: - Sequential: ~0.4s (4 \u00d7 0.1s operations) - Parallel: ~0.1s (4 concurrent operations) - 4x speedup!</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require 'simple_flow'\n\n# Build a user data pipeline\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { validate_user(result) }\n\n  parallel do\n    step -&gt;(result) { fetch_profile(result) }\n    step -&gt;(result) { fetch_orders(result) }\n    step -&gt;(result) { fetch_analytics(result) }\n  end\n\n  step -&gt;(result) { aggregate_data(result) }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(user_id: 123))\n</code></pre>"},{"location":"#why-simpleflow","title":"Why SimpleFlow?","text":"<ul> <li>Simple: Minimal API surface, maximum power</li> <li>Fast: Fiber-based concurrency for I/O-bound operations</li> <li>Safe: Immutable results prevent race conditions</li> <li>Flexible: Middleware and flow control for any use case</li> <li>Testable: Easy to unit test individual steps</li> <li>Production-Ready: Used in real-world applications</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p> Quick Start</p> <p>Get up and running in 5 minutes</p> <p> Quick Start</p> </li> <li> <p> Core Concepts</p> <p>Learn the fundamental concepts</p> <p> Core Concepts</p> </li> <li> <p> Concurrent Execution</p> <p>Maximize performance with parallel steps</p> <p> Concurrency Guide</p> </li> <li> <p> Examples</p> <p>Real-world examples and patterns</p> <p> Examples</p> </li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li> GitHub Repository</li> <li> Issue Tracker</li> <li> Changelog</li> </ul>"},{"location":"#license","title":"License","text":"<p>SimpleFlow is released under the MIT License.</p>"},{"location":"api/middleware/","title":"Middleware API Reference","text":"<p>Middleware in SimpleFlow wraps steps with cross-cutting functionality using the decorator pattern. This document covers built-in middleware and how to create custom middleware.</p>"},{"location":"api/middleware/#built-in-middleware","title":"Built-in Middleware","text":""},{"location":"api/middleware/#class-simpleflowmiddlewarelogging","title":"Class: <code>SimpleFlow::MiddleWare::Logging</code>","text":"<p>Location: <code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/lib/simple_flow/middleware.rb</code></p> <p>Logs before and after step execution.</p>"},{"location":"api/middleware/#constructor","title":"Constructor","text":"<pre><code>def initialize(callable, logger = nil)\n</code></pre> <p>Parameters: - <code>callable</code> (Proc/Object) - The step to wrap - <code>logger</code> (Logger, optional) - Custom logger instance (default: <code>Logger.new($stdout)</code>)</p>"},{"location":"api/middleware/#usage","title":"Usage","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n\n  step -&gt;(result) { result.continue(process(result.value)) }\nend\n</code></pre> <p>With Custom Logger: <pre><code>require 'logger'\n\ncustom_logger = Logger.new('pipeline.log')\ncustom_logger.level = Logger::DEBUG\n\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging, logger: custom_logger\n\n  step -&gt;(result) { result.continue(result.value) }\nend\n</code></pre></p> <p>Output: <pre><code>I, [2025-11-15T12:00:00.123456 #12345]  INFO -- : Before call\nI, [2025-11-15T12:00:00.456789 #12345]  INFO -- : After call\n</code></pre></p>"},{"location":"api/middleware/#class-simpleflowmiddlewareinstrumentation","title":"Class: <code>SimpleFlow::MiddleWare::Instrumentation</code>","text":"<p>Location: <code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/lib/simple_flow/middleware.rb</code></p> <p>Measures step execution duration.</p>"},{"location":"api/middleware/#constructor_1","title":"Constructor","text":"<pre><code>def initialize(callable, api_key: nil)\n</code></pre> <p>Parameters: - <code>callable</code> (Proc/Object) - The step to wrap - <code>api_key</code> (String, optional) - API key for external instrumentation service</p>"},{"location":"api/middleware/#usage_1","title":"Usage","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'demo-key-123'\n\n  step -&gt;(result) {\n    sleep 0.1\n    result.continue(result.value)\n  }\nend\n</code></pre> <p>Output: <pre><code>Instrumentation: demo-key-123 took 0.10012345s\n</code></pre></p>"},{"location":"api/middleware/#creating-custom-middleware","title":"Creating Custom Middleware","text":""},{"location":"api/middleware/#basic-pattern","title":"Basic Pattern","text":"<p>Custom middleware must implement a <code>call</code> method that: 1. Receives a Result object 2. Calls the wrapped callable 3. Returns a Result object</p> <pre><code>class MyMiddleware\n  def initialize(callable, **options)\n    @callable = callable\n    @options = options\n  end\n\n  def call(result)\n    # Before step execution\n    puts \"Before: #{result.value}\"\n\n    # Execute the wrapped step\n    output = @callable.call(result)\n\n    # After step execution\n    puts \"After: #{output.value}\"\n\n    output\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware MyMiddleware, option: \"value\"\n\n  step -&gt;(result) { result.continue(result.value) }\nend\n</code></pre>"},{"location":"api/middleware/#middleware-examples","title":"Middleware Examples","text":""},{"location":"api/middleware/#timing-middleware","title":"Timing Middleware","text":"<pre><code>class TimingMiddleware\n  def initialize(callable, step_name: nil)\n    @callable = callable\n    @step_name = step_name || \"unknown_step\"\n  end\n\n  def call(result)\n    start_time = Time.now\n    output = @callable.call(result)\n    duration = Time.now - start_time\n\n    output.with_context(\n      \"#{@step_name}_duration\".to_sym,\n      duration\n    )\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware TimingMiddleware, step_name: \"data_processing\"\n\n  step -&gt;(result) {\n    process_data(result.value)\n    result.continue(result.value)\n  }\nend\n\nresult = pipeline.call(initial_data)\nputs \"Execution time: #{result.context[:data_processing_duration]}s\"\n</code></pre>"},{"location":"api/middleware/#retry-middleware","title":"Retry Middleware","text":"<pre><code>class RetryMiddleware\n  def initialize(callable, max_retries: 3, retry_on: [StandardError])\n    @callable = callable\n    @max_retries = max_retries\n    @retry_on = Array(retry_on)\n  end\n\n  def call(result)\n    attempts = 0\n\n    begin\n      attempts += 1\n      @callable.call(result)\n    rescue *@retry_on =&gt; e\n      if attempts &lt; @max_retries\n        sleep(attempts ** 2)  # Exponential backoff\n        retry\n      else\n        result.halt.with_error(\n          :retry_exhausted,\n          \"Failed after #{@max_retries} attempts: #{e.message}\"\n        )\n      end\n    end\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware RetryMiddleware, max_retries: 3, retry_on: [Net::HTTPError]\n\n  step -&gt;(result) {\n    data = fetch_from_api(result.value)  # May fail temporarily\n    result.continue(data)\n  }\nend\n</code></pre>"},{"location":"api/middleware/#authentication-middleware","title":"Authentication Middleware","text":"<pre><code>class AuthMiddleware\n  def initialize(callable, required_role:)\n    @callable = callable\n    @required_role = required_role\n  end\n\n  def call(result)\n    user_role = result.context[:user_role]\n\n    unless user_role == @required_role\n      return result.halt.with_error(\n        :auth,\n        \"Unauthorized: requires #{@required_role} role\"\n      )\n    end\n\n    @callable.call(result)\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  # Set user role in first step\n  step -&gt;(result) {\n    result.with_context(:user_role, :admin).continue(result.value)\n  }\n\n  # Protect subsequent steps\n  use_middleware AuthMiddleware, required_role: :admin\n\n  step -&gt;(result) {\n    # This only executes if user_role == :admin\n    result.continue(\"Sensitive operation\")\n  }\nend\n</code></pre>"},{"location":"api/middleware/#caching-middleware","title":"Caching Middleware","text":"<pre><code>class CachingMiddleware\n  def initialize(callable, cache_key_proc:, ttl: 3600)\n    @callable = callable\n    @cache_key_proc = cache_key_proc\n    @ttl = ttl\n  end\n\n  def call(result)\n    cache_key = @cache_key_proc.call(result)\n\n    # Check cache\n    if cached = REDIS.get(cache_key)\n      return result.with_context(:cache_hit, true).continue(JSON.parse(cached))\n    end\n\n    # Execute step\n    output = @callable.call(result)\n\n    # Cache result if successful\n    if output.continue?\n      REDIS.setex(cache_key, @ttl, output.value.to_json)\n    end\n\n    output.with_context(:cache_hit, false)\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware CachingMiddleware,\n    cache_key_proc: -&gt;(result) { \"user_#{result.value}\" },\n    ttl: 1800\n\n  step -&gt;(result) {\n    user = User.find(result.value)\n    result.continue(user)\n  }\nend\n</code></pre>"},{"location":"api/middleware/#error-tracking-middleware","title":"Error Tracking Middleware","text":"<pre><code>class ErrorTrackingMiddleware\n  def initialize(callable, error_tracker:)\n    @callable = callable\n    @error_tracker = error_tracker\n  end\n\n  def call(result)\n    output = @callable.call(result)\n\n    # Report errors to tracking service\n    if !output.continue? &amp;&amp; output.errors.any?\n      @error_tracker.report(\n        errors: output.errors,\n        context: output.context,\n        value: output.value\n      )\n    end\n\n    output\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware ErrorTrackingMiddleware, error_tracker: Sentry\n\n  step -&gt;(result) {\n    # Errors here will be reported to Sentry\n    result.halt.with_error(:processing, \"Something went wrong\")\n  }\nend\n</code></pre>"},{"location":"api/middleware/#middleware-stacking","title":"Middleware Stacking","text":"<p>Middleware is applied in reverse order (last declared middleware wraps first):</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware OuterMiddleware     # Applied third (outermost)\n  use_middleware MiddleMiddleware    # Applied second\n  use_middleware InnerMiddleware     # Applied first (innermost)\n\n  step -&gt;(result) { result.continue(result.value) }\nend\n\n# Execution order:\n# 1. OuterMiddleware before\n# 2. MiddleMiddleware before\n# 3. InnerMiddleware before\n# 4. Step execution\n# 5. InnerMiddleware after\n# 6. MiddleMiddleware after\n# 7. OuterMiddleware after\n</code></pre> <p>Example: <pre><code>class LoggingMiddleware\n  def initialize(callable, name:)\n    @callable = callable\n    @name = name\n  end\n\n  def call(result)\n    puts \"#{@name}: before\"\n    output = @callable.call(result)\n    puts \"#{@name}: after\"\n    output\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware LoggingMiddleware, name: \"Outer\"\n  use_middleware LoggingMiddleware, name: \"Middle\"\n  use_middleware LoggingMiddleware, name: \"Inner\"\n\n  step -&gt;(result) {\n    puts \"Step execution\"\n    result.continue(result.value)\n  }\nend\n\npipeline.call(SimpleFlow::Result.new(nil))\n\n# Output:\n# Outer: before\n# Middle: before\n# Inner: before\n# Step execution\n# Inner: after\n# Middle: after\n# Outer: after\n</code></pre></p>"},{"location":"api/middleware/#best-practices","title":"Best Practices","text":""},{"location":"api/middleware/#1-keep-middleware-focused","title":"1. Keep Middleware Focused","text":"<p>Each middleware should have a single responsibility:</p> <pre><code># GOOD: Focused middleware\nclass TimingMiddleware\n  def call(result)\n    start = Time.now\n    output = @callable.call(result)\n    output.with_context(:duration, Time.now - start)\n  end\nend\n\n# BAD: Too many responsibilities\nclass KitchenSinkMiddleware\n  def call(result)\n    # Logging, timing, caching, retrying, auth... too much!\n  end\nend\n</code></pre>"},{"location":"api/middleware/#2-preserve-result-immutability","title":"2. Preserve Result Immutability","text":"<p>Always return new Result objects:</p> <pre><code># GOOD: Returns new Result\ndef call(result)\n  output = @callable.call(result)\n  output.with_context(:middleware_applied, true)\nend\n\n# BAD: Attempts to modify Result\ndef call(result)\n  output = @callable.call(result)\n  output.context[:middleware_applied] = true  # Won't work!\n  output\nend\n</code></pre>"},{"location":"api/middleware/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<p>Ensure middleware doesn't break the pipeline:</p> <pre><code>class SafeMiddleware\n  def call(result)\n    begin\n      @callable.call(result)\n    rescue StandardError =&gt; e\n      result.halt.with_error(:middleware_error, \"Middleware failed: #{e.message}\")\n    end\n  end\nend\n</code></pre>"},{"location":"api/middleware/#4-make-middleware-configurable","title":"4. Make Middleware Configurable","text":"<p>Use options for flexibility:</p> <pre><code>class ConfigurableMiddleware\n  def initialize(callable, enabled: true, **options)\n    @callable = callable\n    @enabled = enabled\n    @options = options\n  end\n\n  def call(result)\n    return @callable.call(result) unless @enabled\n\n    # Middleware logic here\n    @callable.call(result)\n  end\nend\n</code></pre>"},{"location":"api/middleware/#related-documentation","title":"Related Documentation","text":"<ul> <li>Pipeline API - How pipelines use middleware</li> <li>Complex Workflows - Using middleware in workflows</li> <li>Error Handling - Error handling patterns</li> </ul>"},{"location":"api/parallel-step/","title":"Parallel Execution API Reference","text":"<p>This document covers the APIs for parallel execution in SimpleFlow, including the ParallelExecutor class and dependency graph management.</p>"},{"location":"api/parallel-step/#class-simpleflowparallelexecutor","title":"Class: <code>SimpleFlow::ParallelExecutor</code>","text":"<p>Location: <code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/lib/simple_flow/parallel_executor.rb</code></p> <p>Handles parallel execution of steps using the async gem, with automatic fallback to sequential execution.</p>"},{"location":"api/parallel-step/#class-methods","title":"Class Methods","text":""},{"location":"api/parallel-step/#execute_parallelsteps-result","title":"<code>execute_parallel(steps, result)</code>","text":"<p>Executes a group of steps in parallel.</p> <p>Parameters: - <code>steps</code> (Array) - Array of callable steps - <code>result</code> (Result) - The input result to pass to each step <p>Returns: Array - Results from each step <p>Behavior: - Uses async gem for true parallel execution if available - Falls back to sequential execution if async is not available - Each step receives the same input result - Returns array of results in same order as input steps</p> <p>Example: <pre><code>steps = [\n  -&gt;(result) { result.with_context(:a, \"data_a\").continue(result.value) },\n  -&gt;(result) { result.with_context(:b, \"data_b\").continue(result.value) },\n  -&gt;(result) { result.with_context(:c, \"data_c\").continue(result.value) }\n]\n\ninitial = SimpleFlow::Result.new(123)\nresults = SimpleFlow::ParallelExecutor.execute_parallel(steps, initial)\n\nresults.size  # =&gt; 3\nresults[0].context[:a]  # =&gt; \"data_a\"\nresults[1].context[:b]  # =&gt; \"data_b\"\nresults[2].context[:c]  # =&gt; \"data_c\"\n</code></pre></p>"},{"location":"api/parallel-step/#execute_sequentialsteps-result","title":"<code>execute_sequential(steps, result)</code>","text":"<p>Executes steps sequentially (fallback implementation).</p> <p>Parameters: - <code>steps</code> (Array) - Array of callable steps - <code>result</code> (Result) - The input result <p>Returns: Array <p>Example: <pre><code>results = SimpleFlow::ParallelExecutor.execute_sequential(steps, initial)\n</code></pre></p>"},{"location":"api/parallel-step/#async_available","title":"<code>async_available?</code>","text":"<p>Checks if the async gem is available.</p> <p>Returns: Boolean</p> <p>Example: <pre><code>if SimpleFlow::ParallelExecutor.async_available?\n  puts \"Async gem is installed - true parallel execution enabled\"\nelse\n  puts \"Async gem not found - will use sequential fallback\"\nend\n</code></pre></p>"},{"location":"api/parallel-step/#implementation-details","title":"Implementation Details","text":""},{"location":"api/parallel-step/#async-integration","title":"Async Integration","text":"<p>When async gem is available: <pre><code># Uses Async::Barrier for concurrent execution\nAsync do\n  barrier = Async::Barrier.new\n  tasks = []\n\n  steps.each do |step|\n    tasks &lt;&lt; barrier.async do\n      step.call(result)\n    end\n  end\n\n  barrier.wait\n  results = tasks.map(&amp;:result)\nend\n</code></pre></p>"},{"location":"api/parallel-step/#sequential-fallback","title":"Sequential Fallback","text":"<p>When async is not available: <pre><code>steps.map { |step| step.call(result) }\n</code></pre></p>"},{"location":"api/parallel-step/#class-simpleflowdependencygraph","title":"Class: <code>SimpleFlow::DependencyGraph</code>","text":"<p>Location: <code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/lib/simple_flow/dependency_graph.rb</code></p> <p>Manages dependencies between pipeline steps and determines which steps can execute in parallel.</p>"},{"location":"api/parallel-step/#constructor","title":"Constructor","text":""},{"location":"api/parallel-step/#newdependencies","title":"<code>new(dependencies)</code>","text":"<p>Creates a new dependency graph.</p> <p>Parameters: - <code>dependencies</code> (Hash) - Hash mapping step names to their dependencies</p> <p>Example: <pre><code>graph = SimpleFlow::DependencyGraph.new(\n  fetch_user: [],\n  fetch_orders: [:fetch_user],\n  fetch_products: [:fetch_user],\n  calculate_total: [:fetch_orders, :fetch_products]\n)\n</code></pre></p>"},{"location":"api/parallel-step/#instance-methods","title":"Instance Methods","text":""},{"location":"api/parallel-step/#order","title":"<code>order</code>","text":"<p>Returns steps in topological order (dependencies first).</p> <p>Returns: Array - Ordered list of step names</p> <p>Example: <pre><code>graph.order\n# =&gt; [:fetch_user, :fetch_orders, :fetch_products, :calculate_total]\n</code></pre></p>"},{"location":"api/parallel-step/#reverse_order","title":"<code>reverse_order</code>","text":"<p>Returns steps in reverse topological order.</p> <p>Returns: Array</p> <p>Example: <pre><code>graph.reverse_order\n# =&gt; [:calculate_total, :fetch_products, :fetch_orders, :fetch_user]\n</code></pre></p>"},{"location":"api/parallel-step/#parallel_order","title":"<code>parallel_order</code>","text":"<p>Groups steps that can be executed in parallel.</p> <p>Returns: Array - Array of groups, where each group can run in parallel <p>Algorithm: Steps can run in parallel if: 1. They have the exact same dependencies, OR 2. All of a step's dependencies have been resolved in previous groups</p> <p>Example: <pre><code>graph = SimpleFlow::DependencyGraph.new(\n  step_a: [],\n  step_b: [:step_a],\n  step_c: [:step_a],\n  step_d: [:step_b, :step_c]\n)\n\ngraph.parallel_order\n# =&gt; [\n#      [:step_a],           # Group 1: step_a (no dependencies)\n#      [:step_b, :step_c],  # Group 2: parallel (both depend only on step_a)\n#      [:step_d]            # Group 3: step_d (waits for step_b and step_c)\n#    ]\n</code></pre></p>"},{"location":"api/parallel-step/#subgraphnode","title":"<code>subgraph(node)</code>","text":"<p>Generates a subgraph starting at the given node.</p> <p>Parameters: - <code>node</code> (Symbol) - The starting node</p> <p>Returns: DependencyGraph - New graph containing only the node and its dependencies</p> <p>Example: <pre><code>graph = SimpleFlow::DependencyGraph.new(\n  step_a: [],\n  step_b: [:step_a],\n  step_c: [:step_b]\n)\n\nsubgraph = graph.subgraph(:step_c)\nsubgraph.dependencies\n# =&gt; { step_c: [:step_b], step_b: [:step_a], step_a: [] }\n</code></pre></p>"},{"location":"api/parallel-step/#mergeother","title":"<code>merge(other)</code>","text":"<p>Merges this graph with another graph.</p> <p>Parameters: - <code>other</code> (DependencyGraph) - Another dependency graph</p> <p>Returns: DependencyGraph - New merged graph</p> <p>Behavior: - Combines all dependencies from both graphs - If both graphs depend on the same item, uses the union of dependencies</p> <p>Example: <pre><code>graph1 = SimpleFlow::DependencyGraph.new(\n  step_a: [],\n  step_b: [:step_a]\n)\n\ngraph2 = SimpleFlow::DependencyGraph.new(\n  step_c: [],\n  step_b: [:step_c]  # Different dependency for step_b\n)\n\nmerged = graph1.merge(graph2)\nmerged.dependencies[:step_b]\n# =&gt; [:step_a, :step_c]  # Union of dependencies\n</code></pre></p>"},{"location":"api/parallel-step/#instance-attributes","title":"Instance Attributes","text":""},{"location":"api/parallel-step/#dependencies","title":"<code>dependencies</code>","text":"<p>Hash of dependencies (read-only).</p> <p>Type: Hash</p> <p>Example: <pre><code>graph.dependencies\n# =&gt; {\n#      fetch_user: [],\n#      fetch_orders: [:fetch_user],\n#      fetch_products: [:fetch_user],\n#      calculate_total: [:fetch_orders, :fetch_products]\n#    }\n</code></pre></p>"},{"location":"api/parallel-step/#class-simpleflowpipelineparallelblock","title":"Class: <code>SimpleFlow::Pipeline::ParallelBlock</code>","text":"<p>Internal helper class for building parallel blocks.</p>"},{"location":"api/parallel-step/#methods","title":"Methods","text":""},{"location":"api/parallel-step/#stepname_or_callable-nil-callable-nil-depends_on-block","title":"<code>step(name_or_callable = nil, callable = nil, depends_on: [], &amp;block)</code>","text":"<p>Adds a step to the parallel block.</p> <p>Note: This is used internally by the Pipeline DSL.</p>"},{"location":"api/parallel-step/#usage-examples","title":"Usage Examples","text":""},{"location":"api/parallel-step/#direct-parallelexecutor-usage","title":"Direct ParallelExecutor Usage","text":"<pre><code>steps = [\n  -&gt;(result) {\n    data = fetch_from_api_a(result.value)\n    result.with_context(:api_a, data).continue(result.value)\n  },\n  -&gt;(result) {\n    data = fetch_from_api_b(result.value)\n    result.with_context(:api_b, data).continue(result.value)\n  },\n  -&gt;(result) {\n    data = fetch_from_cache(result.value)\n    result.with_context(:cache, data).continue(result.value)\n  }\n]\n\ninitial = SimpleFlow::Result.new(request_id)\nresults = SimpleFlow::ParallelExecutor.execute_parallel(steps, initial)\n\n# Merge contexts\nmerged_context = results.reduce({}) do |acc, r|\n  acc.merge(r.context)\nend\n# =&gt; { api_a: ..., api_b: ..., cache: ... }\n</code></pre>"},{"location":"api/parallel-step/#dependency-graph-analysis","title":"Dependency Graph Analysis","text":"<pre><code># Define dependencies\ndependencies = {\n  validate_input: [],\n  check_inventory: [:validate_input],\n  check_pricing: [:validate_input],\n  check_shipping: [:validate_input],\n  calculate_discount: [:check_inventory, :check_pricing],\n  finalize_order: [:calculate_discount, :check_shipping]\n}\n\ngraph = SimpleFlow::DependencyGraph.new(dependencies)\n\n# Analyze execution order\nputs \"Sequential order:\"\nputs graph.order.join(' -&gt; ')\n# =&gt; validate_input -&gt; check_inventory -&gt; check_pricing -&gt; check_shipping -&gt; calculate_discount -&gt; finalize_order\n\nputs \"\\nParallel execution groups:\"\ngraph.parallel_order.each_with_index do |group, index|\n  puts \"Group #{index + 1}: #{group.join(', ')}\"\nend\n# =&gt; Group 1: validate_input\n# =&gt; Group 2: check_inventory, check_pricing, check_shipping\n# =&gt; Group 3: calculate_discount\n# =&gt; Group 4: finalize_order\n\n# Calculate potential speedup\ntotal_steps = graph.order.size\ntotal_groups = graph.parallel_order.size\nputs \"\\nPotential speedup: #{total_steps.to_f / total_groups}x\"\n# =&gt; Potential speedup: 1.5x\n</code></pre>"},{"location":"api/parallel-step/#installing-async-gem","title":"Installing Async Gem","text":"<p>Add to your Gemfile: <pre><code>gem 'async', '~&gt; 2.0'\n</code></pre></p> <p>Then run: <pre><code>bundle install\n</code></pre></p>"},{"location":"api/parallel-step/#checking-async-availability","title":"Checking Async Availability","text":"<pre><code># In your application\nif SimpleFlow::ParallelExecutor.async_available?\n  puts \"Parallel execution enabled\"\n  puts \"Using async gem for true concurrency\"\nelse\n  puts \"Parallel execution disabled\"\n  puts \"Add 'async' gem to Gemfile for parallel support\"\nend\n</code></pre>"},{"location":"api/parallel-step/#related-documentation","title":"Related Documentation","text":"<ul> <li>Pipeline API - Pipeline class reference</li> <li>Parallel Steps Guide - Using parallel execution</li> <li>Performance Guide - Performance characteristics</li> <li>Best Practices - Concurrent execution best practices</li> </ul>"},{"location":"api/pipeline/","title":"Pipeline API Reference","text":"<p>The <code>Pipeline</code> class orchestrates step execution with middleware integration and parallel execution support.</p>"},{"location":"api/pipeline/#class-simpleflowpipeline","title":"Class: <code>SimpleFlow::Pipeline</code>","text":"<p>Location: <code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/lib/simple_flow/pipeline.rb</code></p>"},{"location":"api/pipeline/#constructor","title":"Constructor","text":""},{"location":"api/pipeline/#newconfig","title":"<code>new(&amp;config)</code>","text":"<p>Creates a new Pipeline with optional configuration block.</p> <p>Parameters: - <code>config</code> (Block, optional) - Configuration block for defining steps and middleware</p> <p>Example: <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n  step -&gt;(result) { result.continue(result.value + 1) }\nend\n</code></pre></p>"},{"location":"api/pipeline/#dsl-methods","title":"DSL Methods","text":""},{"location":"api/pipeline/#use_middlewaremiddleware-options","title":"<code>use_middleware(middleware, options = {})</code>","text":"<p>Registers middleware to be applied to each step.</p> <p>Parameters: - <code>middleware</code> (Class/Proc) - Middleware class or proc - <code>options</code> (Hash) - Options passed to middleware constructor</p> <p>Example: <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n  use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'xyz'\n  use_middleware CustomMiddleware, timeout: 30\nend\n</code></pre></p>"},{"location":"api/pipeline/#stepname_or_callable-nil-callable-nil-depends_on-block","title":"<code>step(name_or_callable = nil, callable = nil, depends_on: [], &amp;block)</code>","text":"<p>Adds a step to the pipeline. Supports named and unnamed steps.</p> <p>Parameters: - <code>name_or_callable</code> (Symbol/Proc/Object) - Step name or callable - <code>callable</code> (Proc/Object) - Callable object (if first param is name) - <code>depends_on</code> (Array) - Dependencies for named steps - <code>block</code> (Block) - Block to use as step</p> <p>Returns: self (for chaining)</p> <p>Named Steps: <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user, -&gt;(result) { ... }, depends_on: []\n  step :process_data, -&gt;(result) { ... }, depends_on: [:fetch_user]\nend\n</code></pre></p> <p>Unnamed Steps: <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value + 1) }\n  step { |result| result.continue(result.value * 2) }\nend\n</code></pre></p> <p>Class-Based Steps: <pre><code>class FetchUser\n  def call(result)\n    user = User.find(result.value)\n    result.with_context(:user, user).continue(result.value)\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user, FetchUser.new, depends_on: []\nend\n</code></pre></p>"},{"location":"api/pipeline/#parallelblock","title":"<code>parallel(&amp;block)</code>","text":"<p>Defines an explicit parallel execution block.</p> <p>Parameters: - <code>block</code> (Block) - Block containing step definitions</p> <p>Returns: self (for chaining)</p> <p>Example: <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(validate(result.value)) }\n\n  parallel do\n    step -&gt;(result) { result.with_context(:api, fetch_api).continue(result.value) }\n    step -&gt;(result) { result.with_context(:db, fetch_db).continue(result.value) }\n    step -&gt;(result) { result.with_context(:cache, fetch_cache).continue(result.value) }\n  end\n\n  step -&gt;(result) { result.continue(merge_data(result.context)) }\nend\n</code></pre></p>"},{"location":"api/pipeline/#execution-methods","title":"Execution Methods","text":""},{"location":"api/pipeline/#callresult","title":"<code>call(result)</code>","text":"<p>Executes the pipeline sequentially with a given initial result.</p> <p>Parameters: - <code>result</code> (Result) - Initial Result object</p> <p>Returns: Final Result object</p> <p>Example: <pre><code>initial = SimpleFlow::Result.new(5)\nresult = pipeline.call(initial)\n\nresult.value      # =&gt; Final value\nresult.context    # =&gt; Accumulated context\nresult.errors     # =&gt; Any errors\nresult.continue?  # =&gt; true/false\n</code></pre></p>"},{"location":"api/pipeline/#call_parallelresult-strategy-auto","title":"<code>call_parallel(result, strategy: :auto)</code>","text":"<p>Executes the pipeline with parallel execution where possible.</p> <p>Parameters: - <code>result</code> (Result) - Initial Result object - <code>strategy</code> (Symbol) - Parallelization strategy (<code>:auto</code> or <code>:explicit</code>)</p> <p>Returns: Final Result object</p> <p>Strategies: - <code>:auto</code> (default) - Uses dependency graph if named steps exist - <code>:explicit</code> - Only uses explicit parallel blocks</p> <p>Example: <pre><code># Automatic strategy (uses dependency graph)\nresult = pipeline.call_parallel(initial_data)\n\n# Explicit strategy\nresult = pipeline.call_parallel(initial_data, strategy: :explicit)\n</code></pre></p>"},{"location":"api/pipeline/#visualization-methods","title":"Visualization Methods","text":""},{"location":"api/pipeline/#visualize_asciishow_groups-true","title":"<code>visualize_ascii(show_groups: true)</code>","text":"<p>Returns ASCII visualization of the dependency graph.</p> <p>Parameters: - <code>show_groups</code> (Boolean) - Whether to show parallel execution groups (default: true)</p> <p>Returns: String (ASCII art) or nil if no named steps</p> <p>Example: <pre><code>puts pipeline.visualize_ascii\n\n# Hide parallel groups\nputs pipeline.visualize_ascii(show_groups: false)\n</code></pre></p>"},{"location":"api/pipeline/#visualize_dotinclude_groups-true-orientation-tb","title":"<code>visualize_dot(include_groups: true, orientation: 'TB')</code>","text":"<p>Exports dependency graph to Graphviz DOT format.</p> <p>Parameters: - <code>include_groups</code> (Boolean) - Color-code parallel groups (default: true) - <code>orientation</code> (String) - Graph orientation: 'TB' (top-bottom) or 'LR' (left-right)</p> <p>Returns: String (DOT format) or nil if no named steps</p> <p>Example: <pre><code>File.write('pipeline.dot', pipeline.visualize_dot)\n# Generate image: dot -Tpng pipeline.dot -o pipeline.png\n\n# Left-to-right layout\nFile.write('pipeline.dot', pipeline.visualize_dot(orientation: 'LR'))\n</code></pre></p>"},{"location":"api/pipeline/#visualize_mermaid","title":"<code>visualize_mermaid()</code>","text":"<p>Exports dependency graph to Mermaid diagram format.</p> <p>Returns: String (Mermaid format) or nil if no named steps</p> <p>Example: <pre><code>File.write('pipeline.mmd', pipeline.visualize_mermaid)\n# View at https://mermaid.live/\n</code></pre></p>"},{"location":"api/pipeline/#execution_plan","title":"<code>execution_plan()</code>","text":"<p>Returns detailed execution plan analysis.</p> <p>Returns: String (execution plan) or nil if no named steps</p> <p>Example: <pre><code>puts pipeline.execution_plan\n</code></pre></p> <p>Output includes: - Total steps and execution phases - Which steps run in parallel - Potential speedup vs sequential execution</p>"},{"location":"api/pipeline/#utility-methods","title":"Utility Methods","text":""},{"location":"api/pipeline/#async_available","title":"<code>async_available?</code>","text":"<p>Checks if the async gem is available for true parallel execution.</p> <p>Returns: Boolean</p> <p>Example: <pre><code>if pipeline.async_available?\n  puts \"Parallel execution enabled\"\nelse\n  puts \"Falling back to sequential execution\"\nend\n</code></pre></p>"},{"location":"api/pipeline/#dependency_graph","title":"<code>dependency_graph</code>","text":"<p>Returns the dependency graph for this pipeline.</p> <p>Returns: DependencyGraph or nil if no named steps</p> <p>Example: <pre><code>graph = pipeline.dependency_graph\nif graph\n  puts graph.order            # =&gt; [:step1, :step2, :step3]\n  puts graph.parallel_order   # =&gt; [[:step1], [:step2, :step3]]\nend\n</code></pre></p>"},{"location":"api/pipeline/#visualize","title":"<code>visualize</code>","text":"<p>Creates a visualizer for this pipeline's dependency graph.</p> <p>Returns: DependencyGraphVisualizer or nil if no named steps</p> <p>Example: <pre><code>visualizer = pipeline.visualize\nif visualizer\n  puts visualizer.to_ascii\n  File.write('graph.dot', visualizer.to_dot)\nend\n</code></pre></p>"},{"location":"api/pipeline/#instance-attributes","title":"Instance Attributes","text":""},{"location":"api/pipeline/#steps","title":"<code>steps</code>","text":"<p>Array of step definitions (read-only).</p> <p>Type: Array</p>"},{"location":"api/pipeline/#middlewares","title":"<code>middlewares</code>","text":"<p>Array of registered middleware (read-only).</p> <p>Type: Array</p>"},{"location":"api/pipeline/#named_steps","title":"<code>named_steps</code>","text":"<p>Hash of named steps (read-only).</p> <p>Type: Hash</p>"},{"location":"api/pipeline/#step_dependencies","title":"<code>step_dependencies</code>","text":"<p>Hash of step dependencies (read-only).</p> <p>Type: Hash</p>"},{"location":"api/pipeline/#usage-examples","title":"Usage Examples","text":""},{"location":"api/pipeline/#basic-sequential-pipeline","title":"Basic Sequential Pipeline","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value.strip) }\n  step -&gt;(result) { result.continue(result.value.downcase) }\n  step -&gt;(result) { result.continue(\"Hello, #{result.value}!\") }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(\"  WORLD  \"))\nresult.value  # =&gt; \"Hello, world!\"\n</code></pre>"},{"location":"api/pipeline/#parallel-pipeline-with-dependencies","title":"Parallel Pipeline with Dependencies","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user, -&gt;(result) {\n    user = User.find(result.value)\n    result.with_context(:user, user).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_orders, -&gt;(result) {\n    orders = Order.where(user_id: result.context[:user].id)\n    result.with_context(:orders, orders).continue(result.value)\n  }, depends_on: [:fetch_user]\n\n  step :fetch_preferences, -&gt;(result) {\n    prefs = Preference.where(user_id: result.context[:user].id)\n    result.with_context(:preferences, prefs).continue(result.value)\n  }, depends_on: [:fetch_user]\n\n  step :build_profile, -&gt;(result) {\n    profile = {\n      user: result.context[:user],\n      orders: result.context[:orders],\n      preferences: result.context[:preferences]\n    }\n    result.continue(profile)\n  }, depends_on: [:fetch_orders, :fetch_preferences]\nend\n\n# fetch_orders and fetch_preferences run in parallel\nresult = pipeline.call_parallel(SimpleFlow::Result.new(user_id))\n</code></pre>"},{"location":"api/pipeline/#pipeline-with-middleware","title":"Pipeline with Middleware","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n  use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'demo'\n\n  step -&gt;(result) { result.continue(process(result.value)) }\nend\n</code></pre>"},{"location":"api/pipeline/#mixed-execution-styles","title":"Mixed Execution Styles","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Unnamed sequential step\n  step -&gt;(result) { result.continue(sanitize(result.value)) }\n\n  # Named steps with automatic parallelism\n  step :step_a, -&gt;(result) { ... }, depends_on: []\n  step :step_b, -&gt;(result) { ... }, depends_on: []\n  step :step_c, -&gt;(result) { ... }, depends_on: [:step_a, :step_b]\n\n  # Explicit parallel block\n  parallel do\n    step -&gt;(result) { ... }\n    step -&gt;(result) { ... }\n  end\n\n  # Another sequential step\n  step -&gt;(result) { result.continue(finalize(result.value)) }\nend\n</code></pre>"},{"location":"api/pipeline/#related-documentation","title":"Related Documentation","text":"<ul> <li>Result API - Result class reference</li> <li>Parallel Steps Guide - Using named steps</li> <li>Middleware API - Middleware reference</li> <li>Performance Guide - Optimization strategies</li> </ul>"},{"location":"api/result/","title":"Result API Reference","text":"<p>The <code>Result</code> class is an immutable value object that represents the outcome of a step in a SimpleFlow pipeline. It encapsulates the operation's value, contextual data, and any errors that occurred.</p>"},{"location":"api/result/#class-simpleflowresult","title":"Class: <code>SimpleFlow::Result</code>","text":"<p>Location: <code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/lib/simple_flow/result.rb</code></p>"},{"location":"api/result/#constructor","title":"Constructor","text":""},{"location":"api/result/#newvalue-context-errors","title":"<code>new(value, context: {}, errors: {})</code>","text":"<p>Creates a new Result instance.</p> <p>Parameters: - <code>value</code> (Object) - The outcome of the operation - <code>context</code> (Hash, optional) - Contextual data related to the operation (default: <code>{}</code>) - <code>errors</code> (Hash, optional) - Errors organized by category (default: <code>{}</code>)</p> <p>Returns: Result instance</p> <p>Example: <pre><code># Basic result\nresult = SimpleFlow::Result.new(42)\n\n# Result with context\nresult = SimpleFlow::Result.new(\n  { user_id: 123 },\n  context: { timestamp: Time.now }\n)\n\n# Result with errors\nresult = SimpleFlow::Result.new(\n  nil,\n  errors: { validation: [\"Email is required\"] }\n)\n</code></pre></p>"},{"location":"api/result/#instance-attributes","title":"Instance Attributes","text":""},{"location":"api/result/#value","title":"<code>value</code>","text":"<p>The outcome of the operation.</p> <p>Type: Object (read-only)</p> <p>Example: <pre><code>result = SimpleFlow::Result.new(42)\nresult.value  # =&gt; 42\n</code></pre></p>"},{"location":"api/result/#context","title":"<code>context</code>","text":"<p>Contextual data related to the operation.</p> <p>Type: Hash (read-only)</p> <p>Example: <pre><code>result = SimpleFlow::Result.new(42, context: { user: \"John\" })\nresult.context  # =&gt; { user: \"John\" }\n</code></pre></p>"},{"location":"api/result/#errors","title":"<code>errors</code>","text":"<p>Errors that occurred during the operation, organized by category.</p> <p>Type: Hash (read-only)</p> <p>Example: <pre><code>result = SimpleFlow::Result.new(nil, errors: {\n  validation: [\"Email required\", \"Password too short\"],\n  auth: [\"Invalid credentials\"]\n})\n\nresult.errors[:validation]  # =&gt; [\"Email required\", \"Password too short\"]\nresult.errors[:auth]        # =&gt; [\"Invalid credentials\"]\n</code></pre></p>"},{"location":"api/result/#instance-methods","title":"Instance Methods","text":""},{"location":"api/result/#with_contextkey-value","title":"<code>with_context(key, value)</code>","text":"<p>Adds or updates context to the result. Returns a new Result instance with updated context.</p> <p>Parameters: - <code>key</code> (Symbol) - The key to store the context under - <code>value</code> (Object) - The value to store</p> <p>Returns: New Result instance</p> <p>Immutability: This method creates a new Result object; the original is unchanged.</p> <p>Example: <pre><code>result = SimpleFlow::Result.new(42)\n  .with_context(:user_id, 123)\n  .with_context(:timestamp, Time.now)\n\nresult.context  # =&gt; { user_id: 123, timestamp: 2025-11-15 12:00:00 }\n</code></pre></p> <p>Chaining: <pre><code>result = SimpleFlow::Result.new(data)\n  .with_context(:step_name, \"process_data\")\n  .with_context(:duration, 0.5)\n  .with_context(:source, :api)\n</code></pre></p>"},{"location":"api/result/#with_errorkey-message","title":"<code>with_error(key, message)</code>","text":"<p>Adds an error message under a specific key. If the key already exists, the message is appended to existing errors. Returns a new Result instance with updated errors.</p> <p>Parameters: - <code>key</code> (Symbol) - The category under which to store the error - <code>message</code> (String) - The error message</p> <p>Returns: New Result instance</p> <p>Immutability: Creates a new Result object.</p> <p>Example: <pre><code>result = SimpleFlow::Result.new(nil)\n  .with_error(:validation, \"Email is required\")\n  .with_error(:validation, \"Password too short\")\n  .with_error(:auth, \"Invalid credentials\")\n\nresult.errors\n# =&gt; {\n#      validation: [\"Email is required\", \"Password too short\"],\n#      auth: [\"Invalid credentials\"]\n#    }\n</code></pre></p> <p>Error Accumulation: <pre><code>result = SimpleFlow::Result.new(data)\n\n# Add first validation error\nresult = result.with_error(:validation, \"Name is required\")\n\n# Add second validation error (accumulates)\nresult = result.with_error(:validation, \"Email is required\")\n\nresult.errors[:validation]\n# =&gt; [\"Name is required\", \"Email is required\"]\n</code></pre></p>"},{"location":"api/result/#haltnew_value-nil","title":"<code>halt(new_value = nil)</code>","text":"<p>Halts the pipeline flow. Optionally updates the result's value. Returns a new Result instance with <code>continue</code> set to false.</p> <p>Parameters: - <code>new_value</code> (Object, optional) - New value to set (default: keep current value)</p> <p>Returns: New Result instance with <code>@continue = false</code></p> <p>Example: <pre><code># Halt without changing value\nresult = SimpleFlow::Result.new(42).halt\nresult.continue?  # =&gt; false\nresult.value      # =&gt; 42\n\n# Halt with new value\nresult = SimpleFlow::Result.new(42).halt(100)\nresult.continue?  # =&gt; false\nresult.value      # =&gt; 100\n\n# Halt with error\nresult = SimpleFlow::Result.new(data)\n  .halt\n  .with_error(:validation, \"Invalid input\")\n\nresult.continue?  # =&gt; false\nresult.errors     # =&gt; { validation: [\"Invalid input\"] }\n</code></pre></p> <p>Usage in Steps: <pre><code>step -&gt;(result) {\n  if invalid?(result.value)\n    result.halt.with_error(:validation, \"Invalid data\")\n  else\n    result.continue(process(result.value))\n  end\n}\n</code></pre></p>"},{"location":"api/result/#continuenew_value","title":"<code>continue(new_value)</code>","text":"<p>Continues the pipeline flow with an updated value. Returns a new Result instance with the new value.</p> <p>Parameters: - <code>new_value</code> (Object) - The new value to set</p> <p>Returns: New Result instance with updated value</p> <p>Example: <pre><code>result = SimpleFlow::Result.new(5)\n  .continue(10)\n\nresult.continue?  # =&gt; true\nresult.value      # =&gt; 10\n</code></pre></p> <p>Usage in Steps: <pre><code>step -&gt;(result) {\n  transformed = transform(result.value)\n  result.continue(transformed)\n}\n</code></pre></p>"},{"location":"api/result/#continue","title":"<code>continue?</code>","text":"<p>Checks if the pipeline should continue executing.</p> <p>Returns: Boolean - <code>true</code> if the pipeline should continue - <code>false</code> if the pipeline has been halted</p> <p>Example: <pre><code>result = SimpleFlow::Result.new(42)\nresult.continue?  # =&gt; true\n\nresult = result.halt\nresult.continue?  # =&gt; false\n</code></pre></p> <p>Usage: <pre><code>result = pipeline.call(initial_data)\n\nif result.continue?\n  puts \"Success: #{result.value}\"\n  process_result(result)\nelse\n  puts \"Failed: #{result.errors}\"\n  handle_errors(result)\nend\n</code></pre></p>"},{"location":"api/result/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/result/#basic-flow-control","title":"Basic Flow Control","text":"<pre><code>step -&gt;(result) {\n  if valid?(result.value)\n    result.continue(result.value)\n  else\n    result.halt.with_error(:validation, \"Invalid\")\n  end\n}\n</code></pre>"},{"location":"api/result/#error-accumulation","title":"Error Accumulation","text":"<pre><code>step -&gt;(result) {\n  result_obj = result\n\n  if invalid_email?(result.value[:email])\n    result_obj = result_obj.with_error(:email, \"Invalid format\")\n  end\n\n  if invalid_phone?(result.value[:phone])\n    result_obj = result_obj.with_error(:phone, \"Invalid format\")\n  end\n\n  # Continue even with errors (check later)\n  result_obj.continue(result.value)\n}\n\nstep -&gt;(result) {\n  if result.errors.any?\n    result.halt(result.value)\n  else\n    result.continue(result.value)\n  end\n}\n</code></pre>"},{"location":"api/result/#context-propagation","title":"Context Propagation","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    result\n      .with_context(:started_at, Time.now)\n      .with_context(:user_id, 123)\n      .continue(result.value)\n  }\n\n  step -&gt;(result) {\n    # Access context from previous step\n    user_id = result.context[:user_id]\n    data = fetch_user_data(user_id)\n\n    result\n      .with_context(:user_data, data)\n      .continue(result.value)\n  }\n\n  step -&gt;(result) {\n    # All context available\n    duration = Time.now - result.context[:started_at]\n\n    result\n      .with_context(:duration, duration)\n      .continue(process(result.value))\n  }\nend\n</code></pre>"},{"location":"api/result/#combining-operations","title":"Combining Operations","text":"<pre><code>step -&gt;(result) {\n  result\n    .with_context(:timestamp, Time.now)\n    .with_context(:source, :api)\n    .with_error(:warning, \"Deprecated API version\")\n    .continue(transformed_data)\n}\n</code></pre>"},{"location":"api/result/#implementation-details","title":"Implementation Details","text":""},{"location":"api/result/#immutability","title":"Immutability","text":"<p>All Result methods return new instances:</p> <pre><code>original = SimpleFlow::Result.new(42)\nmodified = original.with_context(:key, \"value\")\n\noriginal.context  # =&gt; {}\nmodified.context  # =&gt; { key: \"value\" }\n\n# original and modified are different objects\noriginal.object_id != modified.object_id  # =&gt; true\n</code></pre>"},{"location":"api/result/#internal-state","title":"Internal State","text":"<p>The Result class maintains internal state that is preserved across method calls:</p> <pre><code>result = SimpleFlow::Result.new(42)\n  .halt\n  .with_context(:key, \"value\")\n\n# @continue flag is preserved\nresult.continue?  # =&gt; false\nresult.context    # =&gt; { key: \"value\" }\n</code></pre>"},{"location":"api/result/#thread-safety","title":"Thread Safety","text":"<p>Result objects are immutable and thread-safe. Multiple threads can safely read from the same Result instance.</p>"},{"location":"api/result/#related-documentation","title":"Related Documentation","text":"<ul> <li>Pipeline API - How pipelines use Result objects</li> <li>Error Handling Guide - Error handling patterns</li> <li>Validation Patterns - Validation strategies</li> </ul>"},{"location":"concurrent/best-practices/","title":"Best Practices for Concurrent Execution","text":"<p>This guide provides comprehensive best practices for designing, implementing, and debugging concurrent pipelines in SimpleFlow.</p>"},{"location":"concurrent/best-practices/#design-principles","title":"Design Principles","text":""},{"location":"concurrent/best-practices/#1-embrace-immutability","title":"1. Embrace Immutability","text":"<p>SimpleFlow's Result objects are immutable by design. Embrace this pattern throughout your pipeline:</p> <pre><code># GOOD: Creating new results\nstep :transform_data, -&gt;(result) {\n  transformed = result.value.map(&amp;:upcase)\n  result.continue(transformed)  # Returns new Result\n}\n\n# GOOD: Adding context\nstep :enrich_data, -&gt;(result) {\n  result\n    .with_context(:timestamp, Time.now)\n    .with_context(:source, \"api\")\n    .continue(result.value)\n}\n\n# BAD: Mutating input\nstep :bad_transform, -&gt;(result) {\n  result.value.map!(&amp;:upcase)  # Mutates shared data!\n  result.continue(result.value)\n}\n</code></pre>"},{"location":"concurrent/best-practices/#2-design-independent-steps","title":"2. Design Independent Steps","text":"<p>Parallel steps should be completely independent:</p> <pre><code># GOOD: Independent operations\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_weather, -&gt;(result) {\n    weather = WeatherAPI.fetch(result.value[:location])\n    result.with_context(:weather, weather).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_traffic, -&gt;(result) {\n    traffic = TrafficAPI.fetch(result.value[:location])\n    result.with_context(:traffic, traffic).continue(result.value)\n  }, depends_on: []\nend\n\n# BAD: Steps that depend on execution order\ncounter = 0\npipeline = SimpleFlow::Pipeline.new do\n  step :increment, -&gt;(result) {\n    counter += 1  # Race condition!\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :read_counter, -&gt;(result) {\n    result.with_context(:count, counter).continue(result.value)\n  }, depends_on: []\nend\n</code></pre>"},{"location":"concurrent/best-practices/#3-use-context-for-communication","title":"3. Use Context for Communication","text":"<p>Pass data between steps exclusively through the Result context:</p> <pre><code># GOOD: Context-based communication\npipeline = SimpleFlow::Pipeline.new do\n  step :load_user, -&gt;(result) {\n    user = User.find(result.value)\n    result.with_context(:user, user).continue(result.value)\n  }, depends_on: []\n\n  step :load_preferences, -&gt;(result) {\n    user_id = result.context[:user][:id]\n    prefs = Preferences.find_by(user_id: user_id)\n    result.with_context(:preferences, prefs).continue(result.value)\n  }, depends_on: [:load_user]\nend\n\n# BAD: Instance variables\nclass PipelineRunner\n  def initialize\n    @shared_data = {}\n  end\n\n  def build_pipeline\n    SimpleFlow::Pipeline.new do\n      step :store_data, -&gt;(result) {\n        @shared_data[:key] = result.value  # Don't do this!\n        result.continue(result.value)\n      }, depends_on: []\n\n      step :read_data, -&gt;(result) {\n        data = @shared_data[:key]  # Race condition!\n        result.continue(data)\n      }, depends_on: []\n    end\n  end\nend\n</code></pre>"},{"location":"concurrent/best-practices/#dependency-management","title":"Dependency Management","text":""},{"location":"concurrent/best-practices/#1-declare-all-dependencies-explicitly","title":"1. Declare All Dependencies Explicitly","text":"<p>Be exhaustive when declaring dependencies:</p> <pre><code># GOOD: All dependencies declared\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_data, -&gt;(result) { ... }, depends_on: []\n  step :validate_data, -&gt;(result) { ... }, depends_on: [:fetch_data]\n  step :transform_data, -&gt;(result) { ... }, depends_on: [:validate_data]\n  step :save_data, -&gt;(result) { ... }, depends_on: [:transform_data]\nend\n\n# BAD: Missing dependencies\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_data, -&gt;(result) { ... }, depends_on: []\n  step :transform_data, -&gt;(result) { ... }, depends_on: []  # Should depend on fetch_data!\n  step :save_data, -&gt;(result) { ... }, depends_on: [:transform_data]\nend\n</code></pre>"},{"location":"concurrent/best-practices/#2-avoid-circular-dependencies","title":"2. Avoid Circular Dependencies","text":"<p>Circular dependencies will cause runtime errors:</p> <pre><code># BAD: Circular dependency\npipeline = SimpleFlow::Pipeline.new do\n  step :step_a, -&gt;(result) { ... }, depends_on: [:step_b]\n  step :step_b, -&gt;(result) { ... }, depends_on: [:step_a]\nend\n# Raises TSort::Cyclic error\n</code></pre>"},{"location":"concurrent/best-practices/#3-minimize-dependency-chains","title":"3. Minimize Dependency Chains","text":"<p>Flatten dependency chains when possible to maximize parallelism:</p> <pre><code># GOOD: Maximum parallelism\npipeline = SimpleFlow::Pipeline.new do\n  step :validate, -&gt;(result) { ... }, depends_on: []\n\n  # All depend only on validate - can run in parallel\n  step :check_inventory, -&gt;(result) { ... }, depends_on: [:validate]\n  step :check_pricing, -&gt;(result) { ... }, depends_on: [:validate]\n  step :check_shipping, -&gt;(result) { ... }, depends_on: [:validate]\n  step :check_discounts, -&gt;(result) { ... }, depends_on: [:validate]\n\n  # Waits for all parallel steps\n  step :finalize, -&gt;(result) { ... }, depends_on: [\n    :check_inventory,\n    :check_pricing,\n    :check_shipping,\n    :check_discounts\n  ]\nend\n\n# BAD: Sequential chain (slower)\npipeline = SimpleFlow::Pipeline.new do\n  step :validate, -&gt;(result) { ... }, depends_on: []\n  step :check_inventory, -&gt;(result) { ... }, depends_on: [:validate]\n  step :check_pricing, -&gt;(result) { ... }, depends_on: [:check_inventory]\n  step :check_shipping, -&gt;(result) { ... }, depends_on: [:check_pricing]\n  step :finalize, -&gt;(result) { ... }, depends_on: [:check_shipping]\nend\n# All steps run sequentially!\n</code></pre>"},{"location":"concurrent/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"concurrent/best-practices/#1-validate-early","title":"1. Validate Early","text":"<p>Place validation steps before expensive parallel operations:</p> <pre><code># GOOD: Validate before parallel execution\npipeline = SimpleFlow::Pipeline.new do\n  step :validate_input, -&gt;(result) {\n    if result.value[:email].nil?\n      return result.halt.with_error(:validation, \"Email required\")\n    end\n    result.continue(result.value)\n  }, depends_on: []\n\n  # Only execute if validation passes\n  step :fetch_user, -&gt;(result) { ... }, depends_on: [:validate_input]\n  step :fetch_orders, -&gt;(result) { ... }, depends_on: [:validate_input]\n  step :fetch_preferences, -&gt;(result) { ... }, depends_on: [:validate_input]\nend\n\n# BAD: Validate after expensive operations\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user, -&gt;(result) { ... }, depends_on: []\n  step :fetch_orders, -&gt;(result) { ... }, depends_on: []\n  step :fetch_preferences, -&gt;(result) { ... }, depends_on: []\n\n  step :validate_results, -&gt;(result) {\n    # Too late - already did expensive work!\n    if result.errors.any?\n      result.halt(result.value)\n    end\n  }, depends_on: [:fetch_user, :fetch_orders, :fetch_preferences]\nend\n</code></pre>"},{"location":"concurrent/best-practices/#2-accumulate-errors-then-halt","title":"2. Accumulate Errors, Then Halt","text":"<p>For validation pipelines, accumulate all errors before halting:</p> <pre><code># GOOD: Collect all validation errors\npipeline = SimpleFlow::Pipeline.new do\n  step :validate_email, -&gt;(result) {\n    if invalid_email?(result.value[:email])\n      result.with_error(:email, \"Invalid email format\")\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: []\n\n  step :validate_phone, -&gt;(result) {\n    if invalid_phone?(result.value[:phone])\n      result.with_error(:phone, \"Invalid phone format\")\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: []\n\n  step :validate_age, -&gt;(result) {\n    if result.value[:age] &lt; 18\n      result.with_error(:age, \"Must be 18 or older\")\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: []\n\n  # Check all errors at once\n  step :check_validations, -&gt;(result) {\n    if result.errors.any?\n      result.halt(result.value)\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: [:validate_email, :validate_phone, :validate_age]\nend\n\n# User gets all validation errors at once, not just the first one\n</code></pre>"},{"location":"concurrent/best-practices/#3-add-context-to-errors","title":"3. Add Context to Errors","text":"<p>Include helpful debugging information:</p> <pre><code>step :process_file, -&gt;(result) {\n  begin\n    data = File.read(result.value[:path])\n    parsed = JSON.parse(data)\n    result.with_context(:file_size, data.size).continue(parsed)\n  rescue Errno::ENOENT =&gt; e\n    result.halt.with_error(\n      :file_error,\n      \"File not found: #{result.value[:path]}\"\n    )\n  rescue JSON::ParserError =&gt; e\n    result.halt.with_error(\n      :parse_error,\n      \"Invalid JSON in #{result.value[:path]}: #{e.message}\"\n    )\n  end\n}\n</code></pre>"},{"location":"concurrent/best-practices/#performance-optimization","title":"Performance Optimization","text":""},{"location":"concurrent/best-practices/#1-use-parallelism-for-io-operations","title":"1. Use Parallelism for I/O Operations","text":"<p>Prioritize parallelizing I/O-bound operations:</p> <pre><code># GOOD: Parallel I/O operations\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_api_a, -&gt;(result) {\n    # Network I/O - benefits from parallelism\n    response = HTTP.get(\"https://api-a.example.com\")\n    result.with_context(:api_a, response).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_api_b, -&gt;(result) {\n    # Network I/O - benefits from parallelism\n    response = HTTP.get(\"https://api-b.example.com\")\n    result.with_context(:api_b, response).continue(result.value)\n  }, depends_on: []\nend\n\n# Sequential: ~200ms (100ms per API call)\n# Parallel: ~100ms\n# Speedup: 2x\n</code></pre>"},{"location":"concurrent/best-practices/#2-keep-cpu-bound-operations-sequential","title":"2. Keep CPU-Bound Operations Sequential","text":"<p>Don't parallelize CPU-intensive calculations (due to GIL):</p> <pre><code># Keep CPU-bound operations sequential\npipeline = SimpleFlow::Pipeline.new do\n  step :calculate_fibonacci, -&gt;(result) {\n    # CPU-bound - no benefit from parallelism\n    fib = calculate_fib(result.value)\n    result.continue(fib)\n  }, depends_on: []\n\n  step :process_result, -&gt;(result) {\n    result.continue(result.value * 2)\n  }, depends_on: [:calculate_fibonacci]\nend\n</code></pre>"},{"location":"concurrent/best-practices/#3-minimize-context-payload","title":"3. Minimize Context Payload","text":"<p>Keep context lean to reduce merging overhead:</p> <pre><code># GOOD: Minimal context\nstep :fetch_users, -&gt;(result) {\n  users = UserService.all\n  user_count = users.size\n  result.with_context(:user_count, user_count).continue(result.value)\n}\n\n# BAD: Large context\nstep :fetch_users, -&gt;(result) {\n  users = UserService.all  # Could be thousands of records\n  result.with_context(:all_users, users).continue(result.value)\n}\n</code></pre>"},{"location":"concurrent/best-practices/#testing-strategies","title":"Testing Strategies","text":""},{"location":"concurrent/best-practices/#1-test-steps-in-isolation","title":"1. Test Steps in Isolation","text":"<p>Design steps to be testable independently:</p> <pre><code># GOOD: Testable step\nclass FetchUserStep\n  def call(result)\n    user = UserService.find(result.value)\n    result.with_context(:user, user).continue(result.value)\n  end\nend\n\n# Easy to test\ndescribe FetchUserStep do\n  it \"fetches user and adds to context\" do\n    step = FetchUserStep.new\n    result = SimpleFlow::Result.new(123)\n\n    output = step.call(result)\n\n    expect(output.context[:user]).to be_present\n    expect(output.continue?).to be true\n  end\nend\n\n# Use in pipeline\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user, FetchUserStep.new, depends_on: []\nend\n</code></pre>"},{"location":"concurrent/best-practices/#2-test-dependency-graphs","title":"2. Test Dependency Graphs","text":"<p>Verify your dependency structure:</p> <pre><code>describe \"OrderPipeline\" do\n  let(:pipeline) { OrderPipeline.build }\n\n  it \"has correct dependency structure\" do\n    graph = pipeline.dependency_graph\n\n    expect(graph.dependencies[:validate_order]).to eq([])\n    expect(graph.dependencies[:check_inventory]).to eq([:validate_order])\n    expect(graph.dependencies[:calculate_total]).to eq([\n      :check_inventory,\n      :check_pricing\n    ])\n  end\n\n  it \"groups parallel steps correctly\" do\n    graph = pipeline.dependency_graph\n    groups = graph.parallel_order\n\n    # Check inventory and pricing run in parallel\n    expect(groups[1]).to include(:check_inventory, :check_pricing)\n  end\nend\n</code></pre>"},{"location":"concurrent/best-practices/#3-test-both-sequential-and-parallel-execution","title":"3. Test Both Sequential and Parallel Execution","text":"<p>Ensure your pipeline works in both modes:</p> <pre><code>describe \"DataPipeline\" do\n  let(:pipeline) { DataPipeline.build }\n  let(:input) { SimpleFlow::Result.new(data) }\n\n  it \"produces same result sequentially\" do\n    result = pipeline.call(input)\n    expect(result.value).to eq(expected_output)\n  end\n\n  it \"produces same result in parallel\" do\n    result = pipeline.call_parallel(input)\n    expect(result.value).to eq(expected_output)\n  end\n\n  it \"merges context from parallel steps\" do\n    result = pipeline.call_parallel(input)\n    expect(result.context).to include(:data_a, :data_b, :data_c)\n  end\nend\n</code></pre>"},{"location":"concurrent/best-practices/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"concurrent/best-practices/#1-use-visualization-tools","title":"1. Use Visualization Tools","text":"<p>Visualize your pipeline to understand execution flow:</p> <pre><code>pipeline = OrderPipeline.build\n\n# ASCII visualization for quick debugging\nputs pipeline.visualize_ascii\n\n# Detailed execution plan\nputs pipeline.execution_plan\n\n# Generate diagram for documentation\nFile.write('pipeline.dot', pipeline.visualize_dot)\nsystem('dot -Tpng pipeline.dot -o pipeline.png')\n</code></pre>"},{"location":"concurrent/best-practices/#2-add-logging-middleware","title":"2. Add Logging Middleware","text":"<p>Use middleware to trace execution:</p> <pre><code>class DetailedLogging\n  def initialize(callable, step_name: nil)\n    @callable = callable\n    @step_name = step_name\n  end\n\n  def call(result)\n    puts \"[#{Time.now}] Starting #{@step_name}\"\n    puts \"  Input value: #{result.value.inspect}\"\n\n    output = @callable.call(result)\n\n    puts \"[#{Time.now}] Completed #{@step_name}\"\n    puts \"  Output value: #{output.value.inspect}\"\n    puts \"  Continue? #{output.continue?}\"\n    puts \"  Errors: #{output.errors}\" if output.errors.any?\n    puts\n\n    output\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware DetailedLogging, step_name: \"pipeline step\"\n\n  step :fetch_data, -&gt;(result) { ... }, depends_on: []\n  step :process_data, -&gt;(result) { ... }, depends_on: [:fetch_data]\nend\n</code></pre>"},{"location":"concurrent/best-practices/#3-track-step-execution-time","title":"3. Track Step Execution Time","text":"<p>Measure performance of individual steps:</p> <pre><code>class TimingMiddleware\n  def initialize(callable, step_name:)\n    @callable = callable\n    @step_name = step_name\n  end\n\n  def call(result)\n    start_time = Time.now\n    output = @callable.call(result)\n    duration = Time.now - start_time\n\n    output.with_context(\n      \"#{@step_name}_duration\".to_sym,\n      duration\n    )\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware TimingMiddleware, step_name: \"my_step\"\n\n  step :slow_operation, -&gt;(result) { ... }, depends_on: []\nend\n\nresult = pipeline.call(initial_data)\nputs \"Execution time: #{result.context[:slow_operation_duration]}s\"\n</code></pre>"},{"location":"concurrent/best-practices/#code-organization","title":"Code Organization","text":""},{"location":"concurrent/best-practices/#1-extract-steps-to-classes","title":"1. Extract Steps to Classes","text":"<p>For complex steps, use dedicated classes:</p> <pre><code># GOOD: Dedicated step classes\nmodule OrderPipeline\n  class ValidateOrder\n    def call(result)\n      order = result.value\n      errors = []\n\n      errors &lt;&lt; \"Missing email\" unless order[:email]\n      errors &lt;&lt; \"No items\" if order[:items].empty?\n\n      if errors.any?\n        result.halt.with_error(:validation, errors.join(\", \"))\n      else\n        result.continue(order)\n      end\n    end\n  end\n\n  class CalculateTotal\n    def call(result)\n      items = result.context[:items]\n      shipping = result.context[:shipping]\n\n      subtotal = items.sum { |i| i[:price] * i[:quantity] }\n      total = subtotal + shipping\n\n      result.with_context(:total, total).continue(result.value)\n    end\n  end\n\n  def self.build\n    SimpleFlow::Pipeline.new do\n      step :validate, ValidateOrder.new, depends_on: []\n      step :calculate_total, CalculateTotal.new, depends_on: [:validate]\n    end\n  end\nend\n</code></pre>"},{"location":"concurrent/best-practices/#2-use-builder-pattern","title":"2. Use Builder Pattern","text":"<p>Create pipeline builders for complex workflows:</p> <pre><code>class EcommercePipelineBuilder\n  def self.build(options = {})\n    SimpleFlow::Pipeline.new do\n      if options[:enable_logging]\n        use_middleware SimpleFlow::MiddleWare::Logging\n      end\n\n      # Validation phase\n      step :validate_order, ValidateOrder.new, depends_on: []\n\n      # Parallel checks\n      step :check_inventory, CheckInventory.new, depends_on: [:validate_order]\n      step :check_pricing, CheckPricing.new, depends_on: [:validate_order]\n      step :check_shipping, CheckShipping.new, depends_on: [:validate_order]\n\n      # Process payment\n      step :calculate_total, CalculateTotal.new,\n        depends_on: [:check_inventory, :check_pricing, :check_shipping]\n\n      step :process_payment, ProcessPayment.new,\n        depends_on: [:calculate_total]\n    end\n  end\nend\n\n# Use in application\npipeline = EcommercePipelineBuilder.build(enable_logging: true)\nresult = pipeline.call_parallel(order_data)\n</code></pre>"},{"location":"concurrent/best-practices/#3-document-dependencies","title":"3. Document Dependencies","text":"<p>Add comments explaining why dependencies exist:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Must validate before any processing\n  step :validate_input, -&gt;(result) { ... }, depends_on: []\n\n  # These checks are independent and can run in parallel\n  step :check_inventory, -&gt;(result) { ... }, depends_on: [:validate_input]\n  step :check_pricing, -&gt;(result) { ... }, depends_on: [:validate_input]\n\n  # Discount requires both inventory (stock levels) and pricing\n  step :calculate_discount, -&gt;(result) { ... },\n    depends_on: [:check_inventory, :check_pricing]\nend\n</code></pre>"},{"location":"concurrent/best-practices/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"concurrent/best-practices/#1-avoid-premature-parallelization","title":"1. Avoid Premature Parallelization","text":"<p>Don't parallelize until you have measured performance:</p> <pre><code># Start simple\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { fetch_data(result.value) }\n  step -&gt;(result) { transform_data(result.value) }\n  step -&gt;(result) { save_data(result.value) }\nend\n\n# Measure\ntime = Benchmark.realtime { pipeline.call(data) }\n\n# Only add parallelism if it helps\nif time &gt; 1.0  # If pipeline takes &gt; 1 second\n  # Refactor to use named steps with parallelism\nend\n</code></pre>"},{"location":"concurrent/best-practices/#2-dont-parallelize-everything","title":"2. Don't Parallelize Everything","text":"<p>Not all steps benefit from parallelism:</p> <pre><code># BAD: Unnecessary parallelism\npipeline = SimpleFlow::Pipeline.new do\n  step :upcase, -&gt;(result) {\n    result.continue(result.value.upcase)  # Fast operation\n  }, depends_on: []\n\n  step :reverse, -&gt;(result) {\n    result.continue(result.value.reverse)  # Fast operation\n  }, depends_on: []\nend\n\n# Parallel overhead &gt; benefit for fast operations\n</code></pre>"},{"location":"concurrent/best-practices/#3-watch-for-deadlocks","title":"3. Watch for Deadlocks","text":"<p>Ensure database connections and resources are properly managed:</p> <pre><code># GOOD: Connection pooling\nDB = Sequel.connect(\n  'postgres://localhost/db',\n  max_connections: 10  # Allow 10 concurrent connections\n)\n\n# BAD: Single connection\nDB = Sequel.connect('postgres://localhost/db')\n# Parallel steps will deadlock waiting for the connection!\n</code></pre>"},{"location":"concurrent/best-practices/#related-documentation","title":"Related Documentation","text":"<ul> <li>Parallel Steps Guide - How to use named steps with dependencies</li> <li>Performance Guide - Understanding parallel execution performance</li> <li>Testing Guide - Testing strategies for pipelines</li> <li>Pipeline API - Complete Pipeline API reference</li> </ul>"},{"location":"concurrent/introduction/","title":"Concurrent Execution","text":"<p>One of SimpleFlow's most powerful features is the ability to execute independent steps concurrently using fiber-based concurrency.</p>"},{"location":"concurrent/introduction/#why-concurrent-execution","title":"Why Concurrent Execution?","text":"<p>Many workflows have steps that don't depend on each other and can run at the same time:</p> <ul> <li>Fetching data from multiple APIs</li> <li>Running independent validation checks</li> <li>Processing multiple files</li> <li>Enriching data from various sources</li> </ul> <p>Running these steps concurrently can dramatically improve performance.</p>"},{"location":"concurrent/introduction/#performance-benefits","title":"Performance Benefits","text":"<p>Consider fetching data from 4 APIs:</p> <p>Sequential Execution: ~0.4s <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { fetch_api_1(result) }  # 0.1s\n  step -&gt;(result) { fetch_api_2(result) }  # 0.1s\n  step -&gt;(result) { fetch_api_3(result) }  # 0.1s\n  step -&gt;(result) { fetch_api_4(result) }  # 0.1s\nend\n# Total: 0.4s\n</code></pre></p> <p>Parallel Execution: ~0.1s <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  parallel do\n    step -&gt;(result) { fetch_api_1(result) }  # \u2510\n    step -&gt;(result) { fetch_api_2(result) }  # \u251c\u2500 All run\n    step -&gt;(result) { fetch_api_3(result) }  # \u251c\u2500 concurrently\n    step -&gt;(result) { fetch_api_4(result) }  # \u2518\n  end\nend\n# Total: ~0.1s (4x speedup!)\n</code></pre></p>"},{"location":"concurrent/introduction/#basic-usage","title":"Basic Usage","text":"<p>Use the <code>parallel</code> block in your pipeline:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # This runs first (sequential)\n  step -&gt;(result) { initialize_data(result) }\n\n  # These run concurrently\n  parallel do\n    step -&gt;(result) { fetch_orders(result) }\n    step -&gt;(result) { fetch_preferences(result) }\n    step -&gt;(result) { fetch_analytics(result) }\n  end\n\n  # This waits for all parallel steps to complete\n  step -&gt;(result) { aggregate_results(result) }\nend\n</code></pre>"},{"location":"concurrent/introduction/#how-it-works","title":"How It Works","text":""},{"location":"concurrent/introduction/#fiber-based-concurrency","title":"Fiber-Based Concurrency","text":"<p>SimpleFlow uses the Async gem which provides fiber-based concurrency:</p> <ul> <li>No threading overhead: Fibers are lightweight</li> <li>No GIL limitations: Not affected by Ruby's Global Interpreter Lock</li> <li>Perfect for I/O: Ideal for network requests, file operations, etc.</li> </ul>"},{"location":"concurrent/introduction/#result-merging","title":"Result Merging","text":"<p>When parallel steps complete, their results are automatically merged:</p> <pre><code>parallel do\n  step -&gt;(result) { result.with_context(:a, 1).continue(result.value) }\n  step -&gt;(result) { result.with_context(:b, 2).continue(result.value) }\n  step -&gt;(result) { result.with_context(:c, 3).continue(result.value) }\nend\n\n# Merged result has all contexts: {:a=&gt;1, :b=&gt;2, :c=&gt;3}\n</code></pre> <p>Merging Rules: - Values: Uses the last non-halted result's value - Contexts: Merges all contexts together - Errors: Merges all errors together - Continue: If any step halts, the merged result is halted</p>"},{"location":"concurrent/introduction/#real-world-example","title":"Real-World Example","text":""},{"location":"concurrent/introduction/#user-data-aggregation","title":"User Data Aggregation","text":"<pre><code>require 'simple_flow'\nrequire 'net/http'\nrequire 'json'\n\npipeline = SimpleFlow::Pipeline.new do\n  # Validate user ID\n  step -&gt;(result) {\n    user_id = result.value\n    user_id &gt; 0 ?\n      result.continue(user_id) :\n      result.halt.with_error(:validation, \"Invalid user ID\")\n  }\n\n  # Fetch data from multiple services concurrently\n  parallel do\n    step -&gt;(result) {\n      user_id = result.value\n      profile = fetch_user_profile(user_id)\n      result.with_context(:profile, profile).continue(user_id)\n    }\n\n    step -&gt;(result) {\n      user_id = result.value\n      orders = fetch_user_orders(user_id)\n      result.with_context(:orders, orders).continue(user_id)\n    }\n\n    step -&gt;(result) {\n      user_id = result.value\n      preferences = fetch_user_preferences(user_id)\n      result.with_context(:preferences, preferences).continue(user_id)\n    }\n\n    step -&gt;(result) {\n      user_id = result.value\n      analytics = fetch_user_analytics(user_id)\n      result.with_context(:analytics, analytics).continue(user_id)\n    }\n  end\n\n  # Aggregate all fetched data\n  step -&gt;(result) {\n    aggregated = {\n      user_id: result.value,\n      profile: result.context[:profile],\n      orders: result.context[:orders],\n      preferences: result.context[:preferences],\n      analytics: result.context[:analytics]\n    }\n    result.continue(aggregated)\n  }\nend\n\n# Execute\nresult = pipeline.call(SimpleFlow::Result.new(123))\nputs result.value[:profile]\n# =&gt; {...}\n</code></pre>"},{"location":"concurrent/introduction/#multiple-parallel-blocks","title":"Multiple Parallel Blocks","text":"<p>You can have multiple parallel blocks in a pipeline:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { initialize(result) }\n\n  # First parallel block\n  parallel do\n    step -&gt;(result) { fetch_data_a(result) }\n    step -&gt;(result) { fetch_data_b(result) }\n  end\n\n  step -&gt;(result) { process_first_batch(result) }\n\n  # Second parallel block\n  parallel do\n    step -&gt;(result) { enrich_data_a(result) }\n    step -&gt;(result) { enrich_data_b(result) }\n    step -&gt;(result) { enrich_data_c(result) }\n  end\n\n  step -&gt;(result) { finalize(result) }\nend\n</code></pre>"},{"location":"concurrent/introduction/#error-handling","title":"Error Handling","text":"<p>If any parallel step halts, the entire parallel block halts:</p> <pre><code>parallel do\n  step -&gt;(result) { result.continue(\"success\") }\n  step -&gt;(result) { result.halt.with_error(:service, \"Failed\") }\n  step -&gt;(result) { result.continue(\"success\") }\nend\n# Result is halted with error: {:service=&gt;[\"Failed\"]}\n</code></pre> <p>All errors are accumulated:</p> <pre><code>parallel do\n  step -&gt;(result) { result.with_error(:a, \"Error A\").continue(result.value) }\n  step -&gt;(result) { result.with_error(:b, \"Error B\").continue(result.value) }\nend\n# Result has errors: {:a=&gt;[\"Error A\"], :b=&gt;[\"Error B\"]}\n</code></pre>"},{"location":"concurrent/introduction/#best-practices","title":"Best Practices","text":""},{"location":"concurrent/introduction/#good-use-cases","title":"\u2705 Good Use Cases","text":"<ul> <li>Independent I/O operations: API calls, database queries</li> <li>Independent validations: Multiple validation checks</li> <li>Data enrichment: Fetching supplementary data</li> <li>File processing: Processing multiple files</li> </ul>"},{"location":"concurrent/introduction/#poor-use-cases","title":"\u274c Poor Use Cases","text":"<ul> <li>Dependent operations: When step B needs step A's result</li> <li>CPU-intensive work: Better with threading or processes</li> <li>Shared mutable state: Could cause race conditions</li> <li>Very quick operations: Overhead might outweigh benefits</li> </ul>"},{"location":"concurrent/introduction/#when-to-use-parallel-execution","title":"When to Use Parallel Execution","text":"<p>Use the <code>parallel</code> block when:</p> <ol> <li>\u2705 Steps are independent (don't depend on each other's results)</li> <li>\u2705 Steps are I/O-bound (network, file, database)</li> <li>\u2705 Total execution time of steps &gt; ~50ms</li> <li>\u2705 Steps can safely run concurrently</li> </ol> <p>Don't use <code>parallel</code> when:</p> <ol> <li>\u274c Steps depend on previous results</li> <li>\u274c Steps are very fast (&lt;10ms each)</li> <li>\u274c Steps modify shared state</li> <li>\u274c Steps are CPU-intensive</li> </ol>"},{"location":"concurrent/introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Parallel Steps Guide - Deep dive into ParallelStep</li> <li>Performance Tips - Optimize concurrent execution</li> <li>Best Practices - Patterns and anti-patterns</li> <li>Examples - See it in action</li> </ul>"},{"location":"concurrent/parallel-steps/","title":"Parallel Execution with Named Steps","text":"<p>SimpleFlow provides powerful parallel execution capabilities through two approaches: automatic parallel discovery using dependency graphs and explicit parallel blocks. This guide focuses on using named steps with dependencies for automatic parallelization.</p>"},{"location":"concurrent/parallel-steps/#overview","title":"Overview","text":"<p>When you define steps with names and dependencies, SimpleFlow automatically analyzes the dependency graph and executes independent steps concurrently. This provides optimal performance without requiring you to explicitly manage parallelism.</p>"},{"location":"concurrent/parallel-steps/#basic-concepts","title":"Basic Concepts","text":""},{"location":"concurrent/parallel-steps/#named-steps","title":"Named Steps","text":"<p>A named step is defined with three components:</p> <ol> <li>Name (Symbol) - Unique identifier for the step</li> <li>Callable (Proc/Lambda) - The code to execute</li> <li>Dependencies (Array of Symbols) - Steps that must complete first</li> </ol> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :step_name, -&gt;(result) {\n    # Your code here\n    result.continue(new_value)\n  }, depends_on: [:prerequisite_step]\nend\n</code></pre>"},{"location":"concurrent/parallel-steps/#dependency-declaration","title":"Dependency Declaration","text":"<p>Dependencies are declared using the <code>depends_on:</code> parameter:</p> <pre><code># No dependencies - can run immediately\nstep :initial_step, -&gt;(result) { ... }, depends_on: []\n\n# Depends on one step\nstep :second_step, -&gt;(result) { ... }, depends_on: [:initial_step]\n\n# Depends on multiple steps\nstep :final_step, -&gt;(result) { ... }, depends_on: [:second_step, :third_step]\n</code></pre>"},{"location":"concurrent/parallel-steps/#automatic-parallelization","title":"Automatic Parallelization","text":""},{"location":"concurrent/parallel-steps/#how-it-works","title":"How It Works","text":"<ol> <li>Graph Analysis: SimpleFlow builds a dependency graph from your step declarations</li> <li>Topological Sort: Steps are organized into execution groups using Ruby's TSort module</li> <li>Parallel Execution: Steps with all dependencies satisfied run concurrently</li> <li>Result Merging: Contexts and errors from parallel steps are automatically merged</li> </ol>"},{"location":"concurrent/parallel-steps/#simple-example","title":"Simple Example","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Step 1: Runs first (no dependencies)\n  step :fetch_user, -&gt;(result) {\n    user = UserService.find(result.value)\n    result.with_context(:user, user).continue(result.value)\n  }, depends_on: []\n\n  # Steps 2 &amp; 3: Run in parallel (both depend only on step 1)\n  step :fetch_orders, -&gt;(result) {\n    orders = OrderService.for_user(result.context[:user])\n    result.with_context(:orders, orders).continue(result.value)\n  }, depends_on: [:fetch_user]\n\n  step :fetch_preferences, -&gt;(result) {\n    prefs = PreferenceService.for_user(result.context[:user])\n    result.with_context(:preferences, prefs).continue(result.value)\n  }, depends_on: [:fetch_user]\n\n  # Step 4: Runs after both parallel steps complete\n  step :build_profile, -&gt;(result) {\n    profile = {\n      user: result.context[:user],\n      orders: result.context[:orders],\n      preferences: result.context[:preferences]\n    }\n    result.continue(profile)\n  }, depends_on: [:fetch_orders, :fetch_preferences]\nend\n\n# Execute with automatic parallelism\nresult = pipeline.call_parallel(SimpleFlow::Result.new(user_id))\n</code></pre> <p>Execution Flow: 1. <code>fetch_user</code> runs first 2. <code>fetch_orders</code> and <code>fetch_preferences</code> run in parallel 3. <code>build_profile</code> runs after both parallel steps complete</p>"},{"location":"concurrent/parallel-steps/#complex-dependency-graphs","title":"Complex Dependency Graphs","text":""},{"location":"concurrent/parallel-steps/#multi-level-parallelism","title":"Multi-Level Parallelism","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Level 1: Validation (sequential)\n  step :validate_input, -&gt;(result) {\n    # Validate request\n    result.with_context(:validated, true).continue(result.value)\n  }, depends_on: []\n\n  # Level 2: Three independent checks (parallel)\n  step :check_inventory, -&gt;(result) {\n    inventory = InventoryService.check(result.value)\n    result.with_context(:inventory, inventory).continue(result.value)\n  }, depends_on: [:validate_input]\n\n  step :check_pricing, -&gt;(result) {\n    price = PricingService.calculate(result.value)\n    result.with_context(:price, price).continue(result.value)\n  }, depends_on: [:validate_input]\n\n  step :check_shipping, -&gt;(result) {\n    shipping = ShippingService.calculate(result.value)\n    result.with_context(:shipping, shipping).continue(result.value)\n  }, depends_on: [:validate_input]\n\n  # Level 3: Calculate discount (depends on inventory and pricing)\n  step :calculate_discount, -&gt;(result) {\n    discount = DiscountService.calculate(\n      result.context[:inventory],\n      result.context[:price]\n    )\n    result.with_context(:discount, discount).continue(result.value)\n  }, depends_on: [:check_inventory, :check_pricing]\n\n  # Level 4: Finalize (depends on discount and shipping)\n  step :finalize_order, -&gt;(result) {\n    total = result.context[:price] +\n            result.context[:shipping] -\n            result.context[:discount]\n    result.continue(total)\n  }, depends_on: [:calculate_discount, :check_shipping]\nend\n</code></pre> <p>Execution Groups: - Group 1: <code>validate_input</code> (sequential) - Group 2: <code>check_inventory</code>, <code>check_pricing</code>, <code>check_shipping</code> (parallel) - Group 3: <code>calculate_discount</code> (sequential, waits for inventory and pricing) - Group 4: <code>finalize_order</code> (sequential, waits for discount and shipping)</p>"},{"location":"concurrent/parallel-steps/#context-merging","title":"Context Merging","text":"<p>When parallel steps complete, SimpleFlow automatically merges their contexts and errors:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :task_a, -&gt;(result) {\n    result.with_context(:data_a, \"from A\").continue(result.value)\n  }, depends_on: []\n\n  step :task_b, -&gt;(result) {\n    result.with_context(:data_b, \"from B\").continue(result.value)\n  }, depends_on: []\n\n  step :combine, -&gt;(result) {\n    # Both contexts are available\n    combined = {\n      a: result.context[:data_a],  # \"from A\"\n      b: result.context[:data_b]   # \"from B\"\n    }\n    result.continue(combined)\n  }, depends_on: [:task_a, :task_b]\nend\n</code></pre>"},{"location":"concurrent/parallel-steps/#error-accumulation","title":"Error Accumulation","text":"<p>Errors from parallel steps are also merged:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :validate_email, -&gt;(result) {\n    if invalid_email?(result.value[:email])\n      result.with_error(:email, \"Invalid format\")\n    end\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :validate_phone, -&gt;(result) {\n    if invalid_phone?(result.value[:phone])\n      result.with_error(:phone, \"Invalid format\")\n    end\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :check_errors, -&gt;(result) {\n    # Errors from both parallel validations are available\n    if result.errors.any?\n      result.halt(result.value)  # Stop if any validation failed\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: [:validate_email, :validate_phone]\nend\n</code></pre>"},{"location":"concurrent/parallel-steps/#halting-execution","title":"Halting Execution","text":"<p>If any parallel step calls <code>halt()</code>, the pipeline stops immediately:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :task_a, -&gt;(result) {\n    result.with_context(:success_a, true).continue(result.value)\n  }, depends_on: []\n\n  step :task_b, -&gt;(result) {\n    # This step fails\n    result.halt.with_error(:failure, \"Task B failed\")\n  }, depends_on: []\n\n  step :task_c, -&gt;(result) {\n    result.with_context(:success_c, true).continue(result.value)\n  }, depends_on: []\n\n  step :final_step, -&gt;(result) {\n    # This will NOT execute because task_b halted\n    result.continue(\"Completed\")\n  }, depends_on: [:task_a, :task_b, :task_c]\nend\n\nresult = pipeline.call_parallel(initial_data)\n# result.continue? =&gt; false\n# result.errors =&gt; {:failure =&gt; [\"Task B failed\"]}\n</code></pre>"},{"location":"concurrent/parallel-steps/#execution-methods","title":"Execution Methods","text":""},{"location":"concurrent/parallel-steps/#call_parallelresult-strategy-auto","title":"<code>call_parallel(result, strategy: :auto)</code>","text":"<p>Executes the pipeline with parallel support:</p> <pre><code># Automatic strategy (default) - uses dependency graph if named steps exist\nresult = pipeline.call_parallel(initial_result)\n\n# Automatic strategy (explicit)\nresult = pipeline.call_parallel(initial_result, strategy: :auto)\n\n# Explicit strategy - only uses explicit parallel blocks\nresult = pipeline.call_parallel(initial_result, strategy: :explicit)\n</code></pre>"},{"location":"concurrent/parallel-steps/#callresult","title":"<code>call(result)</code>","text":"<p>Executes sequentially (ignores parallelism):</p> <pre><code># Sequential execution - useful for debugging\nresult = pipeline.call(initial_result)\n</code></pre>"},{"location":"concurrent/parallel-steps/#visualizing-dependencies","title":"Visualizing Dependencies","text":""},{"location":"concurrent/parallel-steps/#ascii-visualization","title":"ASCII Visualization","text":"<pre><code># Print dependency graph to console\nputs pipeline.visualize_ascii\n\n# Hide parallel groups\nputs pipeline.visualize_ascii(show_groups: false)\n</code></pre>"},{"location":"concurrent/parallel-steps/#graphviz-dot-format","title":"Graphviz DOT Format","text":"<pre><code># Generate DOT file for visualization\ndot_content = pipeline.visualize_dot\nFile.write('pipeline.dot', dot_content)\n\n# Generate image: dot -Tpng pipeline.dot -o pipeline.png\n\n# Left-to-right orientation\ndot_content = pipeline.visualize_dot(orientation: 'LR')\n</code></pre>"},{"location":"concurrent/parallel-steps/#mermaid-diagrams","title":"Mermaid Diagrams","text":"<pre><code># Generate Mermaid diagram\nmermaid = pipeline.visualize_mermaid\nFile.write('pipeline.mmd', mermaid)\n\n# View at https://mermaid.live/\n</code></pre>"},{"location":"concurrent/parallel-steps/#execution-plan","title":"Execution Plan","text":"<pre><code># Get detailed execution analysis\nputs pipeline.execution_plan\n</code></pre> <p>Output includes: - Total steps and execution phases - Which steps run in parallel - Potential speedup vs sequential execution - Step-by-step execution order</p>"},{"location":"concurrent/parallel-steps/#best-practices","title":"Best Practices","text":""},{"location":"concurrent/parallel-steps/#1-design-independent-steps","title":"1. Design Independent Steps","text":"<p>Ensure parallel steps are truly independent:</p> <pre><code># GOOD: Independent operations\nstep :fetch_user_data, -&gt;(result) { ... }, depends_on: []\nstep :fetch_product_data, -&gt;(result) { ... }, depends_on: []\n\n# BAD: Steps that modify shared state\nstep :increment_counter, -&gt;(result) { @counter += 1; ... }, depends_on: []\nstep :read_counter, -&gt;(result) { puts @counter; ... }, depends_on: []\n</code></pre>"},{"location":"concurrent/parallel-steps/#2-use-context-for-data-sharing","title":"2. Use Context for Data Sharing","text":"<p>Pass data between steps using context, not instance variables:</p> <pre><code># GOOD: Using context\nstep :fetch_data, -&gt;(result) {\n  data = API.fetch(result.value)\n  result.with_context(:api_data, data).continue(result.value)\n}, depends_on: []\n\nstep :process_data, -&gt;(result) {\n  processed = transform(result.context[:api_data])\n  result.continue(processed)\n}, depends_on: [:fetch_data]\n\n# BAD: Using instance variables\n@shared_data = nil\nstep :fetch_data, -&gt;(result) {\n  @shared_data = API.fetch(result.value)  # Race condition!\n  result.continue(result.value)\n}, depends_on: []\n</code></pre>"},{"location":"concurrent/parallel-steps/#3-declare-all-dependencies","title":"3. Declare All Dependencies","text":"<p>Be explicit about dependencies to ensure correct execution order:</p> <pre><code># GOOD: Clear dependencies\nstep :load_config, -&gt;(result) { ... }, depends_on: []\nstep :validate_config, -&gt;(result) { ... }, depends_on: [:load_config]\nstep :apply_config, -&gt;(result) { ... }, depends_on: [:validate_config]\n\n# BAD: Missing dependencies\nstep :load_config, -&gt;(result) { ... }, depends_on: []\nstep :apply_config, -&gt;(result) { ... }, depends_on: []  # Should depend on load_config!\n</code></pre>"},{"location":"concurrent/parallel-steps/#4-keep-steps-focused","title":"4. Keep Steps Focused","text":"<p>Each step should have a single responsibility:</p> <pre><code># GOOD: Focused steps\nstep :fetch_user, -&gt;(result) { ... }, depends_on: []\nstep :fetch_orders, -&gt;(result) { ... }, depends_on: [:fetch_user]\nstep :calculate_total, -&gt;(result) { ... }, depends_on: [:fetch_orders]\n\n# BAD: Monolithic step\nstep :do_everything, -&gt;(result) {\n  user = fetch_user\n  orders = fetch_orders(user)\n  total = calculate_total(orders)\n  # Too much in one step!\n}, depends_on: []\n</code></pre>"},{"location":"concurrent/parallel-steps/#5-handle-errors-gracefully","title":"5. Handle Errors Gracefully","text":"<p>Add error handling at appropriate points:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Parallel data fetching\n  step :fetch_a, -&gt;(result) { ... }, depends_on: []\n  step :fetch_b, -&gt;(result) { ... }, depends_on: []\n\n  # Check for errors before proceeding\n  step :validate_fetch, -&gt;(result) {\n    if result.errors.any?\n      result.halt.with_error(:fetch, \"Failed to fetch required data\")\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: [:fetch_a, :fetch_b]\n\n  # Only runs if validation passes\n  step :process, -&gt;(result) { ... }, depends_on: [:validate_fetch]\nend\n</code></pre>"},{"location":"concurrent/parallel-steps/#real-world-example","title":"Real-World Example","text":"<p>See <code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/examples/06_real_world_ecommerce.rb</code> for a complete e-commerce order processing pipeline that demonstrates:</p> <ul> <li>Multi-level parallel execution</li> <li>Context merging</li> <li>Error handling</li> <li>Complex dependency relationships</li> </ul>"},{"location":"concurrent/parallel-steps/#related-documentation","title":"Related Documentation","text":"<ul> <li>Performance Characteristics - Understanding parallel execution performance</li> <li>Best Practices - Comprehensive best practices for concurrent execution</li> <li>Pipeline API - Complete Pipeline API reference</li> <li>Parallel Executor API - Low-level parallel execution details</li> </ul>"},{"location":"concurrent/performance/","title":"Performance Characteristics","text":"<p>Understanding the performance implications of parallel execution in SimpleFlow helps you make informed decisions about when and how to use concurrent execution.</p>"},{"location":"concurrent/performance/#overview","title":"Overview","text":"<p>SimpleFlow uses the <code>async</code> gem for true concurrent execution. When the async gem is available, parallel steps run in separate fibers, allowing I/O operations to execute concurrently. When async is not available, SimpleFlow falls back to sequential execution.</p>"},{"location":"concurrent/performance/#async-gem-integration","title":"Async Gem Integration","text":""},{"location":"concurrent/performance/#checking-availability","title":"Checking Availability","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new\npipeline.async_available?  # =&gt; true if async gem is installed\n</code></pre>"},{"location":"concurrent/performance/#installation","title":"Installation","text":"<p>Add to your Gemfile:</p> <pre><code>gem 'async', '~&gt; 2.0'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre>"},{"location":"concurrent/performance/#fallback-behavior","title":"Fallback Behavior","text":"<p>If async is not available, SimpleFlow automatically falls back to sequential execution:</p> <pre><code># With async gem\nresult = pipeline.call_parallel(data)  # Executes in parallel\n\n# Without async gem\nresult = pipeline.call_parallel(data)  # Executes sequentially (automatically)\n</code></pre> <p>The API remains identical, ensuring your code works in both scenarios.</p>"},{"location":"concurrent/performance/#when-to-use-parallel-execution","title":"When to Use Parallel Execution","text":""},{"location":"concurrent/performance/#ideal-use-cases-io-bound","title":"Ideal Use Cases (I/O-Bound)","text":"<p>Parallel execution provides significant benefits for I/O-bound operations:</p>"},{"location":"concurrent/performance/#1-multiple-api-calls","title":"1. Multiple API Calls","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_weather, -&gt;(result) {\n    # I/O-bound: Network request\n    weather = WeatherAPI.fetch(result.value[:location])\n    result.with_context(:weather, weather).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_news, -&gt;(result) {\n    # I/O-bound: Network request\n    news = NewsAPI.fetch(result.value[:topic])\n    result.with_context(:news, news).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_stocks, -&gt;(result) {\n    # I/O-bound: Network request\n    stocks = StockAPI.fetch(result.value[:symbols])\n    result.with_context(:stocks, stocks).continue(result.value)\n  }, depends_on: []\nend\n\n# Sequential: ~300ms (100ms per API call)\n# Parallel: ~100ms (all calls concurrent)\n# Speedup: 3x\n</code></pre>"},{"location":"concurrent/performance/#2-database-queries","title":"2. Database Queries","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :query_users, -&gt;(result) {\n    # I/O-bound: Database query\n    users = DB[:users].where(active: true).all\n    result.with_context(:users, users).continue(result.value)\n  }, depends_on: []\n\n  step :query_posts, -&gt;(result) {\n    # I/O-bound: Database query\n    posts = DB[:posts].where(published: true).all\n    result.with_context(:posts, posts).continue(result.value)\n  }, depends_on: []\n\n  step :query_comments, -&gt;(result) {\n    # I/O-bound: Database query\n    comments = DB[:comments].where(approved: true).all\n    result.with_context(:comments, comments).continue(result.value)\n  }, depends_on: []\nend\n\n# Sequential: ~150ms (50ms per query)\n# Parallel: ~50ms (all queries concurrent)\n# Speedup: 3x\n</code></pre>"},{"location":"concurrent/performance/#3-file-operations","title":"3. File Operations","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :read_config, -&gt;(result) {\n    # I/O-bound: File read\n    config = JSON.parse(File.read('config.json'))\n    result.with_context(:config, config).continue(result.value)\n  }, depends_on: []\n\n  step :read_users, -&gt;(result) {\n    # I/O-bound: File read\n    users = CSV.read('users.csv')\n    result.with_context(:users, users).continue(result.value)\n  }, depends_on: []\n\n  step :read_logs, -&gt;(result) {\n    # I/O-bound: File read\n    logs = File.readlines('app.log')\n    result.with_context(:logs, logs).continue(result.value)\n  }, depends_on: []\nend\n\n# Sequential: ~300ms (100ms per file)\n# Parallel: ~100ms (all reads concurrent)\n# Speedup: 3x\n</code></pre>"},{"location":"concurrent/performance/#when-not-to-use-parallel-execution","title":"When NOT to Use Parallel Execution","text":""},{"location":"concurrent/performance/#1-cpu-bound-operations","title":"1. CPU-Bound Operations","text":"<p>Due to Ruby's Global Interpreter Lock (GIL), CPU-bound operations do not benefit from parallel execution:</p> <pre><code># CPU-intensive calculations\npipeline = SimpleFlow::Pipeline.new do\n  step :calculate_fibonacci, -&gt;(result) {\n    # CPU-bound: No I/O, pure computation\n    fib = fibonacci(result.value)\n    result.with_context(:fib, fib).continue(result.value)\n  }, depends_on: []\n\n  step :calculate_primes, -&gt;(result) {\n    # CPU-bound: No I/O, pure computation\n    primes = find_primes(result.value)\n    result.with_context(:primes, primes).continue(result.value)\n  }, depends_on: []\nend\n\n# Sequential: ~200ms\n# Parallel: ~200ms (no speedup due to GIL)\n# Speedup: None\n</code></pre> <p>Recommendation: Use sequential execution for CPU-bound tasks.</p>"},{"location":"concurrent/performance/#2-steps-with-shared-state","title":"2. Steps with Shared State","text":"<p>Avoid parallel execution when steps modify shared state:</p> <pre><code># BAD: Race conditions\n@counter = 0\n\npipeline = SimpleFlow::Pipeline.new do\n  step :increment_a, -&gt;(result) {\n    @counter += 1  # Race condition!\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :increment_b, -&gt;(result) {\n    @counter += 1  # Race condition!\n    result.continue(result.value)\n  }, depends_on: []\nend\n</code></pre> <p>Recommendation: Design steps to be independent and use context for data sharing.</p>"},{"location":"concurrent/performance/#3-small-fast-operations","title":"3. Small, Fast Operations","text":"<p>Parallel execution has overhead. For very fast operations, the overhead may exceed the benefit:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :upcase_string, -&gt;(result) {\n    result.continue(result.value.upcase)  # ~0.001ms\n  }, depends_on: []\n\n  step :reverse_string, -&gt;(result) {\n    result.continue(result.value.reverse)  # ~0.001ms\n  }, depends_on: []\nend\n\n# Sequential: ~0.002ms\n# Parallel: ~0.5ms (overhead &gt; benefit)\n# Slowdown: 250x\n</code></pre> <p>Recommendation: Use parallel execution only when individual steps take at least 10-100ms.</p>"},{"location":"concurrent/performance/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"concurrent/performance/#test-setup","title":"Test Setup","text":"<pre><code>require 'benchmark'\n\n# Simulate I/O delay\ndef simulate_io(duration_ms)\n  sleep(duration_ms / 1000.0)\nend\n\n# Simple pipeline with 3 parallel steps\npipeline = SimpleFlow::Pipeline.new do\n  step :task_a, -&gt;(result) {\n    simulate_io(100)\n    result.with_context(:a, \"done\").continue(result.value)\n  }, depends_on: []\n\n  step :task_b, -&gt;(result) {\n    simulate_io(100)\n    result.with_context(:b, \"done\").continue(result.value)\n  }, depends_on: []\n\n  step :task_c, -&gt;(result) {\n    simulate_io(100)\n    result.with_context(:c, \"done\").continue(result.value)\n  }, depends_on: []\nend\n\ninitial = SimpleFlow::Result.new(nil)\n</code></pre>"},{"location":"concurrent/performance/#results","title":"Results","text":"<pre><code>Benchmark.bm do |x|\n  x.report(\"Sequential:\") { pipeline.call(initial) }\n  x.report(\"Parallel:  \") { pipeline.call_parallel(initial) }\nend\n</code></pre> <p>Output: <pre><code>                user     system      total        real\nSequential:   0.000000   0.000000   0.000000 (  0.301234)\nParallel:     0.000000   0.000000   0.000000 (  0.101456)\n</code></pre></p> <p>Speedup: 2.97x (nearly 3x for 3 parallel steps)</p>"},{"location":"concurrent/performance/#complex-pipeline","title":"Complex Pipeline","text":"<pre><code># Multi-level pipeline (like e-commerce example)\n# Level 1: 1 step (100ms)\n# Level 2: 2 parallel steps (100ms each)\n# Level 3: 1 step (100ms)\n# Level 4: 2 parallel steps (100ms each)\n\n# Sequential: 100 + 100 + 100 + 100 + 100 + 100 = 600ms\n# Parallel:   100 + 100 + 100 + 100 = 400ms\n# Speedup: 1.5x\n</code></pre>"},{"location":"concurrent/performance/#gil-limitations","title":"GIL Limitations","text":""},{"location":"concurrent/performance/#understanding-the-gil","title":"Understanding the GIL","text":"<p>Ruby's Global Interpreter Lock (GIL) allows only one thread to execute Ruby code at a time. This means:</p> <ol> <li>I/O Operations: Can run concurrently (I/O happens outside the GIL)</li> <li>CPU Operations: Cannot run concurrently (bound by GIL)</li> </ol>"},{"location":"concurrent/performance/#example-io-vs-cpu","title":"Example: I/O vs CPU","text":"<pre><code># I/O-bound: Benefits from parallelism\nstep :fetch_api, -&gt;(result) {\n  # Network I/O releases GIL\n  response = HTTP.get(\"https://api.example.com\")\n  result.with_context(:data, response).continue(result.value)\n}\n\n# CPU-bound: No benefit from parallelism\nstep :calculate, -&gt;(result) {\n  # Pure Ruby computation holds GIL\n  result = (1..1000000).reduce(:+)\n  result.continue(result)\n}\n</code></pre>"},{"location":"concurrent/performance/#ruby-implementation-differences","title":"Ruby Implementation Differences","text":"<p>Different Ruby implementations handle the GIL differently:</p> <ul> <li>MRI (CRuby): Has GIL, I/O can be concurrent</li> <li>JRuby: No GIL, true parallelism for CPU tasks</li> <li>TruffleRuby: No GIL, true parallelism for CPU tasks</li> </ul> <p>SimpleFlow works with all implementations, but performance characteristics vary.</p>"},{"location":"concurrent/performance/#overhead-analysis","title":"Overhead Analysis","text":""},{"location":"concurrent/performance/#parallel-execution-overhead","title":"Parallel Execution Overhead","text":"<p>Parallel execution adds overhead from:</p> <ol> <li>Task creation: Creating async tasks</li> <li>Synchronization: Waiting for tasks to complete</li> <li>Result merging: Combining contexts and errors</li> </ol>"},{"location":"concurrent/performance/#overhead-measurements","title":"Overhead Measurements","text":"<pre><code># Overhead for empty steps\npipeline = SimpleFlow::Pipeline.new do\n  (1..10).each do |i|\n    step \"step_#{i}\".to_sym, -&gt;(result) {\n      result.continue(result.value)\n    }, depends_on: []\n  end\nend\n\n# Sequential: ~0.5ms\n# Parallel: ~5ms\n# Overhead: ~4.5ms\n</code></pre> <p>Guideline: Parallel execution is worthwhile when: - Each step takes &gt; 10ms - Multiple steps can run concurrently - Steps are I/O-bound</p>"},{"location":"concurrent/performance/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"concurrent/performance/#1-batch-independent-operations","title":"1. Batch Independent Operations","text":"<p>Group independent I/O operations for maximum concurrency:</p> <pre><code># GOOD: Maximum parallelism\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user_data, -&gt;(result) { ... }, depends_on: []\n  step :fetch_product_data, -&gt;(result) { ... }, depends_on: []\n  step :fetch_order_data, -&gt;(result) { ... }, depends_on: []\n  step :fetch_shipping_data, -&gt;(result) { ... }, depends_on: []\n  # All 4 run in parallel\nend\n\n# BAD: Artificial dependencies\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user_data, -&gt;(result) { ... }, depends_on: []\n  step :fetch_product_data, -&gt;(result) { ... }, depends_on: [:fetch_user_data]\n  step :fetch_order_data, -&gt;(result) { ... }, depends_on: [:fetch_product_data]\n  # All run sequentially (slower)\nend\n</code></pre>"},{"location":"concurrent/performance/#2-minimize-context-size","title":"2. Minimize Context Size","text":"<p>Large contexts slow down result merging:</p> <pre><code># GOOD: Only essential data\nstep :fetch_users, -&gt;(result) {\n  users = fetch_all_users\n  user_ids = users.map { |u| u[:id] }\n  result.with_context(:user_ids, user_ids).continue(result.value)\n}\n\n# BAD: Large data structures\nstep :fetch_users, -&gt;(result) {\n  users = fetch_all_users  # Huge array\n  result.with_context(:all_users, users).continue(result.value)\n}\n</code></pre>"},{"location":"concurrent/performance/#3-use-connection-pools","title":"3. Use Connection Pools","text":"<p>For database operations, use connection pooling:</p> <pre><code># Configure connection pool\nDB = Sequel.connect(\n  'postgres://localhost/mydb',\n  max_connections: 10  # Allow concurrent queries\n)\n\npipeline = SimpleFlow::Pipeline.new do\n  step :query_a, -&gt;(result) {\n    # Uses connection from pool\n    data = DB[:table_a].all\n    result.with_context(:data_a, data).continue(result.value)\n  }, depends_on: []\n\n  step :query_b, -&gt;(result) {\n    # Uses different connection from pool\n    data = DB[:table_b].all\n    result.with_context(:data_b, data).continue(result.value)\n  }, depends_on: []\nend\n</code></pre>"},{"location":"concurrent/performance/#4-profile-before-optimizing","title":"4. Profile Before Optimizing","text":"<p>Measure actual performance before adding parallelism:</p> <pre><code>require 'benchmark'\n\n# Test sequential\nsequential_time = Benchmark.realtime do\n  pipeline.call(initial_result)\nend\n\n# Test parallel\nparallel_time = Benchmark.realtime do\n  pipeline.call_parallel(initial_result)\nend\n\nspeedup = sequential_time / parallel_time\nputs \"Speedup: #{speedup.round(2)}x\"\n</code></pre>"},{"location":"concurrent/performance/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"concurrent/performance/#execution-time-tracking","title":"Execution Time Tracking","text":"<p>Add timing to your steps:</p> <pre><code>step :timed_operation, -&gt;(result) {\n  start = Time.now\n\n  # Your operation\n  data = perform_operation(result.value)\n\n  duration = Time.now - start\n  result\n    .with_context(:operation_data, data)\n    .with_context(:operation_duration, duration)\n    .continue(result.value)\n}\n</code></pre>"},{"location":"concurrent/performance/#visualization","title":"Visualization","text":"<p>Use visualization tools to understand execution flow:</p> <pre><code># View execution plan\nputs pipeline.execution_plan\n\n# Generate visual diagram\nFile.write('pipeline.dot', pipeline.visualize_dot)\n# Run: dot -Tpng pipeline.dot -o pipeline.png\n</code></pre>"},{"location":"concurrent/performance/#performance-testing","title":"Performance Testing","text":"<p>See <code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/examples/04_parallel_automatic.rb</code> for performance comparisons showing:</p> <ul> <li>Parallel vs sequential execution times</li> <li>Context merging behavior</li> <li>Error handling overhead</li> </ul>"},{"location":"concurrent/performance/#related-documentation","title":"Related Documentation","text":"<ul> <li>Parallel Steps - How to use named steps with dependencies</li> <li>Best Practices - Recommended patterns for concurrent execution</li> <li>Benchmarking Guide - How to benchmark your pipelines</li> </ul>"},{"location":"core-concepts/flow-control/","title":"Flow Control","text":"<p>Flow control in SimpleFlow allows you to manage the execution path of your pipeline based on conditions, errors, or business logic.</p>"},{"location":"core-concepts/flow-control/#sequential-step-dependencies","title":"Sequential Step Dependencies","text":"<p>In sequential pipelines, each unnamed step automatically depends on the previous step's success.</p> <p>This means that steps execute in order, and the pipeline short-circuits (stops) as soon as any step halts:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    puts \"Step 1: Running\"\n    result.continue(result.value)\n  }\n\n  step -&gt;(result) {\n    puts \"Step 2: Halting\"\n    result.halt(\"error occurred\")\n  }\n\n  step -&gt;(result) {\n    puts \"Step 3: This never runs\"\n    result.continue(result.value)\n  }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(nil))\n# Output:\n# Step 1: Running\n# Step 2: Halting\n# (Step 3 is skipped)\n</code></pre> <p>Key points: - No need to explicitly define dependencies for sequential workflows - Each step receives the result from the previous step - Halting a step prevents all subsequent steps from executing - This is the default behavior for unnamed steps using <code>pipeline.call(result)</code></p>"},{"location":"core-concepts/flow-control/#the-continue-flag","title":"The Continue Flag","text":"<p>Every <code>Result</code> has a <code>continue?</code> method that determines whether the pipeline should proceed:</p> <pre><code>result = SimpleFlow::Result.new(data)\nresult.continue?  # =&gt; true (default)\n\nresult = result.halt\nresult.continue?  # =&gt; false\n</code></pre>"},{"location":"core-concepts/flow-control/#halting-execution","title":"Halting Execution","text":""},{"location":"core-concepts/flow-control/#basic-halt","title":"Basic Halt","text":"<p>Stop the pipeline while preserving the current value:</p> <pre><code>step -&gt;(result) do\n  if should_stop?(result.value)\n    return result.halt\n  end\n\n  result.continue(process(result.value))\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#halt-with-new-value","title":"Halt with New Value","text":"<p>Stop the pipeline with a different value (e.g., error response):</p> <pre><code>step -&gt;(result) do\n  unless valid?(result.value)\n    error_response = { error: 'Invalid data' }\n    return result.halt(error_response)\n  end\n\n  result.continue(result.value)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#continue-after-halt","title":"Continue After Halt","text":"<p>Once halted, a result stays halted even if you try to continue:</p> <pre><code>result = SimpleFlow::Result.new(data)\n  .halt\n  .continue('new value')\n\nresult.continue?  # =&gt; false (still halted)\nresult.value      # =&gt; 'new value' (value changed, but still halted)\n</code></pre>"},{"location":"core-concepts/flow-control/#conditional-execution","title":"Conditional Execution","text":""},{"location":"core-concepts/flow-control/#early-return-pattern","title":"Early Return Pattern","text":"<pre><code>step -&gt;(result) do\n  # Skip processing if conditions not met\n  return result.continue(result.value) if skip_condition?(result)\n\n  # Process normally\n  processed = expensive_operation(result.value)\n  result.continue(processed)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#guard-clauses","title":"Guard Clauses","text":"<pre><code>step -&gt;(result) do\n  data = result.value\n\n  # Multiple guard clauses\n  return result.with_error(:validation, 'ID required').halt unless data[:id]\n  return result.with_error(:validation, 'Email required').halt unless data[:email]\n  return result.with_error(:authorization, 'Unauthorized').halt unless authorized?(data)\n\n  # Main logic\n  result.continue(process(data))\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#branching-logic","title":"Branching Logic","text":"<pre><code>step -&gt;(result) do\n  user_type = result.value[:type]\n\n  case user_type\n  when 'premium'\n    result.continue(process_premium(result.value))\n  when 'standard'\n    result.continue(process_standard(result.value))\n  when 'trial'\n    result.continue(process_trial(result.value))\n  else\n    result.with_error(:validation, \"Unknown type: #{user_type}\").halt\n  end\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#error-based-flow-control","title":"Error-Based Flow Control","text":""},{"location":"core-concepts/flow-control/#accumulate-errors-continue-processing","title":"Accumulate Errors, Continue Processing","text":"<pre><code>step -&gt;(result) do\n  data = result.value\n  result_with_errors = result\n\n  # Collect all validation errors\n  if data[:name].blank?\n    result_with_errors = result_with_errors.with_error(:validation, 'Name required')\n  end\n\n  if data[:email].blank?\n    result_with_errors = result_with_errors.with_error(:validation, 'Email required')\n  end\n\n  if data[:age] &amp;&amp; data[:age] &lt; 18\n    result_with_errors = result_with_errors.with_error(:validation, 'Must be 18+')\n  end\n\n  # Continue with errors tracked\n  result_with_errors.continue(data)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#halt-on-critical-errors","title":"Halt on Critical Errors","text":"<pre><code>step -&gt;(result) do\n  data = result.value\n  result_with_errors = result\n\n  # Collect warnings (non-critical)\n  if data[:phone].blank?\n    result_with_errors = result_with_errors.with_error(:warning, 'Phone number recommended')\n  end\n\n  # Halt on critical errors\n  if data[:credit_card].blank?\n    return result_with_errors\n      .with_error(:critical, 'Payment method required')\n      .halt\n  end\n\n  result_with_errors.continue(data)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#check-accumulated-errors","title":"Check Accumulated Errors","text":"<pre><code>step -&gt;(result) do\n  # Check if previous steps added errors\n  if result.errors.key?(:validation)\n    return result.halt  # Stop if validation errors exist\n  end\n\n  result.continue(process(result.value))\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#context-based-flow-control","title":"Context-Based Flow Control","text":""},{"location":"core-concepts/flow-control/#skip-steps-based-on-context","title":"Skip Steps Based on Context","text":"<pre><code>step -&gt;(result) do\n  # Skip if already processed\n  if result.context[:processed]\n    return result.continue(result.value)\n  end\n\n  processed = process_data(result.value)\n  result\n    .continue(processed)\n    .with_context(:processed, true)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#feature-flags","title":"Feature Flags","text":"<pre><code>step -&gt;(result) do\n  # Skip if feature disabled\n  unless result.context[:feature_enabled]\n    return result.continue(result.value)\n  end\n\n  new_feature_processing(result.value)\n  result.continue(processed)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#retry-logic","title":"Retry Logic","text":""},{"location":"core-concepts/flow-control/#simple-retry","title":"Simple Retry","text":"<pre><code>step -&gt;(result) do\n  max_retries = 3\n  attempts = 0\n\n  begin\n    data = unreliable_api_call(result.value)\n    result.continue(data)\n  rescue StandardError =&gt; e\n    attempts += 1\n    retry if attempts &lt; max_retries\n\n    result\n      .with_error(:api, \"Failed after #{attempts} attempts: #{e.message}\")\n      .halt\n  end\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#exponential-backoff","title":"Exponential Backoff","text":"<pre><code>step -&gt;(result) do\n  max_retries = 5\n  base_delay = 1.0\n  attempts = 0\n\n  begin\n    data = fetch_external_data(result.value)\n    result.continue(data)\n  rescue StandardError =&gt; e\n    attempts += 1\n\n    if attempts &lt; max_retries\n      delay = base_delay * (2 ** (attempts - 1))\n      sleep(delay)\n      retry\n    end\n\n    result\n      .with_error(:external, \"Max retries exceeded: #{e.message}\")\n      .with_context(:retry_attempts, attempts)\n      .halt\n  end\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>class CircuitBreaker\n  def initialize\n    @failure_count = 0\n    @last_failure_time = nil\n    @threshold = 5\n    @timeout = 60\n  end\n\n  def call(result)\n    # Check if circuit is open\n    if circuit_open?\n      return result\n        .with_error(:circuit_breaker, 'Circuit breaker open')\n        .halt\n    end\n\n    # Try operation\n    begin\n      data = risky_operation(result.value)\n      reset_circuit\n      result.continue(data)\n    rescue StandardError =&gt; e\n      record_failure\n      result.with_error(:operation, e.message).halt\n    end\n  end\n\n  private\n\n  def circuit_open?\n    @failure_count &gt;= @threshold &amp;&amp;\n      @last_failure_time &amp;&amp;\n      (Time.now - @last_failure_time) &lt; @timeout\n  end\n\n  def record_failure\n    @failure_count += 1\n    @last_failure_time = Time.now\n  end\n\n  def reset_circuit\n    @failure_count = 0\n    @last_failure_time = nil\n  end\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#conditional-pipeline-construction","title":"Conditional Pipeline Construction","text":"<p>Build pipelines dynamically based on conditions:</p> <pre><code>def build_pipeline(user_type)\n  SimpleFlow::Pipeline.new do\n    # Always validate\n    step method(:validate_user)\n\n    # Conditional steps based on user type\n    if user_type == :premium\n      step method(:apply_premium_discount)\n      step method(:check_premium_limits)\n    end\n\n    if user_type == :enterprise\n      step method(:check_bulk_pricing)\n      step method(:assign_account_manager)\n    end\n\n    # Always process\n    step method(:process_order)\n  end\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#short-circuit-entire-pipeline","title":"Short-Circuit Entire Pipeline","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Pre-flight check - halts entire pipeline if fails\n  step -&gt;(result) do\n    unless system_healthy?\n      return result\n        .with_error(:system, 'System maintenance in progress')\n        .halt\n    end\n    result.continue(result.value)\n  end\n\n  # These only run if pre-flight passes\n  step method(:process_data)\n  step method(:validate_results)\n  step method(:save_to_database)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#best-practices","title":"Best Practices","text":"<ol> <li>Fail Fast: Use <code>halt</code> as soon as you know processing cannot succeed</li> <li>Preserve Context: Keep error messages and context for debugging</li> <li>Distinguish Error Severity: Use different error categories (<code>:validation</code>, <code>:critical</code>, <code>:warning</code>)</li> <li>Use Early Returns: Make guard clauses clear with early returns</li> <li>Document Flow Logic: Comment complex conditional logic</li> <li>Test Both Paths: Test both success and failure paths</li> <li>Avoid Deep Nesting: Use early returns instead of nested conditionals</li> </ol>"},{"location":"core-concepts/flow-control/#common-patterns","title":"Common Patterns","text":""},{"location":"core-concepts/flow-control/#validation-pipeline","title":"Validation Pipeline","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) do\n    # Collect all errors, but don't halt yet\n    result_with_errors = validate_all_fields(result)\n\n    # Halt only if errors exist\n    if result_with_errors.errors.any?\n      return result_with_errors.halt\n    end\n\n    result_with_errors.continue(result.value)\n  end\n\n  # This only runs if validation passed\n  step method(:process_valid_data)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#multi-stage-processing","title":"Multi-Stage Processing","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Stage 1: Preparation (must succeed)\n  step method(:fetch_data)\n  step method(:validate_data)\n\n  # Stage 2: Processing (optional based on flags)\n  step -&gt;(result) do\n    if result.context[:skip_processing]\n      return result.continue(result.value)\n    end\n    result.continue(process_data(result.value))\n  end\n\n  # Stage 3: Finalization (always runs if we got here)\n  step method(:save_results)\n  step method(:send_notifications)\nend\n</code></pre>"},{"location":"core-concepts/flow-control/#next-steps","title":"Next Steps","text":"<ul> <li>Result - Understanding the Result object</li> <li>Steps - Implementing step logic</li> <li>Error Handling Guide - Comprehensive error handling strategies</li> <li>Complex Workflows Guide - Real-world flow control examples</li> </ul>"},{"location":"core-concepts/middleware/","title":"Middleware","text":"<p>Middleware provides a way to add cross-cutting concerns to your pipeline without modifying individual steps.</p>"},{"location":"core-concepts/middleware/#overview","title":"Overview","text":"<p>Middleware wraps steps using the decorator pattern, allowing you to:</p> <ul> <li>Log step execution</li> <li>Measure performance</li> <li>Add authentication/authorization</li> <li>Handle retries</li> <li>Cache results</li> <li>Track metrics</li> </ul>"},{"location":"core-concepts/middleware/#built-in-middleware","title":"Built-in Middleware","text":""},{"location":"core-concepts/middleware/#logging-middleware","title":"Logging Middleware","text":"<p>Logs before and after each step execution:</p> <pre><code>require 'simple_flow'\n\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n\n  step -&gt;(result) { result.continue(process_data(result.value)) }\n  step -&gt;(result) { result.continue(validate_data(result.value)) }\nend\n</code></pre> <p>Output: <pre><code>[SimpleFlow] Before step: #&lt;Proc:0x00007f8b1c0b4f00&gt;\n[SimpleFlow] After step: #&lt;Proc:0x00007f8b1c0b4f00&gt;\n[SimpleFlow] Before step: #&lt;Proc:0x00007f8b1c0b5200&gt;\n[SimpleFlow] After step: #&lt;Proc:0x00007f8b1c0b5200&gt;\n</code></pre></p>"},{"location":"core-concepts/middleware/#instrumentation-middleware","title":"Instrumentation Middleware","text":"<p>Measures execution time and tracks API usage:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'my-app-key'\n\n  step -&gt;(result) { result.continue(fetch_data(result.value)) }\n  step -&gt;(result) { result.continue(process_data(result.value)) }\nend\n</code></pre> <p>Output: <pre><code>Instrumentation: my-app-key took 0.0423s\nInstrumentation: my-app-key took 0.0156s\n</code></pre></p>"},{"location":"core-concepts/middleware/#creating-custom-middleware","title":"Creating Custom Middleware","text":"<p>Middleware is any class that:</p> <ol> <li>Accepts a <code>callable</code> and optional <code>options</code> in its initializer</li> <li>Implements a <code>call(result)</code> method</li> <li>Calls <code>@callable.call(result)</code> to execute the wrapped step</li> </ol>"},{"location":"core-concepts/middleware/#basic-template","title":"Basic Template","text":"<pre><code>class MyMiddleware\n  def initialize(callable, **options)\n    @callable = callable\n    @options = options\n  end\n\n  def call(result)\n    # Before logic\n    puts \"Before step with options: #{@options.inspect}\"\n\n    # Execute the step\n    result = @callable.call(result)\n\n    # After logic\n    puts \"After step, value: #{result.value.inspect}\"\n\n    result\n  end\nend\n</code></pre>"},{"location":"core-concepts/middleware/#example-retry-middleware","title":"Example: Retry Middleware","text":"<pre><code>class RetryMiddleware\n  def initialize(callable, max_retries: 3, backoff: 1.0)\n    @callable = callable\n    @max_retries = max_retries\n    @backoff = backoff\n  end\n\n  def call(result)\n    attempts = 0\n\n    begin\n      @callable.call(result)\n    rescue StandardError =&gt; e\n      attempts += 1\n\n      if attempts &lt; @max_retries\n        sleep(@backoff * attempts)\n        retry\n      else\n        result.with_error(:retry_exhausted, e.message).halt\n      end\n    end\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware RetryMiddleware, max_retries: 5, backoff: 2.0\n\n  step -&gt;(result) {\n    # This will be retried up to 5 times\n    data = unreliable_api_call(result.value)\n    result.continue(data)\n  }\nend\n</code></pre>"},{"location":"core-concepts/middleware/#example-authentication-middleware","title":"Example: Authentication Middleware","text":"<pre><code>class AuthenticationMiddleware\n  def initialize(callable, required_role: nil)\n    @callable = callable\n    @required_role = required_role\n  end\n\n  def call(result)\n    user = result.context[:current_user]\n\n    unless user\n      return result\n        .with_error(:authentication, 'User not authenticated')\n        .halt\n    end\n\n    if @required_role &amp;&amp; !user.has_role?(@required_role)\n      return result\n        .with_error(:authorization, \"Requires #{@required_role} role\")\n        .halt\n    end\n\n    @callable.call(result)\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware AuthenticationMiddleware, required_role: :admin\n\n  step -&gt;(result) {\n    # This only runs if user is authenticated and has admin role\n    result.continue(sensitive_operation(result.value))\n  }\nend\n</code></pre>"},{"location":"core-concepts/middleware/#example-caching-middleware","title":"Example: Caching Middleware","text":"<pre><code>class CachingMiddleware\n  def initialize(callable, cache:, ttl: 3600)\n    @callable = callable\n    @cache = cache\n    @ttl = ttl\n  end\n\n  def call(result)\n    cache_key = generate_cache_key(result)\n\n    # Try cache first\n    if cached = @cache.get(cache_key)\n      return result\n        .continue(cached)\n        .with_context(:cache_hit, true)\n    end\n\n    # Execute step\n    result = @callable.call(result)\n\n    # Cache the result\n    @cache.set(cache_key, result.value, ttl: @ttl) if result.continue?\n\n    result.with_context(:cache_hit, false)\n  end\n\n  private\n\n  def generate_cache_key(result)\n    Digest::MD5.hexdigest(result.value.to_json)\n  end\nend\n\n# Usage\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware CachingMiddleware, cache: Redis.new, ttl: 1800\n\n  step -&gt;(result) {\n    # Expensive operation that will be cached\n    data = expensive_database_query(result.value)\n    result.continue(data)\n  }\nend\n</code></pre>"},{"location":"core-concepts/middleware/#middleware-order","title":"Middleware Order","text":"<p>Middleware is applied in reverse order (last declared = innermost wrapper):</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware MiddlewareA  # Applied third (outermost)\n  use_middleware MiddlewareB  # Applied second\n  use_middleware MiddlewareC  # Applied first (innermost)\n\n  step -&gt;(result) { result.continue('data') }\nend\n</code></pre> <p>Execution order: <pre><code>MiddlewareA before\n  MiddlewareB before\n    MiddlewareC before\n      Step executes\n    MiddlewareC after\n  MiddlewareB after\nMiddlewareA after\n</code></pre></p>"},{"location":"core-concepts/middleware/#combining-multiple-middleware","title":"Combining Multiple Middleware","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Logging (outermost)\n  use_middleware SimpleFlow::MiddleWare::Logging\n\n  # Authentication\n  use_middleware AuthenticationMiddleware, required_role: :user\n\n  # Caching\n  use_middleware CachingMiddleware, cache: Rails.cache\n\n  # Retry logic\n  use_middleware RetryMiddleware, max_retries: 3\n\n  # Instrumentation (innermost)\n  use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'app'\n\n  step -&gt;(result) { result.continue(process(result.value)) }\nend\n</code></pre>"},{"location":"core-concepts/middleware/#conditional-middleware","title":"Conditional Middleware","text":"<p>Apply middleware based on conditions:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging if ENV['DEBUG']\n  use_middleware CachingMiddleware, cache: cache if Rails.env.production?\n\n  step -&gt;(result) { result.continue(process(result.value)) }\nend\n</code></pre>"},{"location":"core-concepts/middleware/#testing-middleware","title":"Testing Middleware","text":"<pre><code>require 'minitest/autorun'\n\nclass MyMiddlewareTest &lt; Minitest::Test\n  def test_middleware_execution\n    step = -&gt;(result) { result.continue('processed') }\n    middleware = MyMiddleware.new(step, option: 'value')\n\n    input = SimpleFlow::Result.new('input')\n    output = middleware.call(input)\n\n    assert_equal 'processed', output.value\n  end\n\n  def test_middleware_adds_context\n    step = -&gt;(result) { result.continue(result.value) }\n    middleware = TimingMiddleware.new(step)\n\n    input = SimpleFlow::Result.new('data')\n    output = middleware.call(input)\n\n    assert output.context[:execution_time]\n  end\nend\n</code></pre>"},{"location":"core-concepts/middleware/#best-practices","title":"Best Practices","text":"<ol> <li>Keep middleware focused: Each middleware should handle one concern</li> <li>Preserve the result: Always call <code>@callable.call(result)</code></li> <li>Don't swallow errors: Let exceptions propagate unless you're handling retries</li> <li>Use context for metadata: Add timing, cache hits, etc. to context</li> <li>Make options explicit: Use keyword arguments for clarity</li> <li>Test in isolation: Middleware should be independently testable</li> <li>Document side effects: Clearly document any state changes</li> </ol>"},{"location":"core-concepts/middleware/#common-use-cases","title":"Common Use Cases","text":""},{"location":"core-concepts/middleware/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>class PerformanceMiddleware\n  def initialize(callable, threshold: 1.0)\n    @callable = callable\n    @threshold = threshold\n  end\n\n  def call(result)\n    start_time = Time.now\n    result = @callable.call(result)\n    duration = Time.now - start_time\n\n    if duration &gt; @threshold\n      warn \"Slow step: #{duration}s (threshold: #{@threshold}s)\"\n    end\n\n    result.with_context(:duration, duration)\n  end\nend\n</code></pre>"},{"location":"core-concepts/middleware/#error-enrichment","title":"Error Enrichment","text":"<pre><code>class ErrorEnrichmentMiddleware\n  def initialize(callable)\n    @callable = callable\n  end\n\n  def call(result)\n    @callable.call(result)\n  rescue StandardError =&gt; e\n    result\n      .with_error(:exception, e.message)\n      .with_context(:exception_class, e.class.name)\n      .with_context(:backtrace, e.backtrace.first(5))\n      .halt\n  end\nend\n</code></pre>"},{"location":"core-concepts/middleware/#request-id-tracking","title":"Request ID Tracking","text":"<pre><code>class RequestIDMiddleware\n  def initialize(callable)\n    @callable = callable\n  end\n\n  def call(result)\n    request_id = result.context[:request_id] || SecureRandom.uuid\n\n    result_with_id = result.with_context(:request_id, request_id)\n\n    Thread.current[:request_id] = request_id\n    result = @callable.call(result_with_id)\n    Thread.current[:request_id] = nil\n\n    result\n  end\nend\n</code></pre>"},{"location":"core-concepts/middleware/#next-steps","title":"Next Steps","text":"<ul> <li>Pipeline - Learn how middleware integrates with pipelines</li> <li>Flow Control - Controlling execution flow</li> <li>Error Handling Guide - Comprehensive error strategies</li> </ul>"},{"location":"core-concepts/overview/","title":"Core Concepts","text":"<p>Understanding SimpleFlow's fundamental concepts will help you build robust pipelines.</p>"},{"location":"core-concepts/overview/#architecture","title":"Architecture","text":"<p>SimpleFlow is built on four core components:</p> <pre><code>graph TD\n    A[Result] --&gt;|passed to| B[Step]\n    B --&gt;|transformed by| C[Middleware]\n    C --&gt;|orchestrated by| D[Pipeline]\n    D --&gt;|produces| A</code></pre>"},{"location":"core-concepts/overview/#1-result","title":"1. Result","text":"<p>An immutable value object that carries: - Value: The data being processed - Context: Metadata accumulated during processing - Errors: Validation or processing errors - Continue Flag: Whether to continue pipeline execution</p> <p>Learn more about Results</p>"},{"location":"core-concepts/overview/#2-step","title":"2. Step","text":"<p>A callable object (usually a lambda) that: - Receives a Result - Performs some operation - Returns a new Result</p> <p>Learn more about Steps</p>"},{"location":"core-concepts/overview/#3-pipeline","title":"3. Pipeline","text":"<p>An orchestrator that: - Holds a sequence of steps - Applies middleware to steps - Executes steps in order - Short-circuits on halt</p> <p>Learn more about Pipelines</p>"},{"location":"core-concepts/overview/#4-middleware","title":"4. Middleware","text":"<p>A decorator that: - Wraps steps with additional behavior - Adds cross-cutting concerns (logging, timing, etc.) - Applied in reverse order to all steps</p> <p>Learn more about Middleware</p>"},{"location":"core-concepts/overview/#data-flow","title":"Data Flow","text":"<p>Here's how data flows through a pipeline:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Pipeline\n    participant Middleware\n    participant Step\n    participant Result\n\n    Client-&gt;&gt;Pipeline: call(initial_result)\n    Pipeline-&gt;&gt;Middleware: wrap steps\n    loop Each Step\n        Pipeline-&gt;&gt;Step: call(result)\n        Step-&gt;&gt;Result: transform\n        Result--&gt;&gt;Step: new result\n        Step--&gt;&gt;Pipeline: new result\n        alt continue?\n            Pipeline-&gt;&gt;Pipeline: next step\n        else halted\n            Pipeline--&gt;&gt;Client: final result\n        end\n    end\n    Pipeline--&gt;&gt;Client: final result</code></pre>"},{"location":"core-concepts/overview/#key-principles","title":"Key Principles","text":""},{"location":"core-concepts/overview/#immutability","title":"Immutability","text":"<p>Results are never modified, only copied with changes:</p> <pre><code>original = SimpleFlow::Result.new(42)\nupdated = original.continue(43)\n\noriginal.value  # =&gt; 42 (unchanged)\nupdated.value   # =&gt; 43 (new object)\n</code></pre> <p>This makes pipelines thread-safe and easier to reason about.</p>"},{"location":"core-concepts/overview/#composability","title":"Composability","text":"<p>Steps are simple, reusable functions:</p> <pre><code># Define reusable steps\nvalidate_email = -&gt;(result) { ... }\nvalidate_age = -&gt;(result) { ... }\nvalidate_password = -&gt;(result) { ... }\n\n# Compose into pipelines\npipeline1 = SimpleFlow::Pipeline.new do\n  step validate_email\n  step validate_age\nend\n\npipeline2 = SimpleFlow::Pipeline.new do\n  step validate_email\n  step validate_password\nend\n</code></pre>"},{"location":"core-concepts/overview/#flow-control","title":"Flow Control","text":"<p>Steps decide whether the pipeline should continue or halt:</p> <pre><code>step -&gt;(result) {\n  if condition_met?\n    result.continue(new_value)  # Continue to next step\n  else\n    result.halt(value).with_error(:key, \"message\")  # Stop pipeline\n  end\n}\n</code></pre>"},{"location":"core-concepts/overview/#context-accumulation","title":"Context Accumulation","text":"<p>Metadata accumulates across steps:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.with_context(:step1, \"data\").continue(result.value) }\n  step -&gt;(result) { result.with_context(:step2, \"more\").continue(result.value) }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(42))\nresult.context  # =&gt; {:step1=&gt;\"data\", :step2=&gt;\"more\"}\n</code></pre>"},{"location":"core-concepts/overview/#design-patterns","title":"Design Patterns","text":"<p>SimpleFlow implements several design patterns:</p>"},{"location":"core-concepts/overview/#pipeline-pattern","title":"Pipeline Pattern","text":"<p>Sequential processing with short-circuit capability.</p>"},{"location":"core-concepts/overview/#decorator-pattern","title":"Decorator Pattern","text":"<p>Middleware wraps steps to add behavior without modifying them.</p>"},{"location":"core-concepts/overview/#immutable-value-object","title":"Immutable Value Object","text":"<p>Results are never modified, preventing side effects.</p>"},{"location":"core-concepts/overview/#builder-pattern","title":"Builder Pattern","text":"<p>DSL for intuitive pipeline configuration.</p>"},{"location":"core-concepts/overview/#chain-of-responsibility","title":"Chain of Responsibility","text":"<p>Each step can handle or pass along the result.</p>"},{"location":"core-concepts/overview/#common-patterns","title":"Common Patterns","text":""},{"location":"core-concepts/overview/#validation-pipeline","title":"Validation Pipeline","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { validate_required_fields(result) }\n  step -&gt;(result) { validate_format(result) }\n  step -&gt;(result) { validate_business_rules(result) }\n\n  step -&gt;(result) {\n    # Halt if any errors accumulated\n    result.errors.any? ? result.halt : result.continue(result.value)\n  }\nend\n</code></pre>"},{"location":"core-concepts/overview/#data-transformation-pipeline","title":"Data Transformation Pipeline","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { parse_input(result) }\n  step -&gt;(result) { transform_data(result) }\n  step -&gt;(result) { format_output(result) }\nend\n</code></pre>"},{"location":"core-concepts/overview/#enrichment-pipeline","title":"Enrichment Pipeline","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { fetch_base_data(result) }\n\n  parallel do\n    step -&gt;(result) { enrich_with_user_data(result) }\n    step -&gt;(result) { enrich_with_order_data(result) }\n    step -&gt;(result) { enrich_with_analytics(result) }\n  end\n\n  step -&gt;(result) { aggregate_enrichments(result) }\nend\n</code></pre>"},{"location":"core-concepts/overview/#next-steps","title":"Next Steps","text":"<p>Explore each component in detail:</p> <ul> <li>Result API - Immutable value objects</li> <li>Pipeline API - Orchestrating steps</li> <li>Steps Guide - Writing effective steps</li> <li>Middleware Guide - Cross-cutting concerns</li> <li>Flow Control - Halting and continuing</li> </ul>"},{"location":"core-concepts/pipeline/","title":"Pipeline","text":"<p>The <code>Pipeline</code> class is the orchestrator that manages the execution of steps in your data processing workflow.</p>"},{"location":"core-concepts/pipeline/#overview","title":"Overview","text":"<p>A Pipeline defines a sequence of operations (steps) that transform data, with support for:</p> <ul> <li>Sequential execution with automatic dependencies</li> <li>Parallel execution (automatic and explicit)</li> <li>Middleware integration</li> <li>Short-circuit evaluation</li> <li>Explicit dependency management</li> </ul>"},{"location":"core-concepts/pipeline/#execution-modes","title":"Execution Modes","text":"<p>SimpleFlow pipelines support two distinct execution modes:</p>"},{"location":"core-concepts/pipeline/#sequential-execution-default","title":"Sequential Execution (Default)","text":"<p>Unnamed steps execute in order, with each step automatically depending on the previous step's success.</p> <p>When a step halts (returns <code>result.halt</code>), the pipeline immediately stops and subsequent steps are not executed.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { puts \"Step 1\"; result.continue(result.value) }\n  step -&gt;(result) { puts \"Step 2\"; result.halt(\"stopped\") }\n  step -&gt;(result) { puts \"Step 3\"; result.continue(result.value) }  # NEVER EXECUTES\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(nil))\n# Output:\n# Step 1\n# Step 2\n# (Step 3 is skipped because Step 2 halted)\n</code></pre> <p>This automatic dependency chain means: - Steps execute one at a time in the order they were defined - Each step receives the result from the previous step - If any step halts, the entire pipeline stops immediately - No need to specify dependencies for sequential workflows</p>"},{"location":"core-concepts/pipeline/#parallel-execution","title":"Parallel Execution","text":"<p>Named steps with explicit dependencies can run concurrently using <code>call_parallel</code>.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :validate, validator, depends_on: []\n  step :fetch_a, fetcher_a, depends_on: [:validate]  # Runs in parallel with fetch_b\n  step :fetch_b, fetcher_b, depends_on: [:validate]  # Runs in parallel with fetch_a\n  step :merge, merger, depends_on: [:fetch_a, :fetch_b]\nend\n\nresult = pipeline.call_parallel(initial_data)\n</code></pre> <p>See Parallel Execution below for details.</p>"},{"location":"core-concepts/pipeline/#basic-usage","title":"Basic Usage","text":"<pre><code>require 'simple_flow'\n\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value * 2) }\n  step -&gt;(result) { result.continue(result.value + 10) }\n  step -&gt;(result) { result.continue(result.value.to_s) }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(5))\nresult.value # =&gt; \"20\"\n</code></pre>"},{"location":"core-concepts/pipeline/#defining-steps","title":"Defining Steps","text":""},{"location":"core-concepts/pipeline/#lambda-steps","title":"Lambda Steps","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) do\n    # Process the result\n    new_value = transform(result.value)\n    result.continue(new_value)\n  end\nend\n</code></pre>"},{"location":"core-concepts/pipeline/#method-steps","title":"Method Steps","text":"<pre><code>def validate_user(result)\n  if result.value[:email].present?\n    result.continue(result.value)\n  else\n    result.with_error(:validation, 'Email required').halt\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step method(:validate_user)\nend\n</code></pre>"},{"location":"core-concepts/pipeline/#callable-objects","title":"Callable Objects","text":"<pre><code>class EmailValidator\n  def call(result)\n    # Validation logic\n    result.continue(result.value)\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step EmailValidator.new\nend\n</code></pre>"},{"location":"core-concepts/pipeline/#named-steps-with-dependencies","title":"Named Steps with Dependencies","text":"<p>For parallel execution, you can define named steps with explicit dependencies:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :validate, -&gt;(result) { validate(result) }, depends_on: []\n  step :fetch_user, -&gt;(result) { fetch_user(result) }, depends_on: [:validate]\n  step :fetch_orders, -&gt;(result) { fetch_orders(result) }, depends_on: [:validate]\n  step :calculate, -&gt;(result) { calculate(result) }, depends_on: [:fetch_user, :fetch_orders]\nend\n</code></pre> <p>Steps with the same satisfied dependencies run in parallel automatically.</p>"},{"location":"core-concepts/pipeline/#parallel-execution_1","title":"Parallel Execution","text":""},{"location":"core-concepts/pipeline/#automatic-parallelization","title":"Automatic Parallelization","text":"<pre><code># These will run in parallel (both depend only on :validate)\npipeline = SimpleFlow::Pipeline.new do\n  step :validate, validator, depends_on: []\n  step :fetch_orders, fetch_orders_callable, depends_on: [:validate]\n  step :fetch_products, fetch_products_callable, depends_on: [:validate]\nend\n\nresult = pipeline.call_parallel(initial_result)\n</code></pre>"},{"location":"core-concepts/pipeline/#explicit-parallel-blocks","title":"Explicit Parallel Blocks","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Sequential step\n  step -&gt;(result) { validate(result) }\n\n  # These run in parallel\n  parallel do\n    step -&gt;(result) { fetch_from_api(result) }\n    step -&gt;(result) { fetch_from_cache(result) }\n    step -&gt;(result) { fetch_from_database(result) }\n  end\n\n  # Sequential step\n  step -&gt;(result) { merge_results(result) }\nend\n</code></pre>"},{"location":"core-concepts/pipeline/#short-circuit-evaluation","title":"Short-Circuit Evaluation","text":"<p>Pipelines automatically stop executing when a step halts. This is a core feature of sequential execution - each unnamed step implicitly depends on the previous step's success.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(\"step 1\") }\n  step -&gt;(result) { result.halt(\"stopped\") }        # Execution stops here\n  step -&gt;(result) { result.continue(\"step 3\") }     # Never executed\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(nil))\nresult.value      # =&gt; \"stopped\"\nresult.continue?  # =&gt; false\n</code></pre> <p>Implementation detail: The <code>call</code> method checks <code>result.continue?</code> after each step. If it returns <code>false</code>, the pipeline returns immediately without executing remaining steps:</p> <pre><code># Simplified view of Pipeline#call\ndef call(result)\n  steps.reduce(result) do |res, step|\n    return res unless res.continue?  # Short-circuit on halt\n    step.call(res)\n  end\nend\n</code></pre> <p>This behavior ensures: - Fail-fast: Errors stop processing immediately - Resource efficiency: No wasted computation on already-failed results - Predictable flow: Clear execution path based on step outcomes</p>"},{"location":"core-concepts/pipeline/#middleware","title":"Middleware","text":"<p>Apply cross-cutting concerns using middleware:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n  use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'my-key'\n\n  step -&gt;(result) { process(result) }\nend\n</code></pre> <p>Learn more about Middleware</p>"},{"location":"core-concepts/pipeline/#visualization","title":"Visualization","text":"<p>Pipelines with named steps can be visualized:</p> <pre><code># Generate ASCII visualization\nputs pipeline.visualize_ascii\n\n# Export to Graphviz DOT format\nFile.write('pipeline.dot', pipeline.visualize_dot)\n\n# Export to Mermaid diagram\nFile.write('pipeline.mmd', pipeline.visualize_mermaid)\n\n# Get execution plan analysis\nputs pipeline.execution_plan\n</code></pre>"},{"location":"core-concepts/pipeline/#api-reference","title":"API Reference","text":""},{"location":"core-concepts/pipeline/#class-methods","title":"Class Methods","text":"Method Description <code>new(&amp;block)</code> Create a new pipeline with DSL block"},{"location":"core-concepts/pipeline/#instance-methods","title":"Instance Methods","text":"Method Description <code>call(result)</code> Execute pipeline sequentially <code>call_parallel(result, strategy: :auto)</code> Execute with parallelization <code>dependency_graph</code> Get underlying dependency graph <code>visualize</code> Get visualizer instance <code>visualize_ascii(show_groups: true)</code> ASCII visualization <code>visualize_dot(include_groups: true, orientation: 'TB')</code> Graphviz DOT export <code>visualize_mermaid</code> Mermaid diagram export <code>execution_plan</code> Performance analysis"},{"location":"core-concepts/pipeline/#dsl-methods-in-pipelinenew-block","title":"DSL Methods (in Pipeline.new block)","text":"Method Description <code>step(callable)</code> Add anonymous step <code>step(name, callable, depends_on: [])</code> Add named step with dependencies <code>parallel(&amp;block)</code> Define explicit parallel block <code>use_middleware(middleware, **options)</code> Add middleware"},{"location":"core-concepts/pipeline/#best-practices","title":"Best Practices","text":"<ol> <li>Keep steps focused: Each step should do one thing well</li> <li>Use meaningful names: Named steps improve visualization and debugging</li> <li>Handle errors gracefully: Use <code>.halt</code> to stop processing on errors</li> <li>Leverage context: Pass metadata between steps via <code>result.context</code></li> <li>Consider parallelization: Use named steps with dependencies for I/O-bound operations</li> <li>Apply middleware judiciously: Add logging/instrumentation for observability</li> </ol>"},{"location":"core-concepts/pipeline/#example-e-commerce-order-processing","title":"Example: E-Commerce Order Processing","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n  use_middleware SimpleFlow::MiddleWare::Instrumentation\n\n  step :validate, -&gt;(result) {\n    # Validate order\n    result.continue(result.value)\n  }, depends_on: :none\n\n  step :check_inventory, -&gt;(result) {\n    # Check stock\n    result.continue(result.value)\n  }, depends_on: [:validate]\n\n  step :calculate_shipping, -&gt;(result) {\n    # Calculate shipping cost\n    result.continue(result.value)\n  }, depends_on: [:validate]\n\n  step :process_payment, -&gt;(result) {\n    # Process payment\n    result.continue(result.value)\n  }, depends_on: [:check_inventory, :calculate_shipping]\n\n  step :send_confirmation, -&gt;(result) {\n    # Send email\n    result.continue(result.value)\n  }, depends_on: [:process_payment]\nend\n</code></pre>"},{"location":"core-concepts/pipeline/#next-steps","title":"Next Steps","text":"<ul> <li>Steps - Deep dive into step implementations</li> <li>Middleware - Adding cross-cutting concerns</li> <li>Parallel Execution - Concurrent processing patterns</li> <li>Complex Workflows Guide - Real-world examples</li> </ul>"},{"location":"core-concepts/result/","title":"Result","text":"<p>The <code>Result</code> class is the fundamental value object in SimpleFlow that encapsulates the outcome of each operation in your pipeline.</p>"},{"location":"core-concepts/result/#overview","title":"Overview","text":"<p>A <code>Result</code> object contains three main components:</p> <ul> <li>Value: The actual data being processed</li> <li>Context: A hash of metadata and contextual information</li> <li>Errors: Categorized error messages accumulated during processing</li> </ul>"},{"location":"core-concepts/result/#immutability","title":"Immutability","text":"<p>Results are immutable - every operation returns a new <code>Result</code> instance rather than modifying the existing one. This design promotes safer concurrent operations and functional programming patterns.</p> <pre><code>original = SimpleFlow::Result.new(\"data\")\nupdated = original.with_context(:user_id, 123)\n\noriginal.context  # =&gt; {}\nupdated.context   # =&gt; { user_id: 123 }\n</code></pre>"},{"location":"core-concepts/result/#creating-results","title":"Creating Results","text":""},{"location":"core-concepts/result/#basic-initialization","title":"Basic Initialization","text":"<pre><code># Simple result with just a value\nresult = SimpleFlow::Result.new(10)\n\n# Result with initial context and errors\nresult = SimpleFlow::Result.new(\n  { count: 5 },\n  context: { user_id: 123 },\n  errors: { validation: ['Required field missing'] }\n)\n</code></pre>"},{"location":"core-concepts/result/#working-with-context","title":"Working with Context","text":"<p>Context allows you to pass metadata through your pipeline without modifying the primary value.</p> <pre><code>result = SimpleFlow::Result.new(data)\n  .with_context(:user_id, 123)\n  .with_context(:timestamp, Time.now.to_i)\n  .with_context(:source, 'api')\n\nresult.context\n# =&gt; { user_id: 123, timestamp: 1234567890, source: 'api' }\n</code></pre>"},{"location":"core-concepts/result/#common-context-use-cases","title":"Common Context Use Cases","text":"<ul> <li>User authentication details</li> <li>Request timestamps</li> <li>Transaction IDs</li> <li>Debug information</li> <li>Performance metrics</li> </ul>"},{"location":"core-concepts/result/#error-handling","title":"Error Handling","text":"<p>Errors are organized by category, allowing multiple errors per category:</p> <pre><code>result = SimpleFlow::Result.new(data)\n  .with_error(:validation, 'Email is required')\n  .with_error(:validation, 'Password too short')\n  .with_error(:authentication, 'Invalid token')\n\nresult.errors\n# =&gt; {\n#   validation: ['Email is required', 'Password too short'],\n#   authentication: ['Invalid token']\n# }\n</code></pre>"},{"location":"core-concepts/result/#flow-control","title":"Flow Control","text":"<p>Results include a continue flag that controls pipeline execution.</p>"},{"location":"core-concepts/result/#continue","title":"Continue","text":"<p>Move to the next step with a new value:</p> <pre><code>result = result.continue(new_value)\n# continue? =&gt; true\n</code></pre>"},{"location":"core-concepts/result/#halt","title":"Halt","text":"<p>Stop pipeline execution:</p> <pre><code># Halt without changing value\nresult = result.halt\n# continue? =&gt; false, value unchanged\n\n# Halt with a new value\nresult = result.halt(error_response)\n# continue? =&gt; false, value changed\n</code></pre>"},{"location":"core-concepts/result/#checking-status","title":"Checking Status","text":"<pre><code>if result.continue?\n  # Pipeline will proceed\nelse\n  # Pipeline has been halted\nend\n</code></pre>"},{"location":"core-concepts/result/#example-multi-step-processing","title":"Example: Multi-Step Processing","text":"<pre><code>def process_user_registration(params)\n  result = SimpleFlow::Result.new(params)\n    .with_context(:ip_address, request.ip)\n    .with_context(:timestamp, Time.now)\n\n  # Validation\n  if params[:email].nil?\n    return result\n      .with_error(:validation, 'Email required')\n      .halt\n  end\n\n  # Process\n  user = create_user(params)\n\n  result\n    .continue(user)\n    .with_context(:user_id, user.id)\nend\n</code></pre>"},{"location":"core-concepts/result/#api-reference","title":"API Reference","text":""},{"location":"core-concepts/result/#instance-methods","title":"Instance Methods","text":"Method Description Returns <code>value</code> Get the current value Object <code>context</code> Get the context hash Hash <code>errors</code> Get the errors hash Hash <code>continue?</code> Check if pipeline should continue Boolean <code>with_context(key, value)</code> Add context New Result <code>with_error(key, message)</code> Add error New Result <code>continue(new_value)</code> Proceed with new value New Result <code>halt(new_value = nil)</code> Stop execution New Result"},{"location":"core-concepts/result/#best-practices","title":"Best Practices","text":"<ol> <li>Use context for metadata: Keep the value focused on the data being processed</li> <li>Categorize errors: Use meaningful error keys like <code>:validation</code>, <code>:authentication</code>, <code>:database</code></li> <li>Halt early: Stop processing as soon as you know the operation cannot succeed</li> <li>Chain operations: Take advantage of immutability to build readable operation chains</li> <li>Preserve information: When halting, preserve context and errors for debugging</li> </ol>"},{"location":"core-concepts/result/#next-steps","title":"Next Steps","text":"<ul> <li>Pipeline - Learn how Results flow through pipelines</li> <li>Flow Control - Advanced flow control patterns</li> <li>Error Handling Guide - Comprehensive error handling strategies</li> </ul>"},{"location":"core-concepts/steps/","title":"Steps","text":"<p>Steps are the individual operations that make up your pipeline. Each step receives a Result and returns a Result.</p>"},{"location":"core-concepts/steps/#step-types","title":"Step Types","text":"<p>SimpleFlow supports any callable object as a step:</p>"},{"location":"core-concepts/steps/#1-lambdaproc","title":"1. Lambda/Proc","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) do\n    new_value = result.value.upcase\n    result.continue(new_value)\n  end\nend\n</code></pre>"},{"location":"core-concepts/steps/#2-method-references","title":"2. Method References","text":"<pre><code>def validate_email(result)\n  if result.value[:email] =~ /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n    result.continue(result.value)\n  else\n    result.with_error(:validation, 'Invalid email').halt\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step method(:validate_email)\nend\n</code></pre>"},{"location":"core-concepts/steps/#3-callable-objects","title":"3. Callable Objects","text":"<pre><code>class UserValidator\n  def call(result)\n    user = result.value\n\n    errors = []\n    errors &lt;&lt; 'Name required' if user[:name].blank?\n    errors &lt;&lt; 'Email required' if user[:email].blank?\n\n    if errors.any?\n      errors.each { |error| result = result.with_error(:validation, error) }\n      return result.halt\n    end\n\n    result.continue(user)\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step UserValidator.new\nend\n</code></pre>"},{"location":"core-concepts/steps/#4-class-methods","title":"4. Class Methods","text":"<pre><code>class DataTransformer\n  def self.call(result)\n    transformed = transform_data(result.value)\n    result.continue(transformed)\n  end\n\n  def self.transform_data(data)\n    # Transformation logic\n    data.transform_values(&amp;:to_s)\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step DataTransformer\nend\n</code></pre>"},{"location":"core-concepts/steps/#anonymous-vs-named-steps","title":"Anonymous vs Named Steps","text":""},{"location":"core-concepts/steps/#anonymous-steps-sequential-execution","title":"Anonymous Steps (Sequential Execution)","text":"<p>Anonymous steps execute sequentially with automatic dependencies on the previous step's success.</p> <p>Each step implicitly depends on the previous step completing successfully (not halting). If any step halts, subsequent steps are skipped.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    puts \"Step 1\"\n    result.continue(result.value * 2)\n  }\n\n  step -&gt;(result) {\n    puts \"Step 2\"\n    result.continue(result.value + 10)\n  }\n\n  step -&gt;(result) {\n    puts \"Step 3\"\n    result.continue(result.value.to_s)\n  }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(5))\n# Output:\n# Step 1\n# Step 2\n# Step 3\n# result.value =&gt; \"20\"\n</code></pre> <p>Key characteristics: - Execute in the order they were defined - Each step receives the result from the previous step - Pipeline short-circuits if any step halts (returns <code>result.halt</code>) - No need to specify dependencies explicitly - Use <code>pipeline.call(result)</code> to execute</p> <p>Example with halting:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { puts \"Step 1\"; result.continue(1) }\n  step -&gt;(result) { puts \"Step 2\"; result.halt(2) }     # Halts here\n  step -&gt;(result) { puts \"Step 3\"; result.continue(3) } # Never executes\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(0))\n# Output:\n# Step 1\n# Step 2\n# (Step 3 is skipped)\n</code></pre>"},{"location":"core-concepts/steps/#named-steps-parallel-execution","title":"Named Steps (Parallel Execution)","text":"<p>Named steps with explicit dependencies enable parallel execution based on a dependency graph.</p> <p>Steps with the same satisfied dependencies run concurrently. No implicit ordering - you must specify all dependencies explicitly.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user, -&gt;(result) { fetch_user(result) }, depends_on: []\n\n  # These two run in parallel (both depend only on :fetch_user)\n  step :fetch_orders, -&gt;(result) { fetch_orders(result) }, depends_on: [:fetch_user]\n  step :fetch_products, -&gt;(result) { fetch_products(result) }, depends_on: [:fetch_user]\n\n  # Waits for both parallel steps\n  step :merge, -&gt;(result) { merge_data(result) }, depends_on: [:fetch_orders, :fetch_products]\nend\n\nresult = pipeline.call_parallel(SimpleFlow::Result.new(user_id))\n</code></pre> <p>Key characteristics: - Execute based on dependency graph, not definition order - Steps with satisfied dependencies run in parallel - Must explicitly specify all dependencies with <code>depends_on:</code> - Use <code>pipeline.call_parallel(result)</code> to execute - Optimal for I/O-bound operations (API calls, database queries)</p>"},{"location":"core-concepts/steps/#step-contract","title":"Step Contract","text":"<p>Every step must:</p> <ol> <li>Accept a <code>Result</code> object as input</li> <li>Return a <code>Result</code> object as output</li> <li>Use <code>.continue(value)</code> to proceed</li> <li>Use <code>.halt(value)</code> to stop the pipeline</li> </ol> <pre><code># \u2705 Good - follows contract\ndef my_step(result)\n  processed = process(result.value)\n  result.continue(processed)\nend\n\n# \u274c Bad - returns wrong type\ndef bad_step(result)\n  result.value * 2  # Returns a number, not a Result\nend\n\n# \u274c Bad - doesn't accept Result\ndef bad_step(value)\n  value * 2\nend\n</code></pre>"},{"location":"core-concepts/steps/#working-with-values","title":"Working with Values","text":""},{"location":"core-concepts/steps/#transforming-values","title":"Transforming Values","text":"<pre><code>step -&gt;(result) do\n  # Get current value\n  data = result.value\n\n  # Transform it\n  transformed = data.map { |item| item.upcase }\n\n  # Continue with new value\n  result.continue(transformed)\nend\n</code></pre>"},{"location":"core-concepts/steps/#modifying-nested-data","title":"Modifying Nested Data","text":"<pre><code>step -&gt;(result) do\n  user = result.value\n  user[:processed_at] = Time.now\n  result.continue(user)\nend\n</code></pre>"},{"location":"core-concepts/steps/#adding-context","title":"Adding Context","text":"<p>Context persists across steps without modifying the value:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    result\n      .continue(result.value)\n      .with_context(:started_at, Time.now)\n  }\n\n  step -&gt;(result) {\n    result\n      .continue(process(result.value))\n      .with_context(:processed_at, Time.now)\n  }\n\n  step -&gt;(result) {\n    duration = result.context[:processed_at] - result.context[:started_at]\n    result\n      .continue(result.value)\n      .with_context(:duration, duration)\n  }\nend\n</code></pre>"},{"location":"core-concepts/steps/#error-handling-in-steps","title":"Error Handling in Steps","text":""},{"location":"core-concepts/steps/#collecting-errors","title":"Collecting Errors","text":"<pre><code>step -&gt;(result) do\n  user = result.value\n  result_with_errors = result\n\n  if user[:email].nil?\n    result_with_errors = result_with_errors.with_error(:validation, 'Email required')\n  end\n\n  if user[:age] &amp;&amp; user[:age] &lt; 18\n    result_with_errors = result_with_errors.with_error(:validation, 'Must be 18+')\n  end\n\n  # Continue even with errors (they're tracked)\n  result_with_errors.continue(user)\nend\n</code></pre>"},{"location":"core-concepts/steps/#halting-on-errors","title":"Halting on Errors","text":"<pre><code>step -&gt;(result) do\n  if critical_error?(result.value)\n    return result\n      .with_error(:critical, 'Cannot proceed')\n      .halt\n  end\n\n  result.continue(result.value)\nend\n</code></pre>"},{"location":"core-concepts/steps/#conditional-logic","title":"Conditional Logic","text":""},{"location":"core-concepts/steps/#early-return","title":"Early Return","text":"<pre><code>step -&gt;(result) do\n  return result.halt if should_skip?(result.value)\n\n  result.continue(process(result.value))\nend\n</code></pre>"},{"location":"core-concepts/steps/#branching","title":"Branching","text":"<pre><code>step -&gt;(result) do\n  if result.value[:type] == 'premium'\n    result.continue(process_premium(result.value))\n  else\n    result.continue(process_standard(result.value))\n  end\nend\n</code></pre>"},{"location":"core-concepts/steps/#asyncexternal-operations","title":"Async/External Operations","text":"<p>Steps can perform I/O operations:</p> <pre><code>step -&gt;(result) do\n  # API call\n  response = HTTParty.get(\"https://api.example.com/users/#{result.value[:id]}\")\n\n  result\n    .continue(response.parsed_response)\n    .with_context(:api_response_time, response.headers['x-response-time'])\nend\n</code></pre>"},{"location":"core-concepts/steps/#testing-steps","title":"Testing Steps","text":"<p>Steps are easy to test in isolation:</p> <pre><code>require 'minitest/autorun'\n\nclass StepTest &lt; Minitest::Test\n  def test_validation_step\n    result = SimpleFlow::Result.new({ email: 'test@example.com' })\n    output = validate_email(result)\n\n    assert output.continue?\n    assert_empty output.errors\n  end\n\n  def test_validation_step_with_invalid_email\n    result = SimpleFlow::Result.new({ email: 'invalid' })\n    output = validate_email(result)\n\n    refute output.continue?\n    assert_includes output.errors[:validation], 'Invalid email'\n  end\nend\n</code></pre>"},{"location":"core-concepts/steps/#best-practices","title":"Best Practices","text":"<ol> <li>Single Responsibility: Each step should do one thing</li> <li>Pure Functions: Avoid side effects when possible</li> <li>Explicit Dependencies: Use named steps with <code>depends_on</code> for clarity</li> <li>Error Context: Include helpful error messages with context</li> <li>Testability: Design steps to be easily testable in isolation</li> <li>Immutability: Never modify the input result - always return a new one</li> <li>Meaningful Names: For named steps, use descriptive names</li> </ol>"},{"location":"core-concepts/steps/#performance-considerations","title":"Performance Considerations","text":""},{"location":"core-concepts/steps/#io-bound-steps","title":"I/O-Bound Steps","text":"<p>Use parallel execution for independent I/O operations:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :validate, validator, depends_on: []\n\n  # These run in parallel\n  step :fetch_user_data, fetch_user, depends_on: [:validate]\n  step :fetch_order_data, fetch_orders, depends_on: [:validate]\n  step :fetch_product_data, fetch_products, depends_on: [:validate]\nend\n</code></pre>"},{"location":"core-concepts/steps/#cpu-bound-steps","title":"CPU-Bound Steps","text":"<p>Keep CPU-intensive operations sequential (Ruby GIL limitation):</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { heavy_computation_1(result) }\n  step -&gt;(result) { heavy_computation_2(result) }\nend\n</code></pre>"},{"location":"core-concepts/steps/#next-steps","title":"Next Steps","text":"<ul> <li>Pipeline - Learn how steps are orchestrated</li> <li>Flow Control - Advanced flow control patterns</li> <li>Parallel Execution - Concurrent step execution</li> <li>Error Handling Guide - Comprehensive error handling</li> </ul>"},{"location":"development/benchmarking/","title":"Benchmarking Guide","text":"<p>This guide explains how to benchmark SimpleFlow pipelines and measure performance improvements.</p>"},{"location":"development/benchmarking/#running-benchmarks","title":"Running Benchmarks","text":""},{"location":"development/benchmarking/#basic-benchmark","title":"Basic Benchmark","text":"<pre><code>require 'benchmark'\nrequire_relative '../lib/simple_flow'\n\n# Create pipeline\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    sleep 0.1  # Simulate I/O\n    result.continue(result.value + 1)\n  }\n\n  step -&gt;(result) {\n    sleep 0.1  # Simulate I/O\n    result.continue(result.value * 2)\n  }\nend\n\n# Benchmark execution\ninitial = SimpleFlow::Result.new(5)\n\ntime = Benchmark.realtime do\n  pipeline.call(initial)\nend\n\nputs \"Execution time: #{(time * 1000).round(2)}ms\"\n</code></pre>"},{"location":"development/benchmarking/#parallel-vs-sequential-comparison","title":"Parallel vs Sequential Comparison","text":"<pre><code>require 'benchmark'\nrequire_relative '../lib/simple_flow'\n\n# Sequential pipeline\nsequential = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { sleep 0.1; result.continue(result.value) }\n  step -&gt;(result) { sleep 0.1; result.continue(result.value) }\n  step -&gt;(result) { sleep 0.1; result.continue(result.value) }\n  step -&gt;(result) { sleep 0.1; result.continue(result.value) }\nend\n\n# Parallel pipeline\nparallel = SimpleFlow::Pipeline.new do\n  step :step_a, -&gt;(result) {\n    sleep 0.1\n    result.with_context(:a, true).continue(result.value)\n  }, depends_on: []\n\n  step :step_b, -&gt;(result) {\n    sleep 0.1\n    result.with_context(:b, true).continue(result.value)\n  }, depends_on: []\n\n  step :step_c, -&gt;(result) {\n    sleep 0.1\n    result.with_context(:c, true).continue(result.value)\n  }, depends_on: []\n\n  step :step_d, -&gt;(result) {\n    sleep 0.1\n    result.with_context(:d, true).continue(result.value)\n  }, depends_on: []\nend\n\ninitial = SimpleFlow::Result.new(nil)\n\nputs \"Running benchmarks...\"\nputs \"=\" * 60\n\nsequential_time = Benchmark.realtime do\n  sequential.call(initial)\nend\n\nparallel_time = Benchmark.realtime do\n  parallel.call_parallel(initial)\nend\n\nputs \"Sequential: #{(sequential_time * 1000).round(2)}ms\"\nputs \"Parallel:   #{(parallel_time * 1000).round(2)}ms\"\nputs \"Speedup:    #{(sequential_time / parallel_time).round(2)}x\"\n</code></pre> <p>Expected output: <pre><code>Running benchmarks...\n============================================================\nSequential: 401.23ms\nParallel:   102.45ms\nSpeedup:    3.92x\n</code></pre></p>"},{"location":"development/benchmarking/#benchmarking-patterns","title":"Benchmarking Patterns","text":""},{"location":"development/benchmarking/#memory-usage","title":"Memory Usage","text":"<pre><code>require 'benchmark'\nrequire 'objspace'\n\ndef measure_memory\n  GC.start\n  before = ObjectSpace.memsize_of_all\n  yield\n  GC.start\n  after = ObjectSpace.memsize_of_all\n  (after - before) / 1024.0 / 1024.0  # MB\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    large_data = Array.new(10000) { |i| { id: i, data: \"x\" * 100 } }\n    result.with_context(:data, large_data).continue(result.value)\n  }\nend\n\nmemory_used = measure_memory do\n  pipeline.call(SimpleFlow::Result.new(nil))\nend\n\nputs \"Memory used: #{memory_used.round(2)} MB\"\n</code></pre>"},{"location":"development/benchmarking/#throughput-testing","title":"Throughput Testing","text":"<pre><code>require 'benchmark'\n\ndef measure_throughput(pipeline, iterations: 1000)\n  start = Time.now\n\n  iterations.times do |i|\n    pipeline.call(SimpleFlow::Result.new(i))\n  end\n\n  duration = Time.now - start\n  throughput = iterations / duration\n\n  {\n    duration: duration,\n    throughput: throughput,\n    avg_time: duration / iterations\n  }\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value * 2) }\n  step -&gt;(result) { result.continue(result.value + 10) }\nend\n\nstats = measure_throughput(pipeline, iterations: 10000)\n\nputs \"Total time: #{stats[:duration].round(2)}s\"\nputs \"Throughput: #{stats[:throughput].round(2)} ops/sec\"\nputs \"Average time per operation: #{(stats[:avg_time] * 1000).round(4)}ms\"\n</code></pre>"},{"location":"development/benchmarking/#middleware-overhead","title":"Middleware Overhead","text":"<pre><code>require 'benchmark'\n\n# Pipeline without middleware\nplain_pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value + 1) }\n  step -&gt;(result) { result.continue(result.value * 2) }\nend\n\n# Pipeline with middleware\nmiddleware_pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n  use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'test'\n\n  step -&gt;(result) { result.continue(result.value + 1) }\n  step -&gt;(result) { result.continue(result.value * 2) }\nend\n\niterations = 1000\ninitial = SimpleFlow::Result.new(5)\n\nplain_time = Benchmark.realtime do\n  iterations.times { plain_pipeline.call(initial) }\nend\n\nmiddleware_time = Benchmark.realtime do\n  iterations.times { middleware_pipeline.call(initial) }\nend\n\noverhead = ((middleware_time - plain_time) / plain_time * 100)\n\nputs \"Plain pipeline: #{(plain_time * 1000).round(2)}ms for #{iterations} iterations\"\nputs \"With middleware: #{(middleware_time * 1000).round(2)}ms for #{iterations} iterations\"\nputs \"Middleware overhead: #{overhead.round(2)}%\"\n</code></pre>"},{"location":"development/benchmarking/#benchmark-suite","title":"Benchmark Suite","text":"<p>Create a comprehensive benchmark suite:</p> <pre><code>#!/usr/bin/env ruby\n# benchmark/suite.rb\n\nrequire 'benchmark'\nrequire_relative '../lib/simple_flow'\n\nclass BenchmarkSuite\n  def initialize\n    @results = {}\n  end\n\n  def run_all\n    puts \"SimpleFlow Benchmark Suite\"\n    puts \"=\" * 60\n    puts\n\n    benchmark_sequential_pipeline\n    benchmark_parallel_pipeline\n    benchmark_middleware_overhead\n    benchmark_context_merging\n    benchmark_error_handling\n\n    print_summary\n  end\n\n  private\n\n  def benchmark_sequential_pipeline\n    pipeline = SimpleFlow::Pipeline.new do\n      10.times do\n        step -&gt;(result) { result.continue(result.value + 1) }\n      end\n    end\n\n    time = Benchmark.realtime do\n      100.times { pipeline.call(SimpleFlow::Result.new(0)) }\n    end\n\n    @results[:sequential] = time\n    puts \"Sequential (10 steps, 100 iterations): #{(time * 1000).round(2)}ms\"\n  end\n\n  def benchmark_parallel_pipeline\n    return unless SimpleFlow::Pipeline.new.async_available?\n\n    pipeline = SimpleFlow::Pipeline.new do\n      10.times do |i|\n        step \"step_#{i}\".to_sym, -&gt;(result) {\n          result.with_context(\"step_#{i}\".to_sym, true).continue(result.value)\n        }, depends_on: []\n      end\n    end\n\n    time = Benchmark.realtime do\n      100.times { pipeline.call_parallel(SimpleFlow::Result.new(0)) }\n    end\n\n    @results[:parallel] = time\n    puts \"Parallel (10 steps, 100 iterations): #{(time * 1000).round(2)}ms\"\n  end\n\n  def benchmark_middleware_overhead\n    pipeline = SimpleFlow::Pipeline.new do\n      use_middleware SimpleFlow::MiddleWare::Logging\n      step -&gt;(result) { result.continue(result.value) }\n    end\n\n    time = Benchmark.realtime do\n      100.times { pipeline.call(SimpleFlow::Result.new(0)) }\n    end\n\n    @results[:middleware] = time\n    puts \"Middleware overhead (100 iterations): #{(time * 1000).round(2)}ms\"\n  end\n\n  def benchmark_context_merging\n    pipeline = SimpleFlow::Pipeline.new do\n      step -&gt;(result) {\n        result\n          .with_context(:key1, \"value1\")\n          .with_context(:key2, \"value2\")\n          .with_context(:key3, \"value3\")\n          .continue(result.value)\n      }\n    end\n\n    time = Benchmark.realtime do\n      1000.times { pipeline.call(SimpleFlow::Result.new(0)) }\n    end\n\n    @results[:context_merging] = time\n    puts \"Context merging (1000 iterations): #{(time * 1000).round(2)}ms\"\n  end\n\n  def benchmark_error_handling\n    pipeline = SimpleFlow::Pipeline.new do\n      step -&gt;(result) {\n        result\n          .with_error(:validation, \"Error 1\")\n          .with_error(:validation, \"Error 2\")\n          .halt\n      }\n    end\n\n    time = Benchmark.realtime do\n      1000.times { pipeline.call(SimpleFlow::Result.new(0)) }\n    end\n\n    @results[:error_handling] = time\n    puts \"Error handling (1000 iterations): #{(time * 1000).round(2)}ms\"\n  end\n\n  def print_summary\n    puts\n    puts \"=\" * 60\n    puts \"Summary\"\n    puts \"=\" * 60\n\n    @results.each do |name, time|\n      puts \"#{name.to_s.ljust(20)}: #{(time * 1000).round(2)}ms\"\n    end\n  end\nend\n\nBenchmarkSuite.new.run_all\n</code></pre> <p>Run the suite: <pre><code>ruby benchmark/suite.rb\n</code></pre></p>"},{"location":"development/benchmarking/#profiling","title":"Profiling","text":""},{"location":"development/benchmarking/#using-rubys-profiler","title":"Using Ruby's Profiler","text":"<pre><code>require 'profile'\nrequire_relative '../lib/simple_flow'\n\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value + 1) }\n  step -&gt;(result) { result.continue(result.value * 2) }\nend\n\n100.times { pipeline.call(SimpleFlow::Result.new(5)) }\n</code></pre>"},{"location":"development/benchmarking/#using-ruby-prof","title":"Using ruby-prof","text":"<pre><code>require 'ruby-prof'\nrequire_relative '../lib/simple_flow'\n\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value + 1) }\n  step -&gt;(result) { result.continue(result.value * 2) }\nend\n\nRubyProf.start\n\n1000.times { pipeline.call(SimpleFlow::Result.new(5)) }\n\nresult = RubyProf.stop\n\n# Print a flat profile to text\nprinter = RubyProf::FlatPrinter.new(result)\nprinter.print($stdout)\n</code></pre>"},{"location":"development/benchmarking/#performance-tips","title":"Performance Tips","text":""},{"location":"development/benchmarking/#1-minimize-context-size","title":"1. Minimize Context Size","text":"<pre><code># SLOW: Large context objects\nstep -&gt;(result) {\n  large_data = load_all_users  # 10,000 records\n  result.with_context(:users, large_data).continue(result.value)\n}\n\n# FAST: Only essential data\nstep -&gt;(result) {\n  users = load_all_users\n  user_ids = users.map(&amp;:id)\n  result.with_context(:user_ids, user_ids).continue(result.value)\n}\n</code></pre>"},{"location":"development/benchmarking/#2-use-parallel-execution-for-io","title":"2. Use Parallel Execution for I/O","text":"<pre><code># SLOW: Sequential I/O\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.with_context(:a, fetch_api_a).continue(result.value) }\n  step -&gt;(result) { result.with_context(:b, fetch_api_b).continue(result.value) }\n  step -&gt;(result) { result.with_context(:c, fetch_api_c).continue(result.value) }\nend\n\n# FAST: Parallel I/O\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_a, -&gt;(result) {\n    result.with_context(:a, fetch_api_a).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_b, -&gt;(result) {\n    result.with_context(:b, fetch_api_b).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_c, -&gt;(result) {\n    result.with_context(:c, fetch_api_c).continue(result.value)\n  }, depends_on: []\nend\n</code></pre>"},{"location":"development/benchmarking/#3-avoid-unnecessary-steps","title":"3. Avoid Unnecessary Steps","text":"<pre><code># SLOW: Too many fine-grained steps\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value + 1) }\n  step -&gt;(result) { result.continue(result.value + 1) }\n  step -&gt;(result) { result.continue(result.value + 1) }\nend\n\n# FAST: Combine simple operations\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value + 3) }\nend\n</code></pre>"},{"location":"development/benchmarking/#related-documentation","title":"Related Documentation","text":"<ul> <li>Testing Guide - Writing tests</li> <li>Performance Guide - Performance characteristics</li> <li>Contributing Guide - Contributing to SimpleFlow</li> </ul>"},{"location":"development/contributing/","title":"Contributing to SimpleFlow","text":"<p>Thank you for your interest in contributing to SimpleFlow! This guide will help you get started.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#fork-and-clone","title":"Fork and Clone","text":"<ol> <li>Fork the repository on GitHub</li> <li> <p>Clone your fork locally: <pre><code>git clone https://github.com/YOUR_USERNAME/simple_flow.git\ncd simple_flow\n</code></pre></p> </li> <li> <p>Add the upstream repository: <pre><code>git remote add upstream https://github.com/madbomber/simple_flow.git\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#install-dependencies","title":"Install Dependencies","text":"<pre><code>bundle install\n</code></pre>"},{"location":"development/contributing/#run-tests","title":"Run Tests","text":"<pre><code>bundle exec rake test\n</code></pre> <p>Expected output: <pre><code>77 tests, 296 assertions, 0 failures, 0 errors, 0 skips\n</code></pre></p>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<p>Create a feature branch from <code>main</code>:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <p>Branch naming conventions: - <code>feature/</code> - New features - <code>fix/</code> - Bug fixes - <code>docs/</code> - Documentation changes - <code>refactor/</code> - Code refactoring - <code>test/</code> - Test additions or improvements</p>"},{"location":"development/contributing/#2-make-your-changes","title":"2. Make Your Changes","text":""},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>SimpleFlow follows standard Ruby conventions. Please ensure:</p> <ul> <li>Use 2 spaces for indentation</li> <li>Keep lines under 120 characters when possible</li> <li>Add comments for complex logic</li> <li>Use descriptive variable names</li> </ul>"},{"location":"development/contributing/#adding-features","title":"Adding Features","text":"<p>When adding a new feature:</p> <ol> <li>Write tests first (TDD approach)</li> <li>Implement the feature</li> <li>Update documentation</li> <li>Add examples if applicable</li> </ol>"},{"location":"development/contributing/#fixing-bugs","title":"Fixing Bugs","text":"<p>When fixing a bug:</p> <ol> <li>Add a failing test that reproduces the bug</li> <li>Fix the bug</li> <li>Ensure the test passes</li> <li>Consider adding regression tests</li> </ol>"},{"location":"development/contributing/#3-run-tests","title":"3. Run Tests","text":"<p>Run the full test suite:</p> <pre><code>bundle exec rake test\n</code></pre> <p>Run a specific test file:</p> <pre><code>ruby -Ilib:test test/pipeline_test.rb\n</code></pre> <p>Run a specific test:</p> <pre><code>ruby -Ilib:test test/pipeline_test.rb -n test_basic_pipeline\n</code></pre>"},{"location":"development/contributing/#4-update-documentation","title":"4. Update Documentation","text":"<p>If your changes affect user-facing behavior:</p> <ol> <li>Update relevant documentation in <code>docs/</code></li> <li>Update the README if needed</li> <li>Add or update code examples</li> <li>Update CHANGELOG.md</li> </ol>"},{"location":"development/contributing/#5-commit-your-changes","title":"5. Commit Your Changes","text":"<p>Write clear, descriptive commit messages:</p> <pre><code>git add .\ngit commit -m \"Add feature: parallel execution for named steps\n\n- Implement dependency graph analysis\n- Add automatic parallel detection\n- Include tests and documentation\n\"\n</code></pre> <p>Commit message guidelines: - Use present tense (\"Add feature\" not \"Added feature\") - First line should be under 72 characters - Include a blank line after the first line - Provide detailed description in the body if needed</p>"},{"location":"development/contributing/#6-push-and-create-pull-request","title":"6. Push and Create Pull Request","text":"<p>Push your branch:</p> <pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Create a pull request on GitHub: 1. Go to the SimpleFlow repository 2. Click \"New Pull Request\" 3. Select your branch 4. Fill out the pull request template 5. Submit for review</p>"},{"location":"development/contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":""},{"location":"development/contributing/#pr-template","title":"PR Template","text":"<pre><code>## Description\n\nBrief description of what this PR does.\n\n## Type of Change\n\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Breaking change\n- [ ] Documentation update\n\n## Changes Made\n\n- List of specific changes\n- Another change\n- And another\n\n## Testing\n\nDescribe how you tested your changes:\n\n- [ ] All existing tests pass\n- [ ] Added new tests for new functionality\n- [ ] Tested manually with examples\n\n## Documentation\n\n- [ ] Updated relevant documentation\n- [ ] Updated CHANGELOG.md\n- [ ] Added/updated code examples\n\n## Checklist\n\n- [ ] Code follows project style guidelines\n- [ ] Self-review completed\n- [ ] Comments added for complex code\n- [ ] No new warnings generated\n- [ ] Tests added and passing\n</code></pre>"},{"location":"development/contributing/#code-review-process","title":"Code Review Process","text":"<ol> <li>Automated Checks: GitHub Actions will run tests automatically</li> <li>Peer Review: A maintainer will review your code</li> <li>Feedback: Address any requested changes</li> <li>Approval: Once approved, your PR will be merged</li> </ol>"},{"location":"development/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"development/contributing/#test-structure","title":"Test Structure","text":"<p>Tests use Minitest:</p> <pre><code>require 'test_helper'\n\nclass MyFeatureTest &lt; Minitest::Test\n  def setup\n    # Setup code runs before each test\n    @pipeline = SimpleFlow::Pipeline.new\n  end\n\n  def test_feature_works\n    result = @pipeline.call(SimpleFlow::Result.new(42))\n\n    assert result.continue?\n    assert_equal 42, result.value\n  end\n\n  def test_handles_errors\n    result = @pipeline.call(SimpleFlow::Result.new(nil))\n\n    refute result.continue?\n    assert result.errors.any?\n  end\nend\n</code></pre>"},{"location":"development/contributing/#test-coverage","title":"Test Coverage","text":"<p>Aim for comprehensive test coverage:</p> <ul> <li>Test happy paths</li> <li>Test error conditions</li> <li>Test edge cases</li> <li>Test with various data types</li> </ul> <p>Current test coverage: 96.61% (121 tests, 296 assertions)</p>"},{"location":"development/contributing/#running-specific-tests","title":"Running Specific Tests","text":"<pre><code># Run all tests\nbundle exec rake test\n\n# Run specific test file\nruby -Ilib:test test/result_test.rb\n\n# Run specific test method\nruby -Ilib:test test/result_test.rb -n test_with_context\n</code></pre>"},{"location":"development/contributing/#documentation-guidelines","title":"Documentation Guidelines","text":""},{"location":"development/contributing/#adding-documentation","title":"Adding Documentation","text":"<p>When adding new features, update:</p> <ol> <li>API Reference (<code>docs/api/</code>)</li> <li>Complete method signatures</li> <li>Parameters and return values</li> <li> <p>Examples</p> </li> <li> <p>Guides (<code>docs/guides/</code>)</p> </li> <li>How-to guides</li> <li>Best practices</li> <li> <p>Real-world examples</p> </li> <li> <p>README.md</p> </li> <li>Overview of feature</li> <li>Quick start example</li> </ol>"},{"location":"development/contributing/#documentation-style","title":"Documentation Style","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Cross-reference related documentation</li> <li>Keep examples practical and realistic</li> </ul>"},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>simple_flow/\n\u251c\u2500\u2500 lib/\n\u2502   \u2514\u2500\u2500 simple_flow/\n\u2502       \u251c\u2500\u2500 dependency_graph.rb          # Dependency graph analysis\n\u2502       \u251c\u2500\u2500 dependency_graph_visualizer.rb # Visualization tools\n\u2502       \u251c\u2500\u2500 middleware.rb                # Built-in middleware\n\u2502       \u251c\u2500\u2500 parallel_executor.rb         # Parallel execution\n\u2502       \u251c\u2500\u2500 pipeline.rb                  # Pipeline orchestration\n\u2502       \u251c\u2500\u2500 result.rb                    # Result value object\n\u2502       \u251c\u2500\u2500 step_tracker.rb              # Step tracking\n\u2502       \u2514\u2500\u2500 version.rb                   # Version number\n\u251c\u2500\u2500 test/\n\u2502   \u251c\u2500\u2500 test_helper.rb                   # Test configuration\n\u2502   \u251c\u2500\u2500 result_test.rb                   # Result tests\n\u2502   \u251c\u2500\u2500 pipeline_test.rb                 # Pipeline tests\n\u2502   \u251c\u2500\u2500 middleware_test.rb               # Middleware tests\n\u2502   \u251c\u2500\u2500 parallel_execution_test.rb       # Parallel execution tests\n\u2502   \u2514\u2500\u2500 dependency_graph_test.rb         # Graph analysis tests\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 01_basic_pipeline.rb             # Basic usage\n\u2502   \u251c\u2500\u2500 02_error_handling.rb             # Error patterns\n\u2502   \u251c\u2500\u2500 03_middleware.rb                 # Middleware examples\n\u2502   \u251c\u2500\u2500 04_parallel_automatic.rb         # Auto parallel\n\u2502   \u251c\u2500\u2500 05_parallel_explicit.rb          # Explicit parallel\n\u2502   \u251c\u2500\u2500 06_real_world_ecommerce.rb       # E-commerce example\n\u2502   \u251c\u2500\u2500 07_real_world_etl.rb             # ETL example\n\u2502   \u251c\u2500\u2500 08_graph_visualization.rb        # Graph viz\n\u2502   \u2514\u2500\u2500 09_pipeline_visualization.rb     # Pipeline viz\n\u251c\u2500\u2500 docs/                                # Documentation\n\u2514\u2500\u2500 CHANGELOG.md                         # Change history\n</code></pre>"},{"location":"development/contributing/#adding-examples","title":"Adding Examples","text":"<p>When adding examples:</p> <ol> <li>Place in <code>examples/</code> directory</li> <li>Use clear, descriptive names</li> <li>Include comments explaining the code</li> <li>Make examples runnable</li> <li>Demonstrate real-world use cases</li> </ol> <p>Example template:</p> <pre><code>#!/usr/bin/env ruby\n# frozen_string_literal: true\n\nrequire_relative '../lib/simple_flow'\n\n# Description of what this example demonstrates\n\nputs \"=\" * 60\nputs \"Example: Your Example Name\"\nputs \"=\" * 60\nputs\n\n# Your example code here\n\nputs \"\\n\" + \"=\" * 60\nputs \"Example completed!\"\nputs \"=\" * 60\n</code></pre>"},{"location":"development/contributing/#releasing","title":"Releasing","text":"<p>(For maintainers only)</p> <ol> <li>Update version in <code>lib/simple_flow/version.rb</code></li> <li>Update CHANGELOG.md</li> <li>Commit changes</li> <li>Create git tag: <code>git tag v0.x.x</code></li> <li>Push tag: <code>git push --tags</code></li> <li>Build gem: <code>gem build simple_flow.gemspec</code></li> <li>Push to RubyGems: <code>gem push simple_flow-0.x.x.gem</code></li> </ol>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: Open an issue on GitHub</li> <li>Discussions: Use GitHub Discussions for questions</li> <li>Email: Contact maintainers directly for sensitive issues</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Provide constructive feedback</li> <li>Focus on the code, not the person</li> <li>Help others learn and grow</li> </ul>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing to SimpleFlow, you agree that your contributions will be licensed under the project's license.</p>"},{"location":"development/contributing/#thank-you","title":"Thank You!","text":"<p>Your contributions make SimpleFlow better for everyone. Thank you for taking the time to contribute!</p>"},{"location":"development/dagwood-concepts/","title":"Dagwood Concepts Analysis","text":""},{"location":"development/dagwood-concepts/#overview","title":"Overview","text":"<p>Dagwood is a Ruby gem for dependency graph analysis and resolution ordering using topologically sorted directed acyclic graphs (DAGs).</p>"},{"location":"development/dagwood-concepts/#key-dagwood-concepts","title":"Key Dagwood Concepts","text":""},{"location":"development/dagwood-concepts/#1-dependency-declaration","title":"1. Dependency Declaration","text":"<p>Dagwood explicitly declares dependencies between tasks:</p> <pre><code>graph = Dagwood::DependencyGraph.new(\n  add_mustard: [:slice_bread],\n  add_smoked_meat: [:slice_bread],\n  close_sandwich: [:add_mustard, :add_smoked_meat]\n)\n</code></pre>"},{"location":"development/dagwood-concepts/#2-automatic-parallel-detection","title":"2. Automatic Parallel Detection","text":"<p>The <code>parallel_order</code> method automatically groups tasks that can run concurrently:</p> <pre><code>graph.parallel_order\n# =&gt; [[:slice_bread], [:add_mustard, :add_smoked_meat], [:close_sandwich]]\n</code></pre> <p>Tasks in the same nested array can run in parallel because they have the same dependencies.</p>"},{"location":"development/dagwood-concepts/#3-serial-ordering","title":"3. Serial Ordering","text":"<p>The <code>order</code> method provides topologically sorted execution order:</p> <pre><code>graph.order\n# =&gt; [:slice_bread, :add_mustard, :add_smoked_meat, :close_sandwich]\n</code></pre>"},{"location":"development/dagwood-concepts/#4-reverse-ordering","title":"4. Reverse Ordering","text":"<p>The <code>reverse_order</code> method enables teardown/cleanup operations:</p> <pre><code>graph.reverse_order\n# =&gt; [:close_sandwich, :add_smoked_meat, :add_mustard, :slice_bread]\n</code></pre>"},{"location":"development/dagwood-concepts/#5-subgraphs","title":"5. Subgraphs","text":"<p>Extract dependency chains for specific nodes:</p> <pre><code>subgraph = graph.subgraph(:add_mustard)\nsubgraph.order\n# =&gt; [:slice_bread, :add_mustard]\n</code></pre>"},{"location":"development/dagwood-concepts/#6-graph-merging","title":"6. Graph Merging","text":"<p>Combine multiple dependency graphs:</p> <pre><code>ultimate_recipe = recipe1.merge(recipe2)\n</code></pre>"},{"location":"development/dagwood-concepts/#potential-improvements-for-simpleflow","title":"Potential Improvements for SimpleFlow","text":""},{"location":"development/dagwood-concepts/#1-automatic-parallel-detection-high-value","title":"1. \u2b50 Automatic Parallel Detection (High Value)","text":"<p>Current SimpleFlow (Manual): <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { fetch_user(result) }\n\n  # User must manually identify parallel steps\n  parallel do\n    step -&gt;(result) { fetch_orders(result) }\n    step -&gt;(result) { fetch_preferences(result) }\n  end\nend\n</code></pre></p> <p>With Dagwood Concepts (Automatic): <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user\n  step :fetch_orders, depends_on: [:fetch_user]\n  step :fetch_preferences, depends_on: [:fetch_user]\n  step :fetch_analytics  # No dependencies, runs first\n  step :aggregate, depends_on: [:fetch_orders, :fetch_preferences]\nend\n\n# Pipeline automatically determines:\n# Level 0: [:fetch_analytics, :fetch_user] (parallel)\n# Level 1: [:fetch_orders, :fetch_preferences] (parallel)\n# Level 2: [:aggregate]\n</code></pre></p> <p>Benefits: - No manual <code>parallel</code> blocks needed - Automatic optimization - Clearer dependency relationships - Easier to maintain</p>"},{"location":"development/dagwood-concepts/#2-pipeline-composition-high-value","title":"2. \u2b50 Pipeline Composition (High Value)","text":"<p>Merge Multiple Pipelines: <pre><code>user_flow = SimpleFlow::Pipeline.new do\n  step :fetch_user\n  step :validate_user, depends_on: [:fetch_user]\nend\n\norder_flow = SimpleFlow::Pipeline.new do\n  step :fetch_orders\n  step :calculate_total, depends_on: [:fetch_orders]\nend\n\n# Merge pipelines\ncombined = user_flow.merge(order_flow)\ncombined.parallel_order\n# Automatically detects:\n# Level 0: [:fetch_user, :fetch_orders] (parallel)\n# Level 1: [:validate_user, :calculate_total] (parallel)\n</code></pre></p> <p>Benefits: - Reusable pipeline components - Compose complex workflows from simple ones - Better modularity</p>"},{"location":"development/dagwood-concepts/#3-reversecleanup-pipelines-medium-value","title":"3. Reverse/Cleanup Pipelines (Medium Value)","text":"<p>Automatic Teardown: <pre><code>setup_pipeline = SimpleFlow::Pipeline.new do\n  step :create_temp_files\n  step :connect_database, depends_on: [:create_temp_files]\n  step :load_data, depends_on: [:connect_database]\nend\n\n# Automatically generate cleanup\ncleanup_pipeline = setup_pipeline.reverse\n# Executes: [:load_data, :connect_database, :create_temp_files] in reverse\n</code></pre></p> <p>Benefits: - Transaction rollback - Resource cleanup - Error recovery</p>"},{"location":"development/dagwood-concepts/#4-subgraph-extraction-medium-value","title":"4. Subgraph Extraction (Medium Value)","text":"<p>Partial Pipeline Execution: <pre><code>full_pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user\n  step :fetch_orders, depends_on: [:fetch_user]\n  step :fetch_preferences, depends_on: [:fetch_user]\n  step :calculate_total, depends_on: [:fetch_orders]\n  step :apply_discount, depends_on: [:calculate_total, :fetch_preferences]\nend\n\n# Extract only what's needed for calculate_total\npartial = full_pipeline.subgraph(:calculate_total)\n# Includes: [:fetch_user, :fetch_orders, :calculate_total]\n# Excludes: [:fetch_preferences, :apply_discount]\n</code></pre></p> <p>Benefits: - Run only necessary steps - Better performance - Easier testing</p>"},{"location":"development/dagwood-concepts/#5-named-steps-with-dependency-dsl-high-value","title":"5. Named Steps with Dependency DSL (High Value)","text":"<p>Better than Anonymous Lambdas: <pre><code>class UserPipeline &lt; SimpleFlow::Pipeline\n  define do\n    step :validate_input\n\n    step :fetch_user, depends_on: [:validate_input]\n    step :fetch_orders, depends_on: [:fetch_user]\n    step :fetch_preferences, depends_on: [:fetch_user]\n\n    step :enrich_user_data, depends_on: [\n      :fetch_user,\n      :fetch_orders,\n      :fetch_preferences\n    ]\n  end\n\n  def validate_input(result)\n    # Implementation\n    result.continue(result.value)\n  end\n\n  def fetch_user(result)\n    # Implementation\n  end\n\n  # ... other step methods\nend\n</code></pre></p> <p>Benefits: - Better debugging (named methods vs lambdas) - Easier testing (test individual methods) - Clear dependency visualization - Self-documenting code</p>"},{"location":"development/dagwood-concepts/#implementation-proposal","title":"Implementation Proposal","text":""},{"location":"development/dagwood-concepts/#phase-1-add-dependency-tracking","title":"Phase 1: Add Dependency Tracking","text":"<pre><code># lib/simple_flow/dependency_graph.rb\nrequire 'dagwood'\n\nmodule SimpleFlow\n  class DependencyGraph\n    def initialize\n      @steps = {}\n      @dependencies = {}\n    end\n\n    def add_step(name, callable, depends_on: [])\n      @steps[name] = callable\n      @dependencies[name] = depends_on\n    end\n\n    def parallel_order\n      graph = Dagwood::DependencyGraph.new(@dependencies)\n      graph.parallel_order\n    end\n\n    def execute(initial_result)\n      parallel_order.each do |level|\n        if level.length == 1\n          # Sequential step\n          step_name = level.first\n          initial_result = @steps[step_name].call(initial_result)\n        else\n          # Parallel steps\n          parallel_step = ParallelStep.new(level.map { |name| @steps[name] })\n          initial_result = parallel_step.call(initial_result)\n        end\n\n        break unless initial_result.continue?\n      end\n\n      initial_result\n    end\n  end\nend\n</code></pre>"},{"location":"development/dagwood-concepts/#phase-2-enhanced-pipeline-dsl","title":"Phase 2: Enhanced Pipeline DSL","text":"<pre><code># lib/simple_flow/pipeline.rb (enhanced)\nmodule SimpleFlow\n  class Pipeline\n    def initialize(&amp;config)\n      @dependency_graph = DependencyGraph.new\n      @steps = []\n      @middlewares = []\n      instance_eval(&amp;config) if block_given?\n    end\n\n    # New: Named step with dependencies\n    def step(name = nil, depends_on: [], &amp;block)\n      if name.is_a?(Symbol)\n        # Named step with dependencies\n        callable = block || method(name)\n        @dependency_graph.add_step(name, callable, depends_on: depends_on)\n      else\n        # Original anonymous step behavior (backward compatible)\n        callable = name || block\n        @steps &lt;&lt; apply_middleware(callable)\n      end\n      self\n    end\n\n    def call(result)\n      if @dependency_graph.has_steps?\n        # Use automatic parallel detection\n        @dependency_graph.execute(result)\n      else\n        # Use original sequential/manual parallel execution\n        @steps.reduce(result) do |res, step|\n          res.respond_to?(:continue?) &amp;&amp; !res.continue? ? res : step.call(res)\n        end\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"development/dagwood-concepts/#phase-3-pipeline-composition","title":"Phase 3: Pipeline Composition","text":"<pre><code># lib/simple_flow/pipeline.rb (enhanced)\nclass Pipeline\n  def merge(other_pipeline)\n    merged = Pipeline.new\n    merged.dependency_graph = @dependency_graph.merge(other_pipeline.dependency_graph)\n    merged\n  end\n\n  def reverse\n    reversed = Pipeline.new\n    reversed.dependency_graph = @dependency_graph.reverse\n    reversed\n  end\n\n  def subgraph(step_name)\n    partial = Pipeline.new\n    partial.dependency_graph = @dependency_graph.subgraph(step_name)\n    partial\n  end\nend\n</code></pre>"},{"location":"development/dagwood-concepts/#usage-examples","title":"Usage Examples","text":""},{"location":"development/dagwood-concepts/#example-1-automatic-parallelization","title":"Example 1: Automatic Parallelization","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user\n  step :fetch_orders, depends_on: [:fetch_user]\n  step :fetch_preferences, depends_on: [:fetch_user]\n  step :fetch_analytics, depends_on: [:fetch_user]\n  step :aggregate, depends_on: [:fetch_orders, :fetch_preferences, :fetch_analytics]\nend\n\n# Automatically executes as:\n# Level 0: fetch_user\n# Level 1: fetch_orders, fetch_preferences, fetch_analytics (parallel)\n# Level 2: aggregate\n</code></pre>"},{"location":"development/dagwood-concepts/#example-2-pipeline-composition","title":"Example 2: Pipeline Composition","text":"<pre><code>base_validation = SimpleFlow::Pipeline.new do\n  step :validate_email\n  step :validate_password\nend\n\nuser_creation = SimpleFlow::Pipeline.new do\n  step :create_user, depends_on: [:validate_email, :validate_password]\n  step :send_welcome_email, depends_on: [:create_user]\nend\n\nfull_flow = base_validation.merge(user_creation)\n</code></pre>"},{"location":"development/dagwood-concepts/#example-3-cleanup-pipeline","title":"Example 3: Cleanup Pipeline","text":"<pre><code>setup = SimpleFlow::Pipeline.new do\n  step :allocate_resources\n  step :create_connection, depends_on: [:allocate_resources]\n  step :initialize_state, depends_on: [:create_connection]\nend\n\n# Automatic cleanup in reverse order\ncleanup = setup.reverse\n</code></pre>"},{"location":"development/dagwood-concepts/#backward-compatibility","title":"Backward Compatibility","text":"<p>All enhancements maintain backward compatibility:</p> <pre><code># Old style still works\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { ... }\n  parallel do\n    step -&gt;(result) { ... }\n    step -&gt;(result) { ... }\n  end\nend\n\n# New style with dependencies\npipeline = SimpleFlow::Pipeline.new do\n  step :task1\n  step :task2, depends_on: [:task1]\nend\n\n# Mixed (both work together)\npipeline = SimpleFlow::Pipeline.new do\n  step :named_task\n  step -&gt;(result) { ... }  # Anonymous still works\nend\n</code></pre>"},{"location":"development/dagwood-concepts/#recommendations","title":"Recommendations","text":""},{"location":"development/dagwood-concepts/#high-priority","title":"High Priority","text":"<ol> <li>Dependency tracking and automatic parallelization - Biggest value add</li> <li>Named steps DSL - Better debugging and testing</li> <li>Pipeline composition - Better code reuse</li> </ol>"},{"location":"development/dagwood-concepts/#medium-priority","title":"Medium Priority","text":"<ol> <li>Reverse pipelines - Useful for cleanup</li> <li>Subgraph extraction - Useful for testing</li> </ol>"},{"location":"development/dagwood-concepts/#low-priority","title":"Low Priority","text":"<ol> <li>Complex dependency visualization - Nice to have</li> </ol>"},{"location":"development/dagwood-concepts/#next-steps","title":"Next Steps","text":"<ol> <li>Add <code>dagwood</code> as a dependency</li> <li>Implement <code>SimpleFlow::DependencyGraph</code> wrapper</li> <li>Enhance <code>Pipeline</code> DSL with named steps and <code>depends_on</code></li> <li>Add tests for new functionality</li> <li>Update documentation with examples</li> <li>Maintain 100% backward compatibility</li> </ol>"},{"location":"development/dagwood-concepts/#conclusion","title":"Conclusion","text":"<p>Integrating Dagwood concepts would make SimpleFlow: - Smarter - Automatic parallel detection - Cleaner - Declarative dependencies vs manual parallel blocks - More Powerful - Pipeline composition and merging - Easier to Debug - Named steps instead of anonymous lambdas - More Testable - Test individual steps by name</p> <p>The most valuable improvement would be automatic parallel detection through dependency declaration, eliminating the need for manual <code>parallel</code> blocks while making dependencies explicit and clear.</p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide covers testing strategies, patterns, and best practices for SimpleFlow.</p>"},{"location":"development/testing/#test-suite-overview","title":"Test Suite Overview","text":"<p>SimpleFlow uses Minitest for its test suite.</p> <p>Current Coverage: - 121 tests - 296 assertions - 96.61% code coverage - All tests passing</p>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#run-all-tests","title":"Run All Tests","text":"<pre><code>bundle exec rake test\n</code></pre> <p>Expected output: <pre><code>Run options: --seed 12345\n\n# Running:\n\n.............................................................................\n\nFinished in 0.123456s, 987.65 runs/s, 2345.67 assertions/s.\n\n121 tests, 296 assertions, 0 failures, 0 errors, 0 skips\n</code></pre></p>"},{"location":"development/testing/#run-specific-test-file","title":"Run Specific Test File","text":"<pre><code>ruby -Ilib:test test/pipeline_test.rb\n</code></pre>"},{"location":"development/testing/#run-specific-test","title":"Run Specific Test","text":"<pre><code>ruby -Ilib:test test/pipeline_test.rb -n test_basic_pipeline\n</code></pre>"},{"location":"development/testing/#run-tests-with-verbose-output","title":"Run Tests with Verbose Output","text":"<pre><code>ruby -Ilib:test test/pipeline_test.rb --verbose\n</code></pre>"},{"location":"development/testing/#test-organization","title":"Test Organization","text":"<p>Tests are organized by component:</p> <pre><code>test/\n\u251c\u2500\u2500 test_helper.rb                   # Test configuration and helpers\n\u251c\u2500\u2500 result_test.rb                   # Result class tests\n\u251c\u2500\u2500 pipeline_test.rb                 # Pipeline class tests\n\u251c\u2500\u2500 middleware_test.rb               # Middleware tests\n\u251c\u2500\u2500 parallel_execution_test.rb       # Parallel execution tests\n\u251c\u2500\u2500 dependency_graph_test.rb         # Dependency graph tests\n\u251c\u2500\u2500 dependency_graph_visualizer_test.rb  # Visualization tests\n\u251c\u2500\u2500 pipeline_visualization_test.rb   # Pipeline visualization tests\n\u2514\u2500\u2500 step_tracker_test.rb             # StepTracker tests\n</code></pre>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/testing/#basic-test-structure","title":"Basic Test Structure","text":"<pre><code>require 'test_helper'\n\nclass MyFeatureTest &lt; Minitest::Test\n  def setup\n    # Runs before each test\n    @pipeline = SimpleFlow::Pipeline.new\n  end\n\n  def test_feature_description\n    # Arrange\n    initial = SimpleFlow::Result.new(42)\n\n    # Act\n    result = @pipeline.call(initial)\n\n    # Assert\n    assert result.continue?\n    assert_equal 42, result.value\n  end\n\n  def teardown\n    # Runs after each test (if needed)\n  end\nend\n</code></pre>"},{"location":"development/testing/#testing-result-objects","title":"Testing Result Objects","text":"<pre><code>class ResultTest &lt; Minitest::Test\n  def test_new_result_has_default_values\n    result = SimpleFlow::Result.new(42)\n\n    assert_equal 42, result.value\n    assert_equal({}, result.context)\n    assert_equal({}, result.errors)\n    assert result.continue?\n  end\n\n  def test_with_context_adds_context\n    result = SimpleFlow::Result.new(42)\n      .with_context(:user_id, 123)\n      .with_context(:timestamp, Time.now)\n\n    assert_equal 123, result.context[:user_id]\n    assert result.context[:timestamp]\n  end\n\n  def test_with_error_accumulates_errors\n    result = SimpleFlow::Result.new(nil)\n      .with_error(:validation, \"Error 1\")\n      .with_error(:validation, \"Error 2\")\n\n    assert_equal 2, result.errors[:validation].size\n    assert_includes result.errors[:validation], \"Error 1\"\n    assert_includes result.errors[:validation], \"Error 2\"\n  end\n\n  def test_halt_stops_continuation\n    result = SimpleFlow::Result.new(42).halt\n\n    refute result.continue?\n  end\n\n  def test_immutability\n    original = SimpleFlow::Result.new(42)\n    modified = original.with_context(:key, \"value\")\n\n    assert_equal({}, original.context)\n    assert_equal({ key: \"value\" }, modified.context)\n    refute_equal original.object_id, modified.object_id\n  end\nend\n</code></pre>"},{"location":"development/testing/#testing-pipelines","title":"Testing Pipelines","text":"<pre><code>class PipelineTest &lt; Minitest::Test\n  def test_basic_sequential_execution\n    pipeline = SimpleFlow::Pipeline.new do\n      step -&gt;(result) { result.continue(result.value + 1) }\n      step -&gt;(result) { result.continue(result.value * 2) }\n    end\n\n    result = pipeline.call(SimpleFlow::Result.new(5))\n\n    assert_equal 12, result.value  # (5 + 1) * 2\n    assert result.continue?\n  end\n\n  def test_pipeline_halts_on_error\n    pipeline = SimpleFlow::Pipeline.new do\n      step -&gt;(result) { result.continue(result.value + 1) }\n      step -&gt;(result) { result.halt.with_error(:error, \"Failed\") }\n      step -&gt;(result) { result.continue(result.value * 2) }  # Should not execute\n    end\n\n    result = pipeline.call(SimpleFlow::Result.new(5))\n\n    assert_equal 6, result.value  # Only first step executed\n    refute result.continue?\n    assert_includes result.errors[:error], \"Failed\"\n  end\n\n  def test_pipeline_with_middleware\n    executed = []\n\n    logging_middleware = -&gt;(callable) {\n      -&gt;(result) {\n        executed &lt;&lt; :before\n        output = callable.call(result)\n        executed &lt;&lt; :after\n        output\n      }\n    }\n\n    pipeline = SimpleFlow::Pipeline.new do\n      use_middleware logging_middleware\n\n      step -&gt;(result) {\n        executed &lt;&lt; :step\n        result.continue(result.value)\n      }\n    end\n\n    pipeline.call(SimpleFlow::Result.new(nil))\n\n    assert_equal [:before, :step, :after], executed\n  end\nend\n</code></pre>"},{"location":"development/testing/#testing-parallel-execution","title":"Testing Parallel Execution","text":"<pre><code>class ParallelExecutionTest &lt; Minitest::Test\n  def test_parallel_steps_execute_concurrently\n    skip unless SimpleFlow::Pipeline.new.async_available?\n\n    execution_order = []\n    mutex = Mutex.new\n\n    pipeline = SimpleFlow::Pipeline.new do\n      step :step_a, -&gt;(result) {\n        mutex.synchronize { execution_order &lt;&lt; :a_start }\n        sleep 0.1\n        mutex.synchronize { execution_order &lt;&lt; :a_end }\n        result.with_context(:a, true).continue(result.value)\n      }, depends_on: []\n\n      step :step_b, -&gt;(result) {\n        mutex.synchronize { execution_order &lt;&lt; :b_start }\n        sleep 0.1\n        mutex.synchronize { execution_order &lt;&lt; :b_end }\n        result.with_context(:b, true).continue(result.value)\n      }, depends_on: []\n    end\n\n    result = pipeline.call_parallel(SimpleFlow::Result.new(nil))\n\n    assert result.context[:a]\n    assert result.context[:b]\n\n    # Both steps started before either finished\n    a_start_index = execution_order.index(:a_start)\n    b_start_index = execution_order.index(:b_start)\n    a_end_index = execution_order.index(:a_end)\n    b_end_index = execution_order.index(:b_end)\n\n    assert a_start_index &lt; a_end_index\n    assert b_start_index &lt; b_end_index\n  end\n\n  def test_parallel_execution_merges_contexts\n    pipeline = SimpleFlow::Pipeline.new do\n      step :step_a, -&gt;(result) {\n        result.with_context(:data_a, \"from A\").continue(result.value)\n      }, depends_on: []\n\n      step :step_b, -&gt;(result) {\n        result.with_context(:data_b, \"from B\").continue(result.value)\n      }, depends_on: []\n\n      step :combine, -&gt;(result) {\n        assert_equal \"from A\", result.context[:data_a]\n        assert_equal \"from B\", result.context[:data_b]\n        result.continue(result.value)\n      }, depends_on: [:step_a, :step_b]\n    end\n\n    result = pipeline.call_parallel(SimpleFlow::Result.new(nil))\n    assert result.continue?\n  end\nend\n</code></pre>"},{"location":"development/testing/#testing-middleware","title":"Testing Middleware","text":"<pre><code>class MiddlewareTest &lt; Minitest::Test\n  def test_logging_middleware_logs_execution\n    output = StringIO.new\n    logger = Logger.new(output)\n\n    pipeline = SimpleFlow::Pipeline.new do\n      use_middleware SimpleFlow::MiddleWare::Logging, logger: logger\n\n      step -&gt;(result) { result.continue(result.value) }\n    end\n\n    pipeline.call(SimpleFlow::Result.new(42))\n\n    log_output = output.string\n    assert_match(/Before call/, log_output)\n    assert_match(/After call/, log_output)\n  end\n\n  def test_instrumentation_middleware_measures_time\n    output = StringIO.new\n    $stdout = output\n\n    pipeline = SimpleFlow::Pipeline.new do\n      use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'test'\n\n      step -&gt;(result) {\n        sleep 0.01\n        result.continue(result.value)\n      }\n    end\n\n    pipeline.call(SimpleFlow::Result.new(nil))\n\n    $stdout = STDOUT\n    assert_match(/Instrumentation: test took/, output.string)\n  end\nend\n</code></pre>"},{"location":"development/testing/#testing-patterns","title":"Testing Patterns","text":""},{"location":"development/testing/#testing-step-classes","title":"Testing Step Classes","text":"<pre><code>class FetchUserStep\n  def call(result)\n    user = User.find(result.value)\n    result.with_context(:user, user).continue(result.value)\n  end\nend\n\nclass FetchUserStepTest &lt; Minitest::Test\n  def test_fetches_user_and_adds_to_context\n    # Mock User.find\n    user = { id: 123, name: \"John\" }\n    User.stub :find, user do\n      step = FetchUserStep.new\n      result = step.call(SimpleFlow::Result.new(123))\n\n      assert_equal user, result.context[:user]\n      assert result.continue?\n    end\n  end\n\n  def test_handles_user_not_found\n    User.stub :find, nil do\n      step = FetchUserStep.new\n      result = step.call(SimpleFlow::Result.new(999))\n\n      assert_nil result.context[:user]\n    end\n  end\nend\n</code></pre>"},{"location":"development/testing/#testing-error-handling","title":"Testing Error Handling","text":"<pre><code>def test_validation_errors\n  pipeline = SimpleFlow::Pipeline.new do\n    step -&gt;(result) {\n      if result.value[:email].nil?\n        result.with_error(:validation, \"Email required\")\n      end\n\n      if result.value[:password].nil?\n        result.with_error(:validation, \"Password required\")\n      end\n\n      if result.errors.any?\n        result.halt(result.value)\n      else\n        result.continue(result.value)\n      end\n    }\n  end\n\n  result = pipeline.call(SimpleFlow::Result.new({ email: nil, password: nil }))\n\n  refute result.continue?\n  assert_equal 2, result.errors[:validation].size\n  assert_includes result.errors[:validation], \"Email required\"\n  assert_includes result.errors[:validation], \"Password required\"\nend\n</code></pre>"},{"location":"development/testing/#testing-with-mocks-and-stubs","title":"Testing with Mocks and Stubs","text":"<pre><code>def test_external_api_call\n  # Stub HTTP client\n  mock_response = { status: \"ok\", data: [1, 2, 3] }\n\n  HTTP.stub :get, mock_response do\n    pipeline = SimpleFlow::Pipeline.new do\n      step -&gt;(result) {\n        response = HTTP.get(\"https://api.example.com\")\n        result.continue(response[:data])\n      }\n    end\n\n    result = pipeline.call(SimpleFlow::Result.new(nil))\n\n    assert_equal [1, 2, 3], result.value\n  end\nend\n</code></pre>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":""},{"location":"development/testing/#1-test-public-interfaces","title":"1. Test Public Interfaces","text":"<p>Focus on testing public methods and behaviors:</p> <pre><code># GOOD: Tests public interface\ndef test_pipeline_processes_data\n  result = pipeline.call(initial_data)\n  assert_equal expected_output, result.value\nend\n\n# AVOID: Testing internal implementation\ndef test_internal_step_processing\n  # Don't test private methods directly\nend\n</code></pre>"},{"location":"development/testing/#2-use-descriptive-test-names","title":"2. Use Descriptive Test Names","text":"<pre><code># GOOD: Clear what is being tested\ndef test_pipeline_halts_when_validation_fails\ndef test_parallel_steps_merge_contexts\ndef test_middleware_wraps_steps_in_correct_order\n\n# BAD: Vague test names\ndef test_pipeline\ndef test_it_works\n</code></pre>"},{"location":"development/testing/#3-test-edge-cases","title":"3. Test Edge Cases","text":"<pre><code>def test_handles_nil_value\ndef test_handles_empty_array\ndef test_handles_large_dataset\ndef test_handles_unicode_characters\n</code></pre>"},{"location":"development/testing/#4-keep-tests-focused","title":"4. Keep Tests Focused","text":"<pre><code># GOOD: Tests one thing\ndef test_with_context_adds_context\n  result = SimpleFlow::Result.new(42).with_context(:key, \"value\")\n  assert_equal \"value\", result.context[:key]\nend\n\n# BAD: Tests multiple things\ndef test_result_functionality\n  # Tests context, errors, halt, continue all in one test\nend\n</code></pre>"},{"location":"development/testing/#5-use-setup-and-teardown","title":"5. Use Setup and Teardown","text":"<pre><code>class PipelineTest &lt; Minitest::Test\n  def setup\n    @pipeline = create_test_pipeline\n    @initial_data = SimpleFlow::Result.new(test_data)\n  end\n\n  def teardown\n    cleanup_test_data if needed\n  end\n\n  def test_something\n    result = @pipeline.call(@initial_data)\n    # Test assertions\n  end\nend\n</code></pre>"},{"location":"development/testing/#running-tests-in-ci","title":"Running Tests in CI","text":"<p>SimpleFlow uses GitHub Actions for continuous integration. Tests run automatically on:</p> <ul> <li>Every push to any branch</li> <li>Every pull request</li> <li>Multiple Ruby versions (2.7, 3.0, 3.1, 3.2, 3.3)</li> </ul>"},{"location":"development/testing/#coverage-reports","title":"Coverage Reports","text":"<p>To generate coverage reports locally:</p> <pre><code># Add to test_helper.rb\nrequire 'simplecov'\nSimpleCov.start do\n  add_filter '/test/'\nend\n</code></pre> <p>Run tests: <pre><code>bundle exec rake test\n</code></pre></p> <p>View coverage: <pre><code>open coverage/index.html\n</code></pre></p>"},{"location":"development/testing/#related-documentation","title":"Related Documentation","text":"<ul> <li>Contributing Guide - How to contribute</li> <li>Benchmarking Guide - Performance testing</li> <li>Examples - Working examples to test against</li> </ul>"},{"location":"getting-started/examples/","title":"Examples","text":"<p>Explore real-world examples demonstrating SimpleFlow's capabilities.</p>"},{"location":"getting-started/examples/#running-examples","title":"Running Examples","text":"<p>All examples are located in the <code>examples/</code> directory of the repository. Run them with:</p> <pre><code>ruby examples/example_name.rb\n</code></pre>"},{"location":"getting-started/examples/#available-examples","title":"Available Examples","text":""},{"location":"getting-started/examples/#parallel-data-fetching","title":"Parallel Data Fetching","text":"<p>File: <code>examples/parallel_data_fetching.rb</code></p> <p>Demonstrates fetching data from multiple APIs concurrently for improved performance.</p> <p>Key Features: - Concurrent API calls - 4x performance improvement (0.4s \u2192 0.1s) - Result merging and aggregation</p> <p>Run: <pre><code>ruby examples/parallel_data_fetching.rb\n</code></pre></p> <p>Learn More: Data Fetching Guide</p>"},{"location":"getting-started/examples/#parallel-validation","title":"Parallel Validation","text":"<p>File: <code>examples/parallel_validation.rb</code></p> <p>Shows how to run multiple validation checks concurrently to quickly identify all errors.</p> <p>Key Features: - Concurrent validation checks - Error accumulation - Fast feedback on multiple validation failures</p> <p>Run: <pre><code>ruby examples/parallel_validation.rb\n</code></pre></p> <p>Learn More: Validation Patterns Guide</p>"},{"location":"getting-started/examples/#error-handling","title":"Error Handling","text":"<p>File: <code>examples/error_handling.rb</code></p> <p>Demonstrates various error handling patterns including validation, graceful degradation, and retry logic.</p> <p>Key Features: - Validation with error accumulation - Graceful degradation with optional services - Retry logic with exponential backoff</p> <p>Run: <pre><code>ruby examples/error_handling.rb\n</code></pre></p> <p>Learn More: Error Handling Guide</p>"},{"location":"getting-started/examples/#file-processing","title":"File Processing","text":"<p>File: <code>examples/file_processing.rb</code></p> <p>Shows how to process multiple files in parallel with validation, conversion, and summarization.</p> <p>Key Features: - Parallel file processing - Format conversion (JSON to CSV) - Data validation and summarization</p> <p>Run: <pre><code>ruby examples/file_processing.rb\n</code></pre></p> <p>Learn More: File Processing Guide</p>"},{"location":"getting-started/examples/#complex-workflow","title":"Complex Workflow","text":"<p>File: <code>examples/complex_workflow.rb</code></p> <p>A realistic e-commerce order processing pipeline with multiple stages and parallel execution blocks.</p> <p>Key Features: - 6-stage workflow - 4 parallel execution blocks - 15+ steps - User validation, inventory checks, payment processing - Context accumulation across stages</p> <p>Run: <pre><code>ruby examples/complex_workflow.rb\n</code></pre></p> <p>Learn More: Complex Workflows Guide</p>"},{"location":"getting-started/examples/#code-snippets","title":"Code Snippets","text":""},{"location":"getting-started/examples/#basic-pipeline","title":"Basic Pipeline","text":"<pre><code>require 'simple_flow'\n\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value.strip) }\n  step -&gt;(result) { result.continue(result.value.downcase) }\n  step -&gt;(result) { result.continue(\"Hello, #{result.value}!\") }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(\"  WORLD  \"))\nputs result.value  # =&gt; \"Hello, world!\"\n</code></pre>"},{"location":"getting-started/examples/#with-middleware","title":"With Middleware","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n  use_middleware SimpleFlow::MiddleWare::Instrumentation, api_key: 'abc123'\n\n  step -&gt;(result) { result.continue(result.value + 10) }\n  step -&gt;(result) { result.continue(result.value * 2) }\nend\n</code></pre>"},{"location":"getting-started/examples/#concurrent-execution","title":"Concurrent Execution","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { fetch_user(result) }\n\n  parallel do\n    step -&gt;(result) { fetch_orders(result) }\n    step -&gt;(result) { fetch_preferences(result) }\n    step -&gt;(result) { fetch_analytics(result) }\n  end\n\n  step -&gt;(result) { aggregate_data(result) }\nend\n</code></pre>"},{"location":"getting-started/examples/#error-handling_1","title":"Error Handling","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    if result.value &lt; 0\n      result.halt.with_error(:validation, \"Value must be positive\")\n    else\n      result.continue(result.value)\n    end\n  }\n\n  step -&gt;(result) {\n    # Only runs if validation passed\n    result.continue(result.value * 2)\n  }\nend\n</code></pre>"},{"location":"getting-started/examples/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Run benchmarks to see SimpleFlow's performance:</p> <pre><code># Compare parallel vs sequential execution\nruby benchmarks/parallel_vs_sequential.rb\n\n# Measure pipeline overhead\nruby benchmarks/pipeline_overhead.rb\n</code></pre>"},{"location":"getting-started/examples/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts - Understand the fundamentals</li> <li>Concurrent Execution - Deep dive into parallelism</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Ruby &gt;= 2.7.0</li> <li>Bundler (recommended)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-bundler-recommended","title":"Using Bundler (Recommended)","text":"<p>Add SimpleFlow to your <code>Gemfile</code>:</p> <pre><code>gem 'simple_flow'\n</code></pre> <p>Then install:</p> <pre><code>bundle install\n</code></pre>"},{"location":"getting-started/installation/#using-rubygems","title":"Using RubyGems","text":"<p>Install directly with gem:</p> <pre><code>gem install simple_flow\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>SimpleFlow has minimal dependencies:</p> <ul> <li>async (~&gt; 2.0) - For concurrent execution support</li> </ul> <p>All dependencies are automatically installed.</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify SimpleFlow is working:</p> <pre><code>require 'simple_flow'\n\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(\"Hello, SimpleFlow!\") }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(nil))\nputs result.value\n# =&gt; \"Hello, SimpleFlow!\"\n</code></pre> <p>If this runs without errors, you're ready to go!</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first pipeline</li> <li>Examples - See SimpleFlow in action</li> <li>Core Concepts - Understand the fundamentals</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with SimpleFlow in 5 minutes!</p>"},{"location":"getting-started/quick-start/#your-first-pipeline","title":"Your First Pipeline","text":"<pre><code>require 'simple_flow'\n\n# Create a simple text processing pipeline\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value.strip) }\n  step -&gt;(result) { result.continue(result.value.downcase) }\n  step -&gt;(result) { result.continue(\"Hello, #{result.value}!\") }\nend\n\n# Execute the pipeline\nresult = pipeline.call(SimpleFlow::Result.new(\"  WORLD  \"))\nputs result.value\n# =&gt; \"Hello, world!\"\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-the-basics","title":"Understanding the Basics","text":""},{"location":"getting-started/quick-start/#sequential-execution","title":"Sequential Execution","text":"<p>Steps execute in order, with each step automatically depending on the previous step's success.</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { puts \"Step 1\"; result.continue(result.value) }\n  step -&gt;(result) { puts \"Step 2\"; result.halt(\"error\") }  # Stops here\n  step -&gt;(result) { puts \"Step 3\"; result.continue(result.value) }  # Never runs\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(nil))\n# Output: Step 1\n#         Step 2\n# (Step 3 is skipped because Step 2 halted)\n</code></pre> <p>When any step halts (returns <code>result.halt</code>), the pipeline stops immediately and subsequent steps are not executed.</p>"},{"location":"getting-started/quick-start/#1-create-a-result","title":"1. Create a Result","text":"<p>A <code>Result</code> wraps your data:</p> <pre><code>result = SimpleFlow::Result.new(42)\n</code></pre>"},{"location":"getting-started/quick-start/#2-define-steps","title":"2. Define Steps","text":"<p>Steps are callable objects (usually lambdas) that transform results:</p> <pre><code>step -&gt;(result) {\n  new_value = result.value * 2\n  result.continue(new_value)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#3-build-a-pipeline","title":"3. Build a Pipeline","text":"<p>Combine steps into a pipeline:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(result.value + 10) }\n  step -&gt;(result) { result.continue(result.value * 2) }\nend\n</code></pre>"},{"location":"getting-started/quick-start/#4-execute","title":"4. Execute","text":"<p>Call the pipeline with an initial result:</p> <pre><code>final = pipeline.call(SimpleFlow::Result.new(5))\nputs final.value  # =&gt; 30  ((5 + 10) * 2)\n</code></pre>"},{"location":"getting-started/quick-start/#adding-context","title":"Adding Context","text":"<p>Track metadata throughout your pipeline:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    result\n      .with_context(:started_at, Time.now)\n      .continue(result.value)\n  }\n\n  step -&gt;(result) {\n    result\n      .with_context(:user, \"Alice\")\n      .continue(result.value.upcase)\n  }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(\"hello\"))\nputs result.value    # =&gt; \"HELLO\"\nputs result.context  # =&gt; {:started_at=&gt;..., :user=&gt;\"Alice\"}\n</code></pre>"},{"location":"getting-started/quick-start/#error-handling","title":"Error Handling","text":"<p>Accumulate errors and halt execution:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    age = result.value\n    if age &lt; 18\n      result.halt.with_error(:age, \"Must be 18 or older\")\n    else\n      result.continue(age)\n    end\n  }\n\n  step -&gt;(result) {\n    # This won't execute if age &lt; 18\n    result.continue(\"Approved for age #{result.value}\")\n  }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(16))\nputs result.continue?  # =&gt; false\nputs result.errors     # =&gt; {:age=&gt;[\"Must be 18 or older\"]}\n</code></pre>"},{"location":"getting-started/quick-start/#concurrent-execution","title":"Concurrent Execution","text":"<p>Run independent steps in parallel:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  parallel do\n    step -&gt;(result) { result.with_context(:a, fetch_data_a).continue(result.value) }\n    step -&gt;(result) { result.with_context(:b, fetch_data_b).continue(result.value) }\n    step -&gt;(result) { result.with_context(:c, fetch_data_c).continue(result.value) }\n  end\n\n  step -&gt;(result) {\n    # All three fetches completed concurrently\n    result.continue(\"Aggregated data\")\n  }\nend\n</code></pre>"},{"location":"getting-started/quick-start/#middleware","title":"Middleware","text":"<p>Add cross-cutting concerns:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  use_middleware SimpleFlow::MiddleWare::Logging\n\n  step -&gt;(result) { result.continue(result.value + 1) }\n  step -&gt;(result) { result.continue(result.value * 2) }\nend\n\n# Logs before and after each step\n</code></pre>"},{"location":"getting-started/quick-start/#real-world-example","title":"Real-World Example","text":"<p>Here's a more complete example:</p> <pre><code>require 'simple_flow'\n\n# Define validation steps\nvalidate_email = -&gt;(result) {\n  email = result.value[:email]\n  if email &amp;&amp; email.match?(/\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z]+)+\\z/i)\n    result.continue(result.value)\n  else\n    result.halt(result.value).with_error(:email, \"Invalid email format\")\n  end\n}\n\nvalidate_age = -&gt;(result) {\n  age = result.value[:age]\n  if age &amp;&amp; age &gt;= 18\n    result.continue(result.value)\n  else\n    result.halt(result.value).with_error(:age, \"Must be 18 or older\")\n  end\n}\n\n# Build validation pipeline\nvalidation_pipeline = SimpleFlow::Pipeline.new do\n  step validate_email\n  step validate_age\nend\n\n# Test with valid data\nvalid_data = { email: \"alice@example.com\", age: 25 }\nresult = validation_pipeline.call(SimpleFlow::Result.new(valid_data))\nputs result.continue?  # =&gt; true\n\n# Test with invalid data\ninvalid_data = { email: \"invalid\", age: 16 }\nresult = validation_pipeline.call(SimpleFlow::Result.new(invalid_data))\nputs result.continue?  # =&gt; false\nputs result.errors     # =&gt; {:email=&gt;[\"Invalid email format\"]}\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you've got the basics, explore:</p> <ul> <li>Examples - Real-world use cases</li> <li>Core Concepts - Deep dive into architecture</li> <li>Concurrent Execution - Maximize performance</li> <li>Error Handling Guide - Advanced error patterns</li> </ul>"},{"location":"guides/choosing-concurrency-model/","title":"Choosing a Concurrency Model","text":"<p>SimpleFlow supports two different approaches for parallel execution: Ruby threads and the async gem (fiber-based). This guide helps you choose the right one for your use case.</p>"},{"location":"guides/choosing-concurrency-model/#overview","title":"Overview","text":"<p>You can control which concurrency model a pipeline uses in two ways:</p>"},{"location":"guides/choosing-concurrency-model/#1-automatic-detection-default","title":"1. Automatic Detection (Default)","text":"<p>When you create a pipeline without specifying concurrency:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # steps...\nend\n</code></pre> <p>SimpleFlow automatically uses the best available model: - Without async gem: Uses Ruby's built-in threads - With async gem: Uses fiber-based concurrency</p>"},{"location":"guides/choosing-concurrency-model/#2-explicit-concurrency-selection","title":"2. Explicit Concurrency Selection","text":"<p>You can explicitly choose the concurrency model per pipeline:</p> <pre><code># Force threads (even if async gem is available)\npipeline = SimpleFlow::Pipeline.new(concurrency: :threads) do\n  # steps...\nend\n\n# Force async (raises error if async gem not available)\npipeline = SimpleFlow::Pipeline.new(concurrency: :async) do\n  # steps...\nend\n\n# Auto-detect (default behavior)\npipeline = SimpleFlow::Pipeline.new(concurrency: :auto) do\n  # steps...\nend\n</code></pre> <p>Both provide actual parallel execution - the difference is in how they achieve it and their resource characteristics.</p>"},{"location":"guides/choosing-concurrency-model/#ruby-threads-without-async-gem","title":"Ruby Threads (Without async gem)","text":""},{"location":"guides/choosing-concurrency-model/#how-it-works","title":"How It Works","text":"<ul> <li>Creates actual OS threads (like having multiple workers)</li> <li>Each thread runs independently</li> <li>Ruby's GIL (Global Interpreter Lock) means only one thread runs Ruby code at a time</li> <li>BUT: When a thread waits for I/O (network, disk, database), other threads can run</li> </ul>"},{"location":"guides/choosing-concurrency-model/#best-for","title":"Best For","text":"<ul> <li>Simple use cases: You just want things to run in parallel</li> <li>Blocking I/O operations:</li> <li>Making HTTP requests to APIs</li> <li>Reading/writing files</li> <li>Database queries</li> <li>Any \"waiting\" operations</li> <li>Mixed libraries: Works with any Ruby gem (doesn't need async support)</li> <li>Small-to-medium concurrency: 10-100 parallel operations</li> </ul>"},{"location":"guides/choosing-concurrency-model/#resource-usage","title":"Resource Usage","text":"<ul> <li>Each thread uses ~1-2 MB of memory</li> <li>OS manages thread scheduling</li> <li>Limited by system resources (maybe 100-1,000 threads max)</li> </ul>"},{"location":"guides/choosing-concurrency-model/#example-scenario","title":"Example Scenario","text":"<pre><code># Fetching data from 10 different APIs in parallel\npipeline = SimpleFlow::Pipeline.new do\n  step :validate, validator, depends_on: []\n\n  # These 10 API calls run in parallel with threads\n  step :api_1, -&gt;(r) { r.with_context(:api_1, fetch_api_1) }, depends_on: [:validate]\n  step :api_2, -&gt;(r) { r.with_context(:api_2, fetch_api_2) }, depends_on: [:validate]\n  # ... 8 more API calls\n\n  step :merge, merger, depends_on: [:api_1, :api_2, ...]\nend\n\n# Each API call takes 500ms, threads let them all wait simultaneously\n# Total time: ~500ms instead of 5 seconds\nresult = pipeline.call_parallel(initial_data)\n</code></pre>"},{"location":"guides/choosing-concurrency-model/#async-gem-fiber-based","title":"Async Gem (Fiber-based)","text":""},{"location":"guides/choosing-concurrency-model/#how-it-works_1","title":"How It Works","text":"<ul> <li>Uses Ruby \"fibers\" (lightweight green threads)</li> <li>Cooperative scheduling (fibers yield control when waiting)</li> <li>Event loop manages thousands of concurrent operations</li> <li>Requires async-aware libraries (async-http, async-postgres, etc.)</li> </ul>"},{"location":"guides/choosing-concurrency-model/#best-for_1","title":"Best For","text":"<ul> <li>High concurrency: Thousands of simultaneous operations</li> <li>I/O-heavy applications: Web scrapers, API gateways, chat servers</li> <li>Long-running services: Background workers processing many jobs</li> <li>Async-compatible stack: When using async-aware gems</li> </ul>"},{"location":"guides/choosing-concurrency-model/#resource-usage_1","title":"Resource Usage","text":"<ul> <li>Each fiber uses ~4-8 KB of memory (250x lighter than threads!)</li> <li>Can handle 10,000+ concurrent operations</li> <li>More efficient CPU and memory usage</li> </ul>"},{"location":"guides/choosing-concurrency-model/#example-scenario_1","title":"Example Scenario","text":"<pre><code># Web scraper fetching 10,000 product pages\nrequire 'async'\nrequire 'async/http/internet'\n\npipeline = SimpleFlow::Pipeline.new do\n  step :load_urls, url_loader, depends_on: []\n\n  # With async gem, can handle thousands of concurrent requests\n  step :fetch_pages, -&gt;(result) {\n    urls = result.value[:urls]\n    pages = Async::HTTP::Internet.new.get_all(urls)\n    result.with_context(:pages, pages).continue(result.value)\n  }, depends_on: [:load_urls]\n\n  step :parse_data, parser, depends_on: [:fetch_pages]\nend\n\n# With threads: Would crash or be very slow (10,000 threads = 10+ GB RAM)\n# With async: Handles it smoothly (10,000 fibers = ~80 MB RAM)\nresult = pipeline.call_parallel(initial_data)\n</code></pre>"},{"location":"guides/choosing-concurrency-model/#decision-guide","title":"Decision Guide","text":""},{"location":"guides/choosing-concurrency-model/#use-threads-no-async-gem-when","title":"Use Threads (no async gem) when:","text":"<p>\u2705 You have 10-100 parallel operations \u2705 Using standard Ruby gems (not async-compatible) \u2705 Making database queries or HTTP requests with traditional libraries \u2705 You want simple, straightforward code \u2705 Building internal tools or scripts</p> <p>Example: <pre><code># E-commerce checkout: Check inventory, calculate shipping, process payment\n# 3-5 parallel operations, standard libraries\n\n# Option 1: Auto-detect (uses threads since no async gem needed)\npipeline = SimpleFlow::Pipeline.new do\n  step :validate_order, validator, depends_on: []\n  step :check_inventory, inventory_checker, depends_on: [:validate_order]\n  step :calculate_shipping, shipping_calculator, depends_on: [:validate_order]\n  step :process_payment, payment_processor, depends_on: [:check_inventory, :calculate_shipping]\nend\n\n# Option 2: Explicitly use threads (works even if async gem is installed)\npipeline = SimpleFlow::Pipeline.new(concurrency: :threads) do\n  step :validate_order, validator, depends_on: []\n  step :check_inventory, inventory_checker, depends_on: [:validate_order]\n  step :calculate_shipping, shipping_calculator, depends_on: [:validate_order]\n  step :process_payment, payment_processor, depends_on: [:check_inventory, :calculate_shipping]\nend\n\nresult = pipeline.call_parallel(order)  # \u2705 Threads work great\n</code></pre></p>"},{"location":"guides/choosing-concurrency-model/#use-async-add-async-gem-when","title":"Use Async (add async gem) when:","text":"<p>\u2705 You need 1,000+ concurrent operations \u2705 Building high-performance web services \u2705 Processing large-scale I/O operations (web scraping, bulk APIs) \u2705 Using async-compatible libraries (async-http, async-postgres) \u2705 Optimizing resource usage (hosting costs, memory limits)</p> <p>Example: <pre><code># Monitoring service checking 5,000 endpoints every minute\n# Need low memory footprint and high concurrency\n\n# Gemfile:\ngem 'async', '~&gt; 2.0'\ngem 'async-http', '~&gt; 0.60'\n\n# Explicitly require async concurrency for this high-volume pipeline\npipeline = SimpleFlow::Pipeline.new(concurrency: :async) do\n  step :load_endpoints, endpoint_loader, depends_on: []\n\n  # Async gem allows 5,000 concurrent health checks efficiently\n  step :check_all, health_checker, depends_on: [:load_endpoints]\n\n  step :aggregate_results, aggregator, depends_on: [:check_all]\nend\n\nresult = pipeline.call_parallel(config)  # \u2705 Async is essential\n# Raises error if async gem not installed\n</code></pre></p>"},{"location":"guides/choosing-concurrency-model/#quick-comparison-table","title":"Quick Comparison Table","text":"Factor Ruby Threads Async Gem Setup None (built-in) <code>gem 'async'</code> Concurrency Limit ~100-1,000 ~10,000+ Memory per operation 1-2 MB 4-8 KB Library compatibility Any Ruby gem Needs async-aware gems Learning curve Simple Moderate Speed (I/O) Fast Faster Speed (CPU) GIL-limited GIL-limited (same) Best use case Standard apps High-concurrency services"},{"location":"guides/choosing-concurrency-model/#real-world-analogy","title":"Real-World Analogy","text":"<p>Threads = Hiring separate workers - Each worker has their own desk, phone, computer (more resources) - Can have 50-100 workers before office gets crowded - Workers use regular tools everyone knows - Easy to manage</p> <p>Async = One worker with a really efficient task list - Worker rapidly switches between tasks when waiting - Can juggle 10,000 tasks because they're mostly waiting anyway - Needs special tools designed for rapid task-switching - More efficient but requires planning</p>"},{"location":"guides/choosing-concurrency-model/#switching-between-models","title":"Switching Between Models","text":"<p>The beauty of SimpleFlow is that you can switch between concurrency models without changing your pipeline code:</p>"},{"location":"guides/choosing-concurrency-model/#starting-with-threads","title":"Starting with Threads","text":"<pre><code># Gemfile - no async gem\ngem 'simple_flow'\n\n# Your pipeline code\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user, user_fetcher, depends_on: []\n  step :fetch_orders, order_fetcher, depends_on: [:fetch_user]\n  step :fetch_products, product_fetcher, depends_on: [:fetch_user]\nend\n\nresult = pipeline.call_parallel(data)  # Uses threads\n</code></pre>"},{"location":"guides/choosing-concurrency-model/#upgrading-to-async","title":"Upgrading to Async","text":"<pre><code># Gemfile - add async gem\ngem 'simple_flow'\ngem 'async', '~&gt; 2.0'\n\n# Same pipeline code - no changes needed!\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_user, user_fetcher, depends_on: []\n  step :fetch_orders, order_fetcher, depends_on: [:fetch_user]\n  step :fetch_products, product_fetcher, depends_on: [:fetch_user]\nend\n\nresult = pipeline.call_parallel(data)  # Now uses async automatically\n</code></pre>"},{"location":"guides/choosing-concurrency-model/#mixing-concurrency-models-in-one-application","title":"Mixing Concurrency Models in One Application","text":"<p>You can use different concurrency models for different pipelines in the same application:</p> <pre><code># Gemfile - include async for high-volume pipelines\ngem 'simple_flow'\ngem 'async', '~&gt; 2.0'\n\n# Low-volume pipeline: Use threads for simplicity\nuser_pipeline = SimpleFlow::Pipeline.new(concurrency: :threads) do\n  step :validate, validator, depends_on: []\n  step :fetch_profile, profile_fetcher, depends_on: [:validate]\n  step :fetch_preferences, prefs_fetcher, depends_on: [:validate]\nend\n\n# High-volume pipeline: Use async for efficiency\nmonitoring_pipeline = SimpleFlow::Pipeline.new(concurrency: :async) do\n  step :load_endpoints, endpoint_loader, depends_on: []\n  step :check_all, health_checker, depends_on: [:load_endpoints]\n  step :alert, alerter, depends_on: [:check_all]\nend\n\n# Each pipeline uses its configured concurrency model\nuser_result = user_pipeline.call_parallel(user_data)        # Uses threads\nmonitoring_result = monitoring_pipeline.call_parallel(config) # Uses async\n</code></pre> <p>This allows you to optimize each pipeline based on its specific requirements!</p>"},{"location":"guides/choosing-concurrency-model/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"guides/choosing-concurrency-model/#io-bound-operations","title":"I/O-Bound Operations","text":"<p>Both threads and async excel at I/O-bound operations (network, disk, database):</p> <pre><code># API calls, database queries, file operations\n# Both models provide significant speedup over sequential execution\n\n# Sequential: 10 API calls \u00d7 200ms = 2000ms\n# Threads:    10 API calls in parallel = ~200ms\n# Async:      10 API calls in parallel = ~200ms\n\n# Winner: Tie (both are fast for moderate I/O)\n</code></pre>"},{"location":"guides/choosing-concurrency-model/#high-concurrency-1000-operations","title":"High Concurrency (1000+ operations)","text":"<p>Async shines when dealing with thousands of concurrent operations:</p> <pre><code># 5,000 concurrent HTTP requests\n\n# Threads:  5,000 threads \u00d7 1.5 MB = 7.5 GB RAM \u274c\n# Async:    5,000 fibers \u00d7 6 KB = 30 MB RAM \u2705\n\n# Winner: Async (dramatically lower resource usage)\n</code></pre>"},{"location":"guides/choosing-concurrency-model/#cpu-bound-operations","title":"CPU-Bound Operations","text":"<p>Neither model helps with pure CPU work due to Ruby's GIL:</p> <pre><code># Heavy computation (image processing, data crunching)\n# GIL ensures only one thread/fiber does CPU work at a time\n\n# Sequential: 1000ms\n# Threads:    1000ms (GIL limitation)\n# Async:      1000ms (GIL limitation)\n\n# Winner: None (use process-based parallelism for CPU work)\n</code></pre>"},{"location":"guides/choosing-concurrency-model/#common-questions","title":"Common Questions","text":""},{"location":"guides/choosing-concurrency-model/#q-can-i-use-both-in-the-same-application","title":"Q: Can I use both in the same application?","text":"<p>A: Yes! SimpleFlow automatically detects if async is available and uses it. Different pipelines in the same app can use different models.</p>"},{"location":"guides/choosing-concurrency-model/#q-do-i-need-to-change-my-code-to-switch-models","title":"Q: Do I need to change my code to switch models?","text":"<p>A: No! Just add or remove the <code>async</code> gem from your Gemfile. Your pipeline code stays the same.</p>"},{"location":"guides/choosing-concurrency-model/#q-what-if-im-not-sure-which-to-use","title":"Q: What if I'm not sure which to use?","text":"<p>A: Start without async (use threads). It's simpler and works great for most use cases. Add async later if you need it.</p>"},{"location":"guides/choosing-concurrency-model/#q-can-i-check-which-model-is-being-used","title":"Q: Can I check which model is being used?","text":"<p>A: Yes! Use the <code>async_available?</code> method:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new\nputs \"Using async: #{pipeline.async_available?}\"\n</code></pre>"},{"location":"guides/choosing-concurrency-model/#q-are-there-any-compatibility-issues-with-async","title":"Q: Are there any compatibility issues with async?","text":"<p>A: Async requires async-aware libraries for best results: - Use <code>async-http</code> instead of <code>net/http</code> or <code>httparty</code> - Use <code>async-postgres</code> instead of <code>pg</code> - Check if your favorite gems have async versions</p> <p>With threads, any Ruby gem works out of the box.</p>"},{"location":"guides/choosing-concurrency-model/#recommendations","title":"Recommendations","text":""},{"location":"guides/choosing-concurrency-model/#for-most-users","title":"For Most Users","text":"<p>Start with threads (no async gem): - Simpler setup - Works with any library - Sufficient for most applications - Easy to understand and debug</p>"},{"location":"guides/choosing-concurrency-model/#upgrade-to-async-when","title":"Upgrade to Async When","text":"<p>You experience any of these: - \u26a0\ufe0f High memory usage from threads - \u26a0\ufe0f Need more than 100 concurrent operations - \u26a0\ufe0f Building high-throughput services - \u26a0\ufe0f Already using async-compatible libraries - \u26a0\ufe0f Hosting costs driven by memory usage</p>"},{"location":"guides/choosing-concurrency-model/#migration-path","title":"Migration Path","text":"<ol> <li>Start: Build with threads (no dependencies)</li> <li>Measure: Profile your application under realistic load</li> <li>Decide: If you hit thread limits, add async gem</li> <li>Switch: Just add gem to Gemfile, no code changes</li> <li>Optimize: Gradually adopt async-aware libraries for better performance</li> </ol>"},{"location":"guides/choosing-concurrency-model/#next-steps","title":"Next Steps","text":"<ul> <li>Parallel Execution - Deep dive into parallel execution patterns</li> <li>Performance - Benchmarking and optimization tips</li> <li>Best Practices - Concurrent programming patterns</li> <li>Error Handling - Handling errors in parallel pipelines</li> </ul>"},{"location":"guides/choosing-concurrency-model/#summary","title":"Summary","text":"Your Scenario Recommendation Building internal tools, scripts \u2705 Threads (no async) Standard web app with DB queries \u2705 Threads (no async) Processing 10-100 parallel tasks \u2705 Threads (no async) High-volume API gateway \u2705 Async (add gem) Web scraper (1000+ requests) \u2705 Async (add gem) Real-time chat/notifications \u2705 Async (add gem) Background job processor \u2705 Async (add gem) <p>Remember: You can always start simple (threads) and upgrade to async later without changing your pipeline code!</p>"},{"location":"guides/complex-workflows/","title":"Complex Workflows Guide","text":"<p>This guide demonstrates how to build sophisticated, real-world workflows using SimpleFlow's advanced features.</p>"},{"location":"guides/complex-workflows/#e-commerce-order-processing","title":"E-Commerce Order Processing","text":"<p>Complete order processing pipeline with validation, inventory, payment, and notifications:</p> <pre><code>class OrderProcessor\n  def self.build\n    SimpleFlow::Pipeline.new do\n      # Step 1: Validate order\n      step :validate_order, -&gt;(result) {\n        order = result.value\n        errors = []\n\n        errors &lt;&lt; \"Missing email\" unless order[:customer][:email]\n        errors &lt;&lt; \"No items\" if order[:items].empty?\n        errors &lt;&lt; \"Missing payment\" unless order[:payment][:card_token]\n\n        if errors.any?\n          result.halt.with_error(:validation, errors.join(\", \"))\n        else\n          result.with_context(:validated_at, Time.now).continue(order)\n        end\n      }, depends_on: []\n\n      # Steps 2-3: Parallel checks\n      step :check_inventory, -&gt;(result) {\n        order = result.value\n        inventory_results = order[:items].map do |item|\n          InventoryService.check_availability(item[:product_id])\n        end\n\n        if inventory_results.all? { |r| r[:available] }\n          result.with_context(:inventory_check, inventory_results).continue(order)\n        else\n          result.halt.with_error(:inventory, \"Items out of stock\")\n        end\n      }, depends_on: [:validate_order]\n\n      step :calculate_shipping, -&gt;(result) {\n        order = result.value\n        shipping = ShippingService.calculate(\n          order[:shipping_address],\n          order[:items]\n        )\n        result.with_context(:shipping, shipping).continue(order)\n      }, depends_on: [:validate_order]\n\n      # Step 4: Calculate totals\n      step :calculate_totals, -&gt;(result) {\n        order = result.value\n        shipping = result.context[:shipping]\n\n        subtotal = order[:items].sum { |item| item[:price] * item[:quantity] }\n        tax = subtotal * 0.08\n        total = subtotal + tax + shipping[:cost]\n\n        result\n          .with_context(:subtotal, subtotal)\n          .with_context(:tax, tax)\n          .with_context(:total, total)\n          .continue(order)\n      }, depends_on: [:check_inventory, :calculate_shipping]\n\n      # Step 5: Process payment\n      step :process_payment, -&gt;(result) {\n        order = result.value\n        total = result.context[:total]\n\n        payment_result = PaymentService.process(\n          total,\n          order[:payment][:card_token]\n        )\n\n        if payment_result[:status] == :success\n          result.with_context(:payment, payment_result).continue(order)\n        else\n          result.halt.with_error(:payment, payment_result[:reason])\n        end\n      }, depends_on: [:calculate_totals]\n\n      # Step 6: Reserve inventory\n      step :reserve_inventory, -&gt;(result) {\n        order = result.value\n        reservation = InventoryService.reserve(order[:items])\n        result.with_context(:reservation, reservation).continue(order)\n      }, depends_on: [:process_payment]\n\n      # Step 7: Create shipment\n      step :create_shipment, -&gt;(result) {\n        order = result.value\n        shipment = ShippingService.create_shipment(\n          order[:order_id],\n          order[:shipping_address]\n        )\n        result.with_context(:shipment, shipment).continue(order)\n      }, depends_on: [:reserve_inventory]\n\n      # Steps 8-9: Parallel notifications\n      step :send_email, -&gt;(result) {\n        order = result.value\n        NotificationService.send_email(\n          order[:customer][:email],\n          \"Order Confirmed\",\n          order_confirmation_body(order, result.context)\n        )\n        result.continue(order)\n      }, depends_on: [:create_shipment]\n\n      step :send_sms, -&gt;(result) {\n        order = result.value\n        if order[:customer][:phone]\n          NotificationService.send_sms(\n            order[:customer][:phone],\n            \"Order confirmed! Tracking: #{result.context[:shipment][:tracking]}\"\n          )\n        end\n        result.continue(order)\n      }, depends_on: [:create_shipment]\n\n      # Step 10: Finalize\n      step :finalize_order, -&gt;(result) {\n        order = result.value\n        final_order = {\n          order_id: order[:order_id],\n          status: :confirmed,\n          total: result.context[:total],\n          payment_transaction: result.context[:payment][:transaction_id],\n          tracking_number: result.context[:shipment][:tracking_number]\n        }\n        result.continue(final_order)\n      }, depends_on: [:send_email, :send_sms]\n    end\n  end\nend\n\n# Usage\nresult = OrderProcessor.build.call_parallel(\n  SimpleFlow::Result.new(order_data)\n)\n\nif result.continue?\n  puts \"Order #{result.value[:order_id]} processed successfully\"\nelse\n  puts \"Order failed: #{result.errors}\"\nend\n</code></pre>"},{"location":"guides/complex-workflows/#etl-data-pipeline","title":"ETL Data Pipeline","text":"<p>Extract, Transform, Load pipeline with validation and error handling:</p> <pre><code>class ETLPipeline\n  def self.build\n    SimpleFlow::Pipeline.new do\n      # Extract phase - parallel loading\n      step :extract_users, -&gt;(result) {\n        users = DataSource.fetch_users_csv\n        result.with_context(:raw_users, users).continue(result.value)\n      }, depends_on: []\n\n      step :extract_orders, -&gt;(result) {\n        orders = DataSource.fetch_orders_json\n        result.with_context(:raw_orders, orders).continue(result.value)\n      }, depends_on: []\n\n      step :extract_products, -&gt;(result) {\n        products = DataSource.fetch_products_api\n        result.with_context(:raw_products, products).continue(result.value)\n      }, depends_on: []\n\n      # Transform phase - parallel transformations\n      step :transform_users, -&gt;(result) {\n        users = result.context[:raw_users].map do |user|\n          {\n            id: user[:id],\n            name: user[:name].downcase.split.map(&amp;:capitalize).join(' '),\n            email: user[:email].downcase,\n            signup_year: user[:signup_date].split('-').first.to_i\n          }\n        end\n        result.with_context(:users, users).continue(result.value)\n      }, depends_on: [:extract_users]\n\n      step :transform_orders, -&gt;(result) {\n        orders = result.context[:raw_orders]\n          .reject { |o| o[:status] == \"cancelled\" }\n          .map do |order|\n            {\n              id: order[:order_id],\n              user_id: order[:user_id],\n              amount: order[:amount],\n              tax: (order[:amount] * 0.08).round(2),\n              total: (order[:amount] * 1.08).round(2)\n            }\n          end\n        result.with_context(:orders, orders).continue(result.value)\n      }, depends_on: [:extract_orders]\n\n      step :transform_products, -&gt;(result) {\n        products = result.context[:raw_products].map do |product|\n          {\n            id: product[:product_id],\n            name: product[:name],\n            category: product[:category].to_sym\n          }\n        end\n        result.with_context(:products, products).continue(result.value)\n      }, depends_on: [:extract_products]\n\n      # Aggregate phase\n      step :aggregate_stats, -&gt;(result) {\n        users = result.context[:users]\n        orders = result.context[:orders]\n\n        stats = users.map do |user|\n          user_orders = orders.select { |o| o[:user_id] == user[:id] }\n          {\n            user_id: user[:id],\n            name: user[:name],\n            total_orders: user_orders.size,\n            total_spent: user_orders.sum { |o| o[:total] },\n            avg_order: user_orders.empty? ? 0 : user_orders.sum { |o| o[:total] } / user_orders.size\n          }\n        end\n\n        result.with_context(:user_stats, stats).continue(result.value)\n      }, depends_on: [:transform_users, :transform_orders]\n\n      # Validation phase\n      step :validate_data, -&gt;(result) {\n        users = result.context[:users]\n        orders = result.context[:orders]\n\n        issues = []\n\n        # Check for orphaned orders\n        user_ids = users.map { |u| u[:id] }\n        orphaned = orders.reject { |o| user_ids.include?(o[:user_id]) }\n        issues &lt;&lt; \"#{orphaned.size} orphaned orders\" if orphaned.any?\n\n        result.with_context(:validation_warnings, issues).continue(result.value)\n      }, depends_on: [:aggregate_stats]\n\n      # Load phase\n      step :prepare_output, -&gt;(result) {\n        output = {\n          metadata: {\n            processed_at: Time.now,\n            warnings: result.context[:validation_warnings]\n          },\n          analytics: {\n            user_stats: result.context[:user_stats],\n            summary: {\n              total_users: result.context[:users].size,\n              total_orders: result.context[:orders].size,\n              total_revenue: result.context[:orders].sum { |o| o[:total] }\n            }\n          }\n        }\n        result.continue(output)\n      }, depends_on: [:validate_data]\n    end\n  end\nend\n</code></pre>"},{"location":"guides/complex-workflows/#multi-service-integration","title":"Multi-Service Integration","text":"<p>Orchestrating multiple external services:</p> <pre><code>class UserOnboarding\n  def self.build\n    SimpleFlow::Pipeline.new do\n      # Validate user data\n      step :validate_user, -&gt;(result) {\n        user_data = result.value\n        validator = UserValidator.new(user_data)\n\n        if validator.valid?\n          result.continue(user_data)\n        else\n          result.halt.with_error(:validation, validator.errors.join(\", \"))\n        end\n      }, depends_on: []\n\n      # Parallel service calls\n      step :create_auth_account, -&gt;(result) {\n        user = result.value\n        auth_account = AuthService.create_account(\n          email: user[:email],\n          password: user[:password]\n        )\n        result.with_context(:auth_id, auth_account[:id]).continue(user)\n      }, depends_on: [:validate_user]\n\n      step :create_profile, -&gt;(result) {\n        user = result.value\n        profile = ProfileService.create(\n          name: user[:name],\n          bio: user[:bio]\n        )\n        result.with_context(:profile_id, profile[:id]).continue(user)\n      }, depends_on: [:validate_user]\n\n      step :setup_preferences, -&gt;(result) {\n        user = result.value\n        prefs = PreferenceService.initialize_defaults(user[:preferences] || {})\n        result.with_context(:preferences_id, prefs[:id]).continue(user)\n      }, depends_on: [:validate_user]\n\n      # Link accounts\n      step :link_accounts, -&gt;(result) {\n        user_record = User.create!(\n          email: result.value[:email],\n          auth_id: result.context[:auth_id],\n          profile_id: result.context[:profile_id],\n          preferences_id: result.context[:preferences_id]\n        )\n        result.with_context(:user, user_record).continue(user_record)\n      }, depends_on: [:create_auth_account, :create_profile, :setup_preferences]\n\n      # Parallel post-creation tasks\n      step :send_welcome_email, -&gt;(result) {\n        user = result.context[:user]\n        EmailService.send_welcome(user.email)\n        result.continue(result.value)\n      }, depends_on: [:link_accounts]\n\n      step :trigger_analytics, -&gt;(result) {\n        user = result.context[:user]\n        AnalyticsService.track_signup(user)\n        result.continue(result.value)\n      }, depends_on: [:link_accounts]\n\n      step :create_trial_subscription, -&gt;(result) {\n        user = result.context[:user]\n        subscription = BillingService.create_trial(user)\n        result.with_context(:subscription, subscription).continue(result.value)\n      }, depends_on: [:link_accounts]\n\n      # Finalize\n      step :finalize, -&gt;(result) {\n        {\n          user_id: result.context[:user].id,\n          subscription_id: result.context[:subscription][:id],\n          onboarded_at: Time.now\n        }\n      }, depends_on: [:send_welcome_email, :trigger_analytics, :create_trial_subscription]\n    end\n  end\nend\n</code></pre>"},{"location":"guides/complex-workflows/#error-recovery-workflow","title":"Error Recovery Workflow","text":"<p>Advanced error handling with fallbacks and retries:</p> <pre><code>class ResilientDataFetcher\n  def self.build\n    SimpleFlow::Pipeline.new do\n      # Try primary data source\n      step :fetch_primary, -&gt;(result) {\n        begin\n          data = PrimaryAPI.fetch(result.value)\n          result.with_context(:source, :primary).continue(data)\n        rescue PrimaryAPI::Error =&gt; e\n          result\n            .with_context(:primary_error, e.message)\n            .continue(result.value)\n        end\n      }, depends_on: []\n\n      # Try secondary if primary failed\n      step :fetch_secondary, -&gt;(result) {\n        # Skip if primary succeeded\n        if result.context[:source] == :primary\n          return result.continue(result.value)\n        end\n\n        begin\n          data = SecondaryAPI.fetch(result.value)\n          result.with_context(:source, :secondary).continue(data)\n        rescue SecondaryAPI::Error =&gt; e\n          result\n            .with_context(:secondary_error, e.message)\n            .continue(result.value)\n        end\n      }, depends_on: [:fetch_primary]\n\n      # Fallback to cache\n      step :fetch_cache, -&gt;(result) {\n        # Skip if we have data\n        if result.context[:source]\n          return result.continue(result.value)\n        end\n\n        cached = CacheService.get(result.value)\n        if cached\n          result.with_context(:source, :cache).continue(cached)\n        else\n          result.halt.with_error(\n            :data_unavailable,\n            \"All data sources failed: #{[\n              result.context[:primary_error],\n              result.context[:secondary_error]\n            ].compact.join(', ')}\"\n          )\n        end\n      }, depends_on: [:fetch_secondary]\n\n      # Update cache if we fetched from API\n      step :update_cache, -&gt;(result) {\n        if [:primary, :secondary].include?(result.context[:source])\n          CacheService.set(result.value, result.value)\n        end\n        result.continue(result.value)\n      }, depends_on: [:fetch_cache]\n    end\n  end\nend\n</code></pre>"},{"location":"guides/complex-workflows/#for-complete-examples-see","title":"For complete examples, see:","text":"<ul> <li><code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/examples/06_real_world_ecommerce.rb</code> - Full e-commerce workflow</li> <li><code>/Users/dewayne/sandbox/git_repos/madbomber/simple_flow/examples/07_real_world_etl.rb</code> - Complete ETL pipeline</li> </ul>"},{"location":"guides/complex-workflows/#related-documentation","title":"Related Documentation","text":"<ul> <li>Error Handling - Error handling strategies</li> <li>Validation Patterns - Data validation</li> <li>Data Fetching - Fetching external data</li> <li>Parallel Steps - Concurrent execution</li> </ul>"},{"location":"guides/data-fetching/","title":"Data Fetching Guide","text":"<p>This guide demonstrates how to fetch data from various sources using SimpleFlow, including APIs, databases, file systems, and external services.</p>"},{"location":"guides/data-fetching/#api-data-fetching","title":"API Data Fetching","text":""},{"location":"guides/data-fetching/#basic-api-call","title":"Basic API Call","text":"<pre><code>step :fetch_from_api, -&gt;(result) {\n  begin\n    response = HTTP.get(\"https://api.example.com/users/#{result.value}\")\n    data = JSON.parse(response.body)\n    result.with_context(:user_data, data).continue(result.value)\n  rescue HTTP::Error =&gt; e\n    result.halt.with_error(:api, \"API request failed: #{e.message}\")\n  rescue JSON::ParserError =&gt; e\n    result.halt.with_error(:parse, \"Invalid JSON: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/data-fetching/#parallel-api-calls","title":"Parallel API Calls","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_weather, -&gt;(result) {\n    location = result.value[:location]\n    weather = HTTP.get(\"https://api.weather.com/current?location=#{location}\").parse\n    result.with_context(:weather, weather).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_news, -&gt;(result) {\n    topic = result.value[:topic]\n    news = HTTP.get(\"https://api.news.com/articles?topic=#{topic}\").parse\n    result.with_context(:news, news).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_stocks, -&gt;(result) {\n    symbols = result.value[:symbols]\n    stocks = HTTP.get(\"https://api.stocks.com/quotes?symbols=#{symbols}\").parse\n    result.with_context(:stocks, stocks).continue(result.value)\n  }, depends_on: []\n\n  step :combine_results, -&gt;(result) {\n    combined = {\n      weather: result.context[:weather],\n      news: result.context[:news],\n      stocks: result.context[:stocks]\n    }\n    result.continue(combined)\n  }, depends_on: [:fetch_weather, :fetch_news, :fetch_stocks]\nend\n\n# All API calls execute in parallel\nresult = pipeline.call_parallel(\n  SimpleFlow::Result.new({ location: \"NYC\", topic: \"tech\", symbols: \"AAPL,GOOGL\" })\n)\n</code></pre>"},{"location":"guides/data-fetching/#api-with-authentication","title":"API with Authentication","text":"<pre><code>class AuthenticatedAPI\n  def initialize(api_key)\n    @api_key = api_key\n  end\n\n  def call(result)\n    endpoint = result.value[:endpoint]\n\n    response = HTTP\n      .auth(\"Bearer #{@api_key}\")\n      .get(\"https://api.example.com/#{endpoint}\")\n\n    if response.status.success?\n      data = JSON.parse(response.body)\n      result.with_context(:api_response, data).continue(result.value)\n    else\n      result.halt.with_error(:api, \"Request failed with status #{response.status}\")\n    end\n  rescue StandardError =&gt; e\n    result.halt.with_error(:api, \"API error: #{e.message}\")\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step :fetch_data, AuthenticatedAPI.new(ENV['API_KEY']), depends_on: []\nend\n</code></pre>"},{"location":"guides/data-fetching/#rate-limited-api-calls","title":"Rate-Limited API Calls","text":"<pre><code>class RateLimitedFetcher\n  def initialize(max_requests_per_second: 10)\n    @max_requests = max_requests_per_second\n    @request_times = []\n  end\n\n  def call(result)\n    wait_if_rate_limited\n\n    begin\n      @request_times &lt;&lt; Time.now\n      response = HTTP.get(result.value[:url])\n      data = response.parse\n\n      result.with_context(:data, data).continue(result.value)\n    rescue HTTP::Error =&gt; e\n      result.halt.with_error(:http, e.message)\n    end\n  end\n\n  private\n\n  def wait_if_rate_limited\n    # Remove old requests outside the time window\n    one_second_ago = Time.now - 1\n    @request_times.reject! { |time| time &lt; one_second_ago }\n\n    # Wait if we've hit the limit\n    if @request_times.size &gt;= @max_requests\n      sleep(0.1)\n      wait_if_rate_limited\n    end\n  end\nend\n</code></pre>"},{"location":"guides/data-fetching/#database-queries","title":"Database Queries","text":""},{"location":"guides/data-fetching/#basic-database-query","title":"Basic Database Query","text":"<pre><code>step :fetch_users, -&gt;(result) {\n  users = DB[:users]\n    .where(active: true)\n    .where { created_at &gt; Date.today - 30 }\n    .all\n\n  result.with_context(:users, users).continue(result.value)\n}\n</code></pre>"},{"location":"guides/data-fetching/#parallel-database-queries","title":"Parallel Database Queries","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_users, -&gt;(result) {\n    users = DB[:users].where(active: true).all\n    result.with_context(:users, users).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_orders, -&gt;(result) {\n    orders = DB[:orders].where(status: 'completed').all\n    result.with_context(:orders, orders).continue(result.value)\n  }, depends_on: []\n\n  step :fetch_products, -&gt;(result) {\n    products = DB[:products].where(in_stock: true).all\n    result.with_context(:products, products).continue(result.value)\n  }, depends_on: []\n\n  step :aggregate, -&gt;(result) {\n    stats = {\n      total_users: result.context[:users].size,\n      total_orders: result.context[:orders].size,\n      total_products: result.context[:products].size\n    }\n    result.continue(stats)\n  }, depends_on: [:fetch_users, :fetch_orders, :fetch_products]\nend\n\n# Ensure your database connection pool supports concurrent queries\nDB = Sequel.connect(\n  'postgres://localhost/mydb',\n  max_connections: 10  # Allow concurrent connections\n)\n\nresult = pipeline.call_parallel(SimpleFlow::Result.new(nil))\n</code></pre>"},{"location":"guides/data-fetching/#complex-joins-and-aggregations","title":"Complex Joins and Aggregations","text":"<pre><code>step :fetch_user_analytics, -&gt;(result) {\n  user_id = result.value\n\n  analytics = DB[:users]\n    .select(:users__id, :users__name)\n    .select_append { count(:orders__id).as(:order_count) }\n    .select_append { sum(:orders__total).as(:total_spent) }\n    .left_join(:orders, user_id: :id)\n    .where(users__id: user_id)\n    .group(:users__id, :users__name)\n    .first\n\n  result.with_context(:analytics, analytics).continue(result.value)\n}\n</code></pre>"},{"location":"guides/data-fetching/#file-system-operations","title":"File System Operations","text":""},{"location":"guides/data-fetching/#reading-files","title":"Reading Files","text":"<pre><code>step :read_config, -&gt;(result) {\n  begin\n    config_path = result.value[:config_path]\n    content = File.read(config_path)\n    config = JSON.parse(content)\n\n    result.with_context(:config, config).continue(result.value)\n  rescue Errno::ENOENT\n    result.halt.with_error(:file, \"Config file not found: #{config_path}\")\n  rescue JSON::ParserError =&gt; e\n    result.halt.with_error(:parse, \"Invalid JSON in config: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/data-fetching/#reading-multiple-files-in-parallel","title":"Reading Multiple Files in Parallel","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :read_users_csv, -&gt;(result) {\n    users = CSV.read('data/users.csv', headers: true).map(&amp;:to_h)\n    result.with_context(:users, users).continue(result.value)\n  }, depends_on: []\n\n  step :read_products_json, -&gt;(result) {\n    products = JSON.parse(File.read('data/products.json'))\n    result.with_context(:products, products).continue(result.value)\n  }, depends_on: []\n\n  step :read_config_yaml, -&gt;(result) {\n    config = YAML.load_file('config/settings.yml')\n    result.with_context(:config, config).continue(result.value)\n  }, depends_on: []\n\n  step :combine_data, -&gt;(result) {\n    combined = {\n      users: result.context[:users],\n      products: result.context[:products],\n      config: result.context[:config]\n    }\n    result.continue(combined)\n  }, depends_on: [:read_users_csv, :read_products_json, :read_config_yaml]\nend\n</code></pre>"},{"location":"guides/data-fetching/#processing-large-files","title":"Processing Large Files","text":"<pre><code>step :process_large_file, -&gt;(result) {\n  file_path = result.value\n  processed_count = 0\n\n  File.foreach(file_path).each_slice(1000) do |batch|\n    # Process in batches\n    batch.each do |line|\n      process_line(line)\n      processed_count += 1\n    end\n  end\n\n  result.with_context(:lines_processed, processed_count).continue(result.value)\n}\n</code></pre>"},{"location":"guides/data-fetching/#caching-strategies","title":"Caching Strategies","text":""},{"location":"guides/data-fetching/#simple-cache-with-fallback","title":"Simple Cache with Fallback","text":"<pre><code>step :fetch_with_cache, -&gt;(result) {\n  cache_key = \"user_#{result.value}\"\n\n  # Try cache first\n  cached = REDIS.get(cache_key)\n  if cached\n    data = JSON.parse(cached)\n    return result.with_context(:source, :cache).continue(data)\n  end\n\n  # Cache miss - fetch from API\n  begin\n    response = HTTP.get(\"https://api.example.com/users/#{result.value}\")\n    data = response.parse\n\n    # Store in cache for 1 hour\n    REDIS.setex(cache_key, 3600, data.to_json)\n\n    result.with_context(:source, :api).continue(data)\n  rescue HTTP::Error =&gt; e\n    result.halt.with_error(:fetch, \"Failed to fetch data: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/data-fetching/#multi-level-caching","title":"Multi-Level Caching","text":"<pre><code>class MultiLevelCache\n  def self.call(result)\n    key = result.value[:cache_key]\n\n    # Level 1: Memory cache\n    if data = MEMORY_CACHE[key]\n      return result.with_context(:cache_level, :memory).continue(data)\n    end\n\n    # Level 2: Redis cache\n    if cached = REDIS.get(key)\n      data = JSON.parse(cached)\n      MEMORY_CACHE[key] = data\n      return result.with_context(:cache_level, :redis).continue(data)\n    end\n\n    # Level 3: Database\n    if record = DB[:cache].where(key: key).first\n      data = JSON.parse(record[:value])\n      REDIS.setex(key, 3600, data.to_json)\n      MEMORY_CACHE[key] = data\n      return result.with_context(:cache_level, :database).continue(data)\n    end\n\n    # No cache hit - need to fetch\n    result.with_context(:cache_level, :none).continue(nil)\n  end\nend\n</code></pre>"},{"location":"guides/data-fetching/#batch-processing","title":"Batch Processing","text":""},{"location":"guides/data-fetching/#fetching-data-in-batches","title":"Fetching Data in Batches","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :fetch_batch, -&gt;(result) {\n    batch_ids = result.value\n    records = DB[:records].where(id: batch_ids).all\n\n    result.with_context(:records, records).continue(result.value)\n  }\n\n  step :process_records, -&gt;(result) {\n    records = result.context[:records]\n    processed = records.map { |r| transform_record(r) }\n\n    result.continue(processed)\n  }\nend\n\n# Process in batches\nall_ids = (1..10000).to_a\nall_ids.each_slice(100) do |batch|\n  result = pipeline.call(SimpleFlow::Result.new(batch))\n  save_processed_batch(result.value)\nend\n</code></pre>"},{"location":"guides/data-fetching/#real-world-etl-example","title":"Real-World ETL Example","text":"<pre><code>class ETLPipeline\n  def self.build\n    SimpleFlow::Pipeline.new do\n      # Extract phase - parallel data loading\n      step :extract_users, -&gt;(result) {\n        users = CSV.read('data/users.csv', headers: true).map(&amp;:to_h)\n        result.with_context(:raw_users, users).continue(result.value)\n      }, depends_on: []\n\n      step :extract_orders, -&gt;(result) {\n        orders = JSON.parse(File.read('data/orders.json'))\n        result.with_context(:raw_orders, orders).continue(result.value)\n      }, depends_on: []\n\n      step :extract_products, -&gt;(result) {\n        products = DB[:products].all\n        result.with_context(:raw_products, products).continue(result.value)\n      }, depends_on: []\n\n      # Transform phase - parallel transformations\n      step :transform_users, -&gt;(result) {\n        users = result.context[:raw_users].map do |user|\n          {\n            id: user['id'].to_i,\n            name: user['name'].strip.downcase,\n            email: user['email'].downcase,\n            created_at: Date.parse(user['signup_date'])\n          }\n        end\n        result.with_context(:users, users).continue(result.value)\n      }, depends_on: [:extract_users]\n\n      step :transform_orders, -&gt;(result) {\n        orders = result.context[:raw_orders]\n          .reject { |o| o['status'] == 'cancelled' }\n          .map do |order|\n            {\n              id: order['order_id'],\n              user_id: order['user_id'],\n              total: order['amount'].to_f,\n              items: order['items'].size\n            }\n          end\n        result.with_context(:orders, orders).continue(result.value)\n      }, depends_on: [:extract_orders]\n\n      # Load phase - aggregate and save\n      step :aggregate_stats, -&gt;(result) {\n        users = result.context[:users]\n        orders = result.context[:orders]\n\n        stats = users.map do |user|\n          user_orders = orders.select { |o| o[:user_id] == user[:id] }\n          {\n            user_id: user[:id],\n            total_orders: user_orders.size,\n            total_spent: user_orders.sum { |o| o[:total] },\n            avg_order: user_orders.empty? ? 0 : user_orders.sum { |o| o[:total] } / user_orders.size\n          }\n        end\n\n        result.continue(stats)\n      }, depends_on: [:transform_users, :transform_orders]\n\n      step :save_results, -&gt;(result) {\n        DB[:user_stats].multi_insert(result.value)\n        result.continue(\"Saved #{result.value.size} records\")\n      }, depends_on: [:aggregate_stats]\n    end\n  end\nend\n\n# Execute ETL pipeline\nresult = ETLPipeline.build.call_parallel(SimpleFlow::Result.new(nil))\nputs result.value  # \"Saved 150 records\"\n</code></pre>"},{"location":"guides/data-fetching/#error-handling-for-data-fetching","title":"Error Handling for Data Fetching","text":"<pre><code>step :fetch_with_retries, -&gt;(result) {\n  max_retries = 3\n  attempt = 0\n\n  begin\n    attempt += 1\n    response = HTTP.timeout(10).get(result.value[:url])\n    data = response.parse\n\n    result\n      .with_context(:attempts, attempt)\n      .with_context(:data, data)\n      .continue(result.value)\n  rescue HTTP::TimeoutError\n    if attempt &lt; max_retries\n      sleep(attempt ** 2)  # Exponential backoff\n      retry\n    else\n      result.halt.with_error(:timeout, \"Request timed out after #{max_retries} attempts\")\n    end\n  rescue HTTP::Error =&gt; e\n    result.halt.with_error(:http, \"HTTP error: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/data-fetching/#related-documentation","title":"Related Documentation","text":"<ul> <li>Error Handling - Handling errors during data fetching</li> <li>File Processing - Advanced file processing techniques</li> <li>Complex Workflows - Building complete data pipelines</li> <li>Performance Guide - Optimizing data fetching</li> </ul>"},{"location":"guides/error-handling/","title":"Error Handling Guide","text":"<p>SimpleFlow provides flexible mechanisms for handling errors, validating data, and controlling pipeline flow. This guide covers comprehensive error handling strategies.</p>"},{"location":"guides/error-handling/#core-concepts","title":"Core Concepts","text":""},{"location":"guides/error-handling/#the-result-object","title":"The Result Object","text":"<p>Every step receives and returns a <code>Result</code> object with three key components:</p> <ul> <li>value: The data being processed</li> <li>context: Metadata and contextual information</li> <li>errors: Accumulated error messages organized by category</li> </ul>"},{"location":"guides/error-handling/#flow-control","title":"Flow Control","text":"<p>Steps control execution flow using two methods:</p> <ul> <li><code>continue(new_value)</code>: Proceed to next step with updated value</li> <li><code>halt(new_value = nil)</code>: Stop pipeline execution</li> </ul>"},{"location":"guides/error-handling/#basic-error-handling","title":"Basic Error Handling","text":""},{"location":"guides/error-handling/#halting-on-validation-failure","title":"Halting on Validation Failure","text":"<p>The simplest error handling pattern is to halt immediately when validation fails:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    age = result.value\n\n    if age &lt; 18\n      result.halt.with_error(:validation, \"Must be 18 or older\")\n    else\n      result.continue(age)\n    end\n  }\n\n  step -&gt;(result) {\n    # This only runs if age &gt;= 18\n    result.continue(\"Approved for age #{result.value}\")\n  }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(15))\nresult.continue?  # =&gt; false\nresult.errors     # =&gt; {:validation =&gt; [\"Must be 18 or older\"]}\n</code></pre>"},{"location":"guides/error-handling/#checking-continue-status","title":"Checking Continue Status","text":"<p>Always check <code>continue?</code> to determine if pipeline completed successfully:</p> <pre><code>result = pipeline.call(initial_data)\n\nif result.continue?\n  puts \"Success: #{result.value}\"\nelse\n  puts \"Failed with errors: #{result.errors}\"\nend\n</code></pre>"},{"location":"guides/error-handling/#error-accumulation","title":"Error Accumulation","text":""},{"location":"guides/error-handling/#collecting-multiple-errors","title":"Collecting Multiple Errors","text":"<p>Instead of halting at the first error, collect all validation errors:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) {\n    password = result.value\n\n    result = if password.length &lt; 8\n      result.with_error(:password, \"Must be at least 8 characters\")\n    else\n      result\n    end\n\n    result = unless password =~ /[A-Z]/\n      result.with_error(:password, \"Must contain uppercase letters\")\n    else\n      result\n    end\n\n    result = unless password =~ /[0-9]/\n      result.with_error(:password, \"Must contain numbers\")\n    else\n      result\n    end\n\n    result.continue(password)\n  }\n\n  step -&gt;(result) {\n    # Check if any errors were accumulated\n    if result.errors.any?\n      result.halt.with_error(:validation, \"Password requirements not met\")\n    else\n      result.continue(result.value)\n    end\n  }\n\n  step -&gt;(result) {\n    # Only executes if no validation errors\n    result.continue(\"Password accepted\")\n  }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(\"weak\"))\nresult.errors\n# =&gt; {\n#      :password =&gt; [\n#        \"Must be at least 8 characters\",\n#        \"Must contain uppercase letters\",\n#        \"Must contain numbers\"\n#      ],\n#      :validation =&gt; [\"Password requirements not met\"]\n#    }\n</code></pre>"},{"location":"guides/error-handling/#parallel-validation","title":"Parallel Validation","text":"<p>Use parallel execution to run multiple validations concurrently:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  # Validate multiple fields in parallel\n  step :validate_email, -&gt;(result) {\n    unless valid_email?(result.value[:email])\n      result.with_error(:email, \"Invalid email format\")\n    end\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :validate_phone, -&gt;(result) {\n    unless valid_phone?(result.value[:phone])\n      result.with_error(:phone, \"Invalid phone format\")\n    end\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :validate_age, -&gt;(result) {\n    if result.value[:age] &lt; 18\n      result.with_error(:age, \"Must be 18 or older\")\n    end\n    result.continue(result.value)\n  }, depends_on: []\n\n  # Check all validation results\n  step :verify_validations, -&gt;(result) {\n    if result.errors.any?\n      result.halt(result.value)\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: [:validate_email, :validate_phone, :validate_age]\n\n  # Only runs if all validations pass\n  step :create_account, -&gt;(result) {\n    result.continue(\"Account created successfully\")\n  }, depends_on: [:verify_validations]\nend\n</code></pre>"},{"location":"guides/error-handling/#error-categories","title":"Error Categories","text":""},{"location":"guides/error-handling/#organizing-errors-by-type","title":"Organizing Errors by Type","text":"<p>Use symbols to categorize errors for better organization:</p> <pre><code>step :process_order, -&gt;(result) {\n  order = result.value\n\n  # Business logic errors\n  if order[:total] &gt; 10000\n    return result.halt.with_error(:business_rule, \"Order exceeds maximum amount\")\n  end\n\n  # Inventory errors\n  unless inventory_available?(order[:items])\n    return result.halt.with_error(:inventory, \"Items out of stock\")\n  end\n\n  # Payment errors\n  unless valid_payment?(order[:payment])\n    return result.halt.with_error(:payment, \"Payment method declined\")\n  end\n\n  result.continue(order)\n}\n\n# Access errors by category\nresult = pipeline.call(order_data)\nresult.errors[:business_rule]  # =&gt; [\"Order exceeds maximum amount\"]\nresult.errors[:inventory]      # =&gt; nil\nresult.errors[:payment]        # =&gt; nil\n</code></pre>"},{"location":"guides/error-handling/#multiple-errors-per-category","title":"Multiple Errors Per Category","text":"<p>The <code>with_error</code> method appends to existing errors in a category:</p> <pre><code>step :validate_fields, -&gt;(result) {\n  data = result.value\n  result_obj = result\n\n  if data[:name].nil?\n    result_obj = result_obj.with_error(:required, \"Name is required\")\n  end\n\n  if data[:email].nil?\n    result_obj = result_obj.with_error(:required, \"Email is required\")\n  end\n\n  if data[:phone].nil?\n    result_obj = result_obj.with_error(:required, \"Phone is required\")\n  end\n\n  result_obj.continue(data)\n}\n\n# result.errors[:required] =&gt; [\"Name is required\", \"Email is required\", \"Phone is required\"]\n</code></pre>"},{"location":"guides/error-handling/#exception-handling","title":"Exception Handling","text":""},{"location":"guides/error-handling/#rescuing-exceptions","title":"Rescuing Exceptions","text":"<p>Wrap external calls in exception handlers:</p> <pre><code>step :fetch_from_api, -&gt;(result) {\n  begin\n    response = HTTP.get(\"https://api.example.com/data\")\n    data = JSON.parse(response.body)\n    result.with_context(:api_data, data).continue(result.value)\n  rescue HTTP::Error =&gt; e\n    result.halt.with_error(:network, \"API request failed: #{e.message}\")\n  rescue JSON::ParserError =&gt; e\n    result.halt.with_error(:parse, \"Invalid JSON response: #{e.message}\")\n  rescue StandardError =&gt; e\n    result.halt.with_error(:unknown, \"Unexpected error: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/error-handling/#retry-logic-with-middleware","title":"Retry Logic with Middleware","text":"<p>Implement retry logic using custom middleware:</p> <pre><code>class RetryMiddleware\n  def initialize(callable, max_retries: 3, retry_on: [StandardError])\n    @callable = callable\n    @max_retries = max_retries\n    @retry_on = Array(retry_on)\n  end\n\n  def call(result)\n    attempts = 0\n\n    begin\n      attempts += 1\n      @callable.call(result)\n    rescue *@retry_on =&gt; e\n      if attempts &lt; @max_retries\n        sleep(attempts ** 2)  # Exponential backoff\n        retry\n      else\n        result.halt.with_error(\n          :retry_exhausted,\n          \"Failed after #{@max_retries} attempts: #{e.message}\"\n        )\n      end\n    end\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware RetryMiddleware, max_retries: 3, retry_on: [Net::HTTPError, Timeout::Error]\n\n  step -&gt;(result) {\n    # This step will be retried up to 3 times on network errors\n    data = fetch_from_unreliable_api(result.value)\n    result.continue(data)\n  }\nend\n</code></pre>"},{"location":"guides/error-handling/#conditional-processing","title":"Conditional Processing","text":""},{"location":"guides/error-handling/#early-exit-on-errors","title":"Early Exit on Errors","text":"<p>Check for errors and exit early if found:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :load_data, -&gt;(result) {\n    begin\n      data = load_file(result.value)\n      result.continue(data)\n    rescue Errno::ENOENT\n      result.halt.with_error(:file, \"File not found\")\n    end\n  }\n\n  step :validate_data, -&gt;(result) {\n    # Only runs if load_data succeeded\n    if invalid?(result.value)\n      result.halt.with_error(:validation, \"Invalid data format\")\n    else\n      result.continue(result.value)\n    end\n  }\n\n  step :process_data, -&gt;(result) {\n    # Only runs if both previous steps succeeded\n    processed = transform(result.value)\n    result.continue(processed)\n  }\nend\n</code></pre>"},{"location":"guides/error-handling/#conditional-flow-based-on-context","title":"Conditional Flow Based on Context","text":"<p>Use context to make decisions about flow:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :check_user_role, -&gt;(result) {\n    user = result.value\n    result.with_context(:role, user[:role]).continue(user)\n  }\n\n  step :authorize_action, -&gt;(result) {\n    case result.context[:role]\n    when :admin\n      result.with_context(:authorized, true).continue(result.value)\n    when :user\n      if can_access?(result.value)\n        result.with_context(:authorized, true).continue(result.value)\n      else\n        result.halt.with_error(:auth, \"Insufficient permissions\")\n      end\n    else\n      result.halt.with_error(:auth, \"Unknown role\")\n    end\n  }\n\n  step :perform_action, -&gt;(result) {\n    # Only executes if authorized\n    result.continue(\"Action completed\")\n  }\nend\n</code></pre>"},{"location":"guides/error-handling/#error-recovery","title":"Error Recovery","text":""},{"location":"guides/error-handling/#fallback-values","title":"Fallback Values","text":"<p>Provide fallback values when operations fail:</p> <pre><code>step :fetch_with_fallback, -&gt;(result) {\n  begin\n    data = fetch_from_primary_api(result.value)\n    result.with_context(:source, :primary).continue(data)\n  rescue API::Error\n    # Try secondary source\n    begin\n      data = fetch_from_secondary_api(result.value)\n      result.with_context(:source, :secondary).continue(data)\n    rescue API::Error\n      # Use cached data as last resort\n      cached_data = fetch_from_cache(result.value)\n      if cached_data\n        result.with_context(:source, :cache).continue(cached_data)\n      else\n        result.halt.with_error(:data, \"All data sources unavailable\")\n      end\n    end\n  end\n}\n</code></pre>"},{"location":"guides/error-handling/#partial-success-handling","title":"Partial Success Handling","text":"<p>Continue processing even if some operations fail:</p> <pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :batch_process, -&gt;(result) {\n    items = result.value\n    successful = []\n    failed = []\n\n    items.each do |item|\n      begin\n        processed = process_item(item)\n        successful &lt;&lt; processed\n      rescue ProcessingError =&gt; e\n        failed &lt;&lt; { item: item, error: e.message }\n      end\n    end\n\n    result_obj = result.continue(successful)\n\n    if failed.any?\n      result_obj = result_obj.with_context(:failed_items, failed)\n      result_obj = result_obj.with_error(:partial_failure, \"#{failed.size} items failed to process\")\n    end\n\n    result_obj\n  }\n\n  step :handle_results, -&gt;(result) {\n    if result.context[:failed_items]\n      # Log failures but continue\n      log_failures(result.context[:failed_items])\n    end\n\n    result.continue(\"Processed #{result.value.size} items\")\n  }\nend\n</code></pre>"},{"location":"guides/error-handling/#debugging-halted-pipelines","title":"Debugging Halted Pipelines","text":""},{"location":"guides/error-handling/#using-steptracker","title":"Using StepTracker","text":"<p>SimpleFlow's <code>StepTracker</code> adds context about where execution halted:</p> <pre><code>require 'simple_flow/step_tracker'\n\nstep_a = SimpleFlow::StepTracker.new(-&gt;(result) {\n  result.continue(\"Step A done\")\n})\n\nstep_b = SimpleFlow::StepTracker.new(-&gt;(result) {\n  result.halt.with_error(:failure, \"Step B failed\")\n})\n\nstep_c = SimpleFlow::StepTracker.new(-&gt;(result) {\n  result.continue(\"Step C done\")\n})\n\npipeline = SimpleFlow::Pipeline.new do\n  step step_a\n  step step_b\n  step step_c\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(nil))\nresult.context[:halted_step]  # =&gt; The step_b lambda\n</code></pre>"},{"location":"guides/error-handling/#adding-debug-context","title":"Adding Debug Context","text":"<p>Add helpful debugging information to context:</p> <pre><code>step :debug_step, -&gt;(result) {\n  result\n    .with_context(:step_name, \"debug_step\")\n    .with_context(:timestamp, Time.now)\n    .with_context(:input_size, result.value.size)\n    .continue(result.value)\n}\n</code></pre>"},{"location":"guides/error-handling/#validation-patterns","title":"Validation Patterns","text":""},{"location":"guides/error-handling/#schema-validation","title":"Schema Validation","text":"<p>Validate data structure before processing:</p> <pre><code>step :validate_schema, -&gt;(result) {\n  data = result.value\n  required_fields = [:name, :email, :age]\n\n  missing = required_fields.reject { |field| data.key?(field) }\n\n  if missing.any?\n    result.halt.with_error(\n      :schema,\n      \"Missing required fields: #{missing.join(', ')}\"\n    )\n  else\n    result.continue(data)\n  end\n}\n</code></pre>"},{"location":"guides/error-handling/#type-validation","title":"Type Validation","text":"<p>Check data types:</p> <pre><code>step :validate_types, -&gt;(result) {\n  data = result.value\n  errors = []\n\n  unless data[:age].is_a?(Integer)\n    errors &lt;&lt; \"age must be an integer\"\n  end\n\n  unless data[:email].is_a?(String)\n    errors &lt;&lt; \"email must be a string\"\n  end\n\n  if errors.any?\n    result.halt.with_error(:type, errors.join(\", \"))\n  else\n    result.continue(data)\n  end\n}\n</code></pre>"},{"location":"guides/error-handling/#range-validation","title":"Range Validation","text":"<p>Validate numeric ranges:</p> <pre><code>step :validate_ranges, -&gt;(result) {\n  data = result.value\n\n  if data[:age] &lt; 0 || data[:age] &gt; 120\n    return result.halt.with_error(:range, \"Age must be between 0 and 120\")\n  end\n\n  if data[:quantity] &lt; 1\n    return result.halt.with_error(:range, \"Quantity must be at least 1\")\n  end\n\n  result.continue(data)\n}\n</code></pre>"},{"location":"guides/error-handling/#real-world-example","title":"Real-World Example","text":"<p>Complete error handling in an order processing pipeline:</p> <pre><code>order_pipeline = SimpleFlow::Pipeline.new do\n  # Validate order structure\n  step :validate_order, -&gt;(result) {\n    order = result.value\n    errors = []\n\n    errors &lt;&lt; \"Missing customer email\" unless order[:customer][:email]\n    errors &lt;&lt; \"No items in order\" if order[:items].empty?\n    errors &lt;&lt; \"Missing payment method\" unless order[:payment][:card_token]\n\n    if errors.any?\n      result.halt.with_error(:validation, errors.join(\", \"))\n    else\n      result.with_context(:validated_at, Time.now).continue(order)\n    end\n  }, depends_on: []\n\n  # Check inventory with error handling\n  step :check_inventory, -&gt;(result) {\n    begin\n      inventory_results = InventoryService.check_availability(result.value[:items])\n\n      if inventory_results.all? { |r| r[:available] }\n        result.with_context(:inventory_check, inventory_results).continue(result.value)\n      else\n        unavailable = inventory_results.reject { |r| r[:available] }\n        result.halt.with_error(\n          :inventory,\n          \"Items unavailable: #{unavailable.map { |i| i[:product_id] }.join(', ')}\"\n        )\n      end\n    rescue InventoryService::Error =&gt; e\n      result.halt.with_error(:service, \"Inventory service error: #{e.message}\")\n    end\n  }, depends_on: [:validate_order]\n\n  # Process payment with retries\n  step :process_payment, -&gt;(result) {\n    total = result.context[:total]\n\n    payment_result = PaymentService.process_payment(\n      total,\n      result.value[:payment][:card_token]\n    )\n\n    case payment_result[:status]\n    when :success\n      result.with_context(:payment, payment_result).continue(result.value)\n    when :declined\n      result.halt.with_error(:payment, \"Card declined: #{payment_result[:reason]}\")\n    when :insufficient_funds\n      result.halt.with_error(:payment, \"Insufficient funds\")\n    else\n      result.halt.with_error(:payment, \"Payment processing failed\")\n    end\n  }, depends_on: [:check_inventory]\nend\n\n# Execute and handle errors\nresult = order_pipeline.call_parallel(order_data)\n\nif result.continue?\n  puts \"Order processed successfully\"\n  send_confirmation_email(result.value)\nelse\n  puts \"Order failed:\"\n  result.errors.each do |category, messages|\n    puts \"  #{category}: #{messages.join(', ')}\"\n  end\n\n  # Handle specific error types\n  if result.errors[:payment]\n    log_payment_failure(result.value)\n  elsif result.errors[:inventory]\n    notify_inventory_team(result.value)\n  end\nend\n</code></pre>"},{"location":"guides/error-handling/#related-documentation","title":"Related Documentation","text":"<ul> <li>Validation Patterns - Common validation strategies</li> <li>Complex Workflows - Building sophisticated pipelines</li> <li>Result API - Complete Result class reference</li> <li>Pipeline API - Pipeline class reference</li> </ul>"},{"location":"guides/file-processing/","title":"File Processing Guide","text":"<p>This guide demonstrates how to process files efficiently using SimpleFlow, including reading, writing, transforming, and validating file content.</p>"},{"location":"guides/file-processing/#reading-files","title":"Reading Files","text":""},{"location":"guides/file-processing/#basic-file-reading","title":"Basic File Reading","text":"<pre><code>step :read_file, -&gt;(result) {\n  begin\n    filepath = result.value\n    content = File.read(filepath)\n    result.with_context(:content, content).continue(filepath)\n  rescue Errno::ENOENT\n    result.halt.with_error(:file, \"File not found: #{filepath}\")\n  rescue Errno::EACCES\n    result.halt.with_error(:file, \"Permission denied: #{filepath}\")\n  end\n}\n</code></pre>"},{"location":"guides/file-processing/#reading-json-files","title":"Reading JSON Files","text":"<pre><code>step :read_json, -&gt;(result) {\n  begin\n    content = File.read(result.value)\n    data = JSON.parse(content)\n    result.continue(data)\n  rescue JSON::ParserError =&gt; e\n    result.halt.with_error(:parse, \"Invalid JSON: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/file-processing/#reading-csv-files","title":"Reading CSV Files","text":"<pre><code>step :read_csv, -&gt;(result) {\n  begin\n    rows = CSV.read(result.value, headers: true)\n    data = rows.map(&amp;:to_h)\n    result.continue(data)\n  rescue CSV::MalformedCSVError =&gt; e\n    result.halt.with_error(:parse, \"Malformed CSV: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/file-processing/#reading-yaml-files","title":"Reading YAML Files","text":"<pre><code>step :read_yaml, -&gt;(result) {\n  begin\n    data = YAML.load_file(result.value)\n    result.continue(data)\n  rescue Psych::SyntaxError =&gt; e\n    result.halt.with_error(:parse, \"Invalid YAML: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/file-processing/#writing-files","title":"Writing Files","text":""},{"location":"guides/file-processing/#writing-text-files","title":"Writing Text Files","text":"<pre><code>step :write_file, -&gt;(result) {\n  begin\n    filepath = result.value[:path]\n    content = result.value[:content]\n\n    File.write(filepath, content)\n    result.with_context(:bytes_written, content.bytesize).continue(filepath)\n  rescue Errno::EACCES\n    result.halt.with_error(:file, \"Permission denied: #{filepath}\")\n  rescue Errno::ENOSPC\n    result.halt.with_error(:file, \"No space left on device\")\n  end\n}\n</code></pre>"},{"location":"guides/file-processing/#writing-json-files","title":"Writing JSON Files","text":"<pre><code>step :write_json, -&gt;(result) {\n  filepath = result.value[:path]\n  data = result.value[:data]\n\n  json_content = JSON.pretty_generate(data)\n  File.write(filepath, json_content)\n\n  result.with_context(:path, filepath).continue(data)\n}\n</code></pre>"},{"location":"guides/file-processing/#writing-csv-files","title":"Writing CSV Files","text":"<pre><code>step :write_csv, -&gt;(result) {\n  filepath = result.value[:path]\n  rows = result.value[:rows]\n\n  CSV.open(filepath, 'w', write_headers: true, headers: rows.first.keys) do |csv|\n    rows.each { |row| csv &lt;&lt; row.values }\n  end\n\n  result.with_context(:rows_written, rows.size).continue(filepath)\n}\n</code></pre>"},{"location":"guides/file-processing/#processing-large-files","title":"Processing Large Files","text":""},{"location":"guides/file-processing/#line-by-line-processing","title":"Line-by-Line Processing","text":"<pre><code>step :process_large_file, -&gt;(result) {\n  filepath = result.value\n  processed = 0\n\n  File.foreach(filepath) do |line|\n    process_line(line.strip)\n    processed += 1\n  end\n\n  result.with_context(:lines_processed, processed).continue(filepath)\n}\n</code></pre>"},{"location":"guides/file-processing/#batch-processing","title":"Batch Processing","text":"<pre><code>step :process_in_batches, -&gt;(result) {\n  filepath = result.value\n  batch_size = 1000\n  batches_processed = 0\n\n  File.foreach(filepath).each_slice(batch_size) do |batch|\n    # Process batch\n    transformed = batch.map { |line| transform(line) }\n    save_batch(transformed)\n    batches_processed += 1\n  end\n\n  result.with_context(:batches_processed, batches_processed).continue(filepath)\n}\n</code></pre>"},{"location":"guides/file-processing/#streaming-large-files","title":"Streaming Large Files","text":"<pre><code>step :stream_process, -&gt;(result) {\n  input_path = result.value[:input]\n  output_path = result.value[:output]\n\n  File.open(output_path, 'w') do |output|\n    File.foreach(input_path) do |line|\n      transformed = transform_line(line)\n      output.write(transformed)\n    end\n  end\n\n  result.continue(output_path)\n}\n</code></pre>"},{"location":"guides/file-processing/#multi-file-processing","title":"Multi-File Processing","text":""},{"location":"guides/file-processing/#processing-multiple-files-in-parallel","title":"Processing Multiple Files in Parallel","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :process_config, -&gt;(result) {\n    config = JSON.parse(File.read('config/app.json'))\n    result.with_context(:config, config).continue(result.value)\n  }, depends_on: []\n\n  step :process_users, -&gt;(result) {\n    users = CSV.read('data/users.csv', headers: true).map(&amp;:to_h)\n    result.with_context(:users, users).continue(result.value)\n  }, depends_on: []\n\n  step :process_logs, -&gt;(result) {\n    logs = File.readlines('logs/app.log').map(&amp;:strip)\n    result.with_context(:logs, logs).continue(result.value)\n  }, depends_on: []\n\n  step :combine_results, -&gt;(result) {\n    {\n      config: result.context[:config],\n      user_count: result.context[:users].size,\n      log_count: result.context[:logs].size\n    }\n  }, depends_on: [:process_config, :process_users, :process_logs]\nend\n\nresult = pipeline.call_parallel(SimpleFlow::Result.new(nil))\n</code></pre>"},{"location":"guides/file-processing/#directory-processing","title":"Directory Processing","text":"<pre><code>step :process_directory, -&gt;(result) {\n  dir_path = result.value\n  processed_files = []\n\n  Dir.glob(File.join(dir_path, '*.json')).each do |filepath|\n    data = JSON.parse(File.read(filepath))\n    transformed = transform_data(data)\n    processed_files &lt;&lt; { file: filepath, records: transformed.size }\n  end\n\n  result.with_context(:processed_files, processed_files).continue(dir_path)\n}\n</code></pre>"},{"location":"guides/file-processing/#data-transformation","title":"Data Transformation","text":""},{"location":"guides/file-processing/#csv-to-json-conversion","title":"CSV to JSON Conversion","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :read_csv, -&gt;(result) {\n    rows = CSV.read(result.value, headers: true)\n    result.continue(rows.map(&amp;:to_h))\n  }\n\n  step :transform_data, -&gt;(result) {\n    transformed = result.value.map do |row|\n      {\n        id: row['id'].to_i,\n        name: row['name'].strip,\n        email: row['email'].downcase,\n        active: row['active'] == 'true'\n      }\n    end\n    result.continue(transformed)\n  }\n\n  step :write_json, -&gt;(result) {\n    output_path = result.value.first['source'] + '.json'\n    File.write(output_path, JSON.pretty_generate(result.value))\n    result.continue(output_path)\n  }\nend\n</code></pre>"},{"location":"guides/file-processing/#file-format-conversion-pipeline","title":"File Format Conversion Pipeline","text":"<pre><code>class FileConverter\n  def self.build(input_format:, output_format:)\n    SimpleFlow::Pipeline.new do\n      step :read_input, reader_for(input_format), depends_on: []\n      step :transform, -&gt;(result) {\n        # Normalize to common format\n        result.continue(normalize_data(result.value))\n      }, depends_on: [:read_input]\n      step :write_output, writer_for(output_format), depends_on: [:transform]\n    end\n  end\n\n  def self.reader_for(format)\n    case format\n    when :json then -&gt;(result) { JSON.parse(File.read(result.value)) }\n    when :csv then -&gt;(result) { CSV.read(result.value, headers: true).map(&amp;:to_h) }\n    when :yaml then -&gt;(result) { YAML.load_file(result.value) }\n    end\n  end\n\n  def self.writer_for(format)\n    case format\n    when :json then -&gt;(result) { File.write(result.value[:output], JSON.pretty_generate(result.value[:data])) }\n    when :csv then -&gt;(result) { write_csv(result.value[:output], result.value[:data]) }\n    when :yaml then -&gt;(result) { File.write(result.value[:output], result.value[:data].to_yaml) }\n    end\n  end\nend\n</code></pre>"},{"location":"guides/file-processing/#file-validation","title":"File Validation","text":""},{"location":"guides/file-processing/#validating-file-existence","title":"Validating File Existence","text":"<pre><code>step :validate_file_exists, -&gt;(result) {\n  filepath = result.value\n\n  unless File.exist?(filepath)\n    return result.halt.with_error(:file, \"File does not exist: #{filepath}\")\n  end\n\n  unless File.readable?(filepath)\n    return result.halt.with_error(:file, \"File is not readable: #{filepath}\")\n  end\n\n  result.continue(filepath)\n}\n</code></pre>"},{"location":"guides/file-processing/#validating-file-format","title":"Validating File Format","text":"<pre><code>step :validate_json_format, -&gt;(result) {\n  begin\n    content = File.read(result.value)\n    JSON.parse(content)  # Just validate, don't use result yet\n    result.continue(result.value)\n  rescue JSON::ParserError =&gt; e\n    result.halt.with_error(:format, \"Invalid JSON file: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/file-processing/#validating-file-size","title":"Validating File Size","text":"<pre><code>step :validate_file_size, -&gt;(result) {\n  filepath = result.value\n  max_size = 10 * 1024 * 1024  # 10 MB\n\n  file_size = File.size(filepath)\n\n  if file_size &gt; max_size\n    result.halt.with_error(:size, \"File too large: #{file_size} bytes (max #{max_size})\")\n  else\n    result.with_context(:file_size, file_size).continue(filepath)\n  end\n}\n</code></pre>"},{"location":"guides/file-processing/#complete-file-processing-example","title":"Complete File Processing Example","text":"<pre><code>class CSVProcessor\n  def self.build\n    SimpleFlow::Pipeline.new do\n      # Validate file\n      step :validate_exists, -&gt;(result) {\n        filepath = result.value\n        unless File.exist?(filepath)\n          return result.halt.with_error(:file, \"File not found\")\n        end\n        result.continue(filepath)\n      }, depends_on: []\n\n      step :validate_size, -&gt;(result) {\n        size = File.size(result.value)\n        max_size = 50 * 1024 * 1024  # 50 MB\n\n        if size &gt; max_size\n          return result.halt.with_error(:size, \"File too large\")\n        end\n\n        result.with_context(:file_size, size).continue(result.value)\n      }, depends_on: [:validate_exists]\n\n      # Read and parse\n      step :read_csv, -&gt;(result) {\n        rows = CSV.read(result.value, headers: true)\n        result.continue(rows.map(&amp;:to_h))\n      }, depends_on: [:validate_size]\n\n      # Validate data\n      step :validate_headers, -&gt;(result) {\n        required = ['id', 'name', 'email']\n        actual = result.value.first.keys\n\n        missing = required - actual\n        if missing.any?\n          return result.halt.with_error(:headers, \"Missing columns: #{missing.join(', ')}\")\n        end\n\n        result.continue(result.value)\n      }, depends_on: [:read_csv]\n\n      # Transform data\n      step :clean_data, -&gt;(result) {\n        cleaned = result.value.map do |row|\n          {\n            id: row['id'].to_i,\n            name: row['name'].strip.capitalize,\n            email: row['email'].downcase.strip\n          }\n        end\n        result.continue(cleaned)\n      }, depends_on: [:validate_headers]\n\n      step :filter_invalid, -&gt;(result) {\n        valid = result.value.select do |row|\n          row[:email] =~ /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n        end\n\n        invalid_count = result.value.size - valid.size\n        if invalid_count &gt; 0\n          result = result.with_context(:invalid_count, invalid_count)\n        end\n\n        result.continue(valid)\n      }, depends_on: [:clean_data]\n\n      # Save results\n      step :write_output, -&gt;(result) {\n        output = 'output/cleaned.json'\n        File.write(output, JSON.pretty_generate(result.value))\n\n        result\n          .with_context(:output_file, output)\n          .with_context(:records_written, result.value.size)\n          .continue(output)\n      }, depends_on: [:filter_invalid]\n    end\n  end\nend\n\n# Usage\nresult = CSVProcessor.build.call(\n  SimpleFlow::Result.new('data/users.csv')\n)\n\nif result.continue?\n  puts \"Processed successfully:\"\n  puts \"  File size: #{result.context[:file_size]} bytes\"\n  puts \"  Records written: #{result.context[:records_written]}\"\n  puts \"  Invalid records skipped: #{result.context[:invalid_count] || 0}\"\n  puts \"  Output: #{result.context[:output_file]}\"\nelse\n  puts \"Processing failed:\"\n  result.errors.each do |category, messages|\n    puts \"  #{category}: #{messages.join(', ')}\"\n  end\nend\n</code></pre>"},{"location":"guides/file-processing/#binary-file-processing","title":"Binary File Processing","text":""},{"location":"guides/file-processing/#reading-binary-files","title":"Reading Binary Files","text":"<pre><code>step :read_binary, -&gt;(result) {\n  filepath = result.value\n  content = File.binread(filepath)\n\n  result\n    .with_context(:file_size, content.bytesize)\n    .with_context(:encoding, content.encoding.name)\n    .continue(content)\n}\n</code></pre>"},{"location":"guides/file-processing/#processing-images","title":"Processing Images","text":"<pre><code>require 'mini_magick'\n\nstep :process_image, -&gt;(result) {\n  filepath = result.value\n\n  image = MiniMagick::Image.open(filepath)\n\n  # Resize if too large\n  if image.width &gt; 1920 || image.height &gt; 1080\n    image.resize '1920x1080'\n  end\n\n  # Generate thumbnail\n  thumbnail = image.clone\n  thumbnail.resize '200x200'\n\n  result\n    .with_context(:original_size, [image.width, image.height])\n    .with_context(:thumbnail_path, filepath.gsub('.jpg', '_thumb.jpg'))\n    .continue(filepath)\n}\n</code></pre>"},{"location":"guides/file-processing/#temporary-files","title":"Temporary Files","text":""},{"location":"guides/file-processing/#using-temporary-files","title":"Using Temporary Files","text":"<pre><code>step :use_temp_file, -&gt;(result) {\n  require 'tempfile'\n\n  Tempfile.create(['process', '.json']) do |temp|\n    # Write intermediate data\n    temp.write(JSON.generate(result.value))\n    temp.rewind\n\n    # Process temp file\n    processed = process_file(temp.path)\n\n    # Temp file automatically deleted when block exits\n    result.continue(processed)\n  end\n}\n</code></pre>"},{"location":"guides/file-processing/#related-documentation","title":"Related Documentation","text":"<ul> <li>Data Fetching - Fetching data from various sources</li> <li>Error Handling - Error handling strategies</li> <li>Complex Workflows - Building complete pipelines</li> <li>Performance Guide - File processing optimization</li> </ul>"},{"location":"guides/validation-patterns/","title":"Validation Patterns","text":"<p>This guide presents common validation patterns used with SimpleFlow for data validation, business rule enforcement, and input sanitization.</p>"},{"location":"guides/validation-patterns/#basic-validation-patterns","title":"Basic Validation Patterns","text":""},{"location":"guides/validation-patterns/#required-fields","title":"Required Fields","text":"<pre><code>step :validate_required, -&gt;(result) {\n  data = result.value\n  required = [:name, :email, :password]\n  missing = required.reject { |field| data[field] &amp;&amp; !data[field].empty? }\n\n  if missing.any?\n    result.halt.with_error(:required, \"Missing fields: #{missing.join(', ')}\")\n  else\n    result.continue(data)\n  end\n}\n</code></pre>"},{"location":"guides/validation-patterns/#format-validation","title":"Format Validation","text":"<pre><code>step :validate_formats, -&gt;(result) {\n  data = result.value\n  errors = []\n\n  unless data[:email] =~ /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n    errors &lt;&lt; \"Invalid email format\"\n  end\n\n  unless data[:phone] =~ /\\A\\+?\\d{10,15}\\z/\n    errors &lt;&lt; \"Invalid phone format\"\n  end\n\n  if errors.any?\n    result.halt.with_error(:format, errors.join(\", \"))\n  else\n    result.continue(data)\n  end\n}\n</code></pre>"},{"location":"guides/validation-patterns/#range-validation","title":"Range Validation","text":"<pre><code>step :validate_ranges, -&gt;(result) {\n  data = result.value\n\n  if data[:age] &amp;&amp; (data[:age] &lt; 0 || data[:age] &gt; 120)\n    return result.halt.with_error(:range, \"Age must be between 0 and 120\")\n  end\n\n  if data[:quantity] &amp;&amp; data[:quantity] &lt; 1\n    return result.halt.with_error(:range, \"Quantity must be at least 1\")\n  end\n\n  result.continue(data)\n}\n</code></pre>"},{"location":"guides/validation-patterns/#type-validation","title":"Type Validation","text":""},{"location":"guides/validation-patterns/#type-checking","title":"Type Checking","text":"<pre><code>step :validate_types, -&gt;(result) {\n  data = result.value\n  type_specs = {\n    name: String,\n    age: Integer,\n    active: [TrueClass, FalseClass],\n    tags: Array\n  }\n\n  errors = type_specs.map do |field, expected_type|\n    value = data[field]\n    next if value.nil?\n\n    expected = Array(expected_type)\n    unless expected.any? { |type| value.is_a?(type) }\n      \"#{field} must be #{expected.join(' or ')}, got #{value.class}\"\n    end\n  end.compact\n\n  if errors.any?\n    result.halt.with_error(:type, errors.join(\", \"))\n  else\n    result.continue(data)\n  end\n}\n</code></pre>"},{"location":"guides/validation-patterns/#parallel-validation","title":"Parallel Validation","text":""},{"location":"guides/validation-patterns/#independent-field-validation","title":"Independent Field Validation","text":"<pre><code>pipeline = SimpleFlow::Pipeline.new do\n  step :validate_email, -&gt;(result) {\n    unless valid_email?(result.value[:email])\n      result.with_error(:email, \"Invalid email\")\n    end\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :validate_password, -&gt;(result) {\n    password = result.value[:password]\n    errors = []\n    errors &lt;&lt; \"Too short\" if password.length &lt; 8\n    errors &lt;&lt; \"Need uppercase\" unless password =~ /[A-Z]/\n    errors &lt;&lt; \"Need number\" unless password =~ /[0-9]/\n\n    errors.each { |err| result = result.with_error(:password, err) }\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :validate_phone, -&gt;(result) {\n    unless valid_phone?(result.value[:phone])\n      result.with_error(:phone, \"Invalid phone\")\n    end\n    result.continue(result.value)\n  }, depends_on: []\n\n  step :check_errors, -&gt;(result) {\n    if result.errors.any?\n      result.halt(result.value)\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: [:validate_email, :validate_password, :validate_phone]\nend\n</code></pre>"},{"location":"guides/validation-patterns/#business-rule-validation","title":"Business Rule Validation","text":""},{"location":"guides/validation-patterns/#single-rule-validation","title":"Single Rule Validation","text":"<pre><code>step :validate_business_rules, -&gt;(result) {\n  order = result.value\n\n  # Maximum order amount\n  if order[:total] &gt; 10000\n    return result.halt.with_error(:business, \"Order exceeds maximum amount\")\n  end\n\n  # Minimum order for free shipping\n  if order[:total] &lt; 50 &amp;&amp; order[:shipping_method] == :free\n    return result.halt.with_error(:business, \"Free shipping requires $50 minimum\")\n  end\n\n  # Age restriction\n  if order[:items].any? { |i| i[:age_restricted] } &amp;&amp; order[:customer][:age] &lt; 21\n    return result.halt.with_error(:business, \"Age-restricted items require customer to be 21+\")\n  end\n\n  result.continue(order)\n}\n</code></pre>"},{"location":"guides/validation-patterns/#conditional-business-rules","title":"Conditional Business Rules","text":"<pre><code>step :apply_discount_rules, -&gt;(result) {\n  order = result.value\n  customer = result.context[:customer]\n\n  discount = 0\n\n  # VIP customers get 20% off\n  if customer[:vip]\n    discount = [discount, 0.20].max\n  end\n\n  # Orders over $100 get 10% off\n  if order[:subtotal] &gt; 100\n    discount = [discount, 0.10].max\n  end\n\n  # First-time customers get 15% off\n  if customer[:order_count] == 0\n    discount = [discount, 0.15].max\n  end\n\n  result\n    .with_context(:discount_rate, discount)\n    .with_context(:discount_amount, order[:subtotal] * discount)\n    .continue(order)\n}\n</code></pre>"},{"location":"guides/validation-patterns/#custom-validators","title":"Custom Validators","text":""},{"location":"guides/validation-patterns/#reusable-validator-classes","title":"Reusable Validator Classes","text":"<pre><code>class EmailValidator\n  def self.call(result)\n    email = result.value[:email]\n\n    errors = []\n    errors &lt;&lt; \"Email is required\" if email.nil? || email.empty?\n    errors &lt;&lt; \"Invalid email format\" unless email =~ /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n    if errors.any?\n      errors.each { |error| result = result.with_error(:email, error) }\n    end\n\n    result.continue(result.value)\n  end\nend\n\nclass PasswordValidator\n  MIN_LENGTH = 8\n\n  def self.call(result)\n    password = result.value[:password]\n\n    errors = []\n    errors &lt;&lt; \"Password is required\" if password.nil? || password.empty?\n    errors &lt;&lt; \"Password too short\" if password &amp;&amp; password.length &lt; MIN_LENGTH\n    errors &lt;&lt; \"Must contain uppercase\" unless password =~ /[A-Z]/\n    errors &lt;&lt; \"Must contain lowercase\" unless password =~ /[a-z]/\n    errors &lt;&lt; \"Must contain number\" unless password =~ /[0-9]/\n\n    if errors.any?\n      errors.each { |error| result = result.with_error(:password, error) }\n    end\n\n    result.continue(result.value)\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  step :validate_email, EmailValidator, depends_on: []\n  step :validate_password, PasswordValidator, depends_on: []\n\n  step :check_validations, -&gt;(result) {\n    if result.errors.any?\n      result.halt(result.value)\n    else\n      result.continue(result.value)\n    end\n  }, depends_on: [:validate_email, :validate_password]\nend\n</code></pre>"},{"location":"guides/validation-patterns/#cross-field-validation","title":"Cross-Field Validation","text":""},{"location":"guides/validation-patterns/#dependent-fields","title":"Dependent Fields","text":"<pre><code>step :validate_shipping, -&gt;(result) {\n  order = result.value\n\n  # If express shipping is selected, shipping address is required\n  if order[:shipping_method] == :express\n    unless order[:shipping_address]\n      return result.halt.with_error(:shipping, \"Express shipping requires address\")\n    end\n  end\n\n  # If international shipping, country is required\n  if order[:international]\n    unless order[:shipping_address][:country]\n      return result.halt.with_error(:shipping, \"International shipping requires country\")\n    end\n  end\n\n  result.continue(order)\n}\n</code></pre>"},{"location":"guides/validation-patterns/#mutually-exclusive-fields","title":"Mutually Exclusive Fields","text":"<pre><code>step :validate_payment, -&gt;(result) {\n  payment = result.value[:payment]\n\n  methods_present = [\n    payment[:credit_card],\n    payment[:paypal],\n    payment[:bank_transfer]\n  ].count { |m| m }\n\n  if methods_present == 0\n    result.halt.with_error(:payment, \"Payment method required\")\n  elsif methods_present &gt; 1\n    result.halt.with_error(:payment, \"Only one payment method allowed\")\n  else\n    result.continue(result.value)\n  end\n}\n</code></pre>"},{"location":"guides/validation-patterns/#external-validation","title":"External Validation","text":""},{"location":"guides/validation-patterns/#api-based-validation","title":"API-Based Validation","text":"<pre><code>step :validate_address, -&gt;(result) {\n  begin\n    address = result.value[:shipping_address]\n    validation = AddressValidator.validate(address)\n\n    if validation[:valid]\n      result\n        .with_context(:validated_address, validation[:normalized])\n        .continue(result.value)\n    else\n      result.halt.with_error(:address, validation[:errors].join(\", \"))\n    end\n  rescue AddressValidator::Error =&gt; e\n    result.halt.with_error(:validation_service, \"Address validation failed: #{e.message}\")\n  end\n}\n</code></pre>"},{"location":"guides/validation-patterns/#database-validation","title":"Database Validation","text":"<pre><code>step :validate_unique_email, -&gt;(result) {\n  email = result.value[:email]\n\n  if User.exists?(email: email)\n    result.halt.with_error(:uniqueness, \"Email already registered\")\n  else\n    result.continue(result.value)\n  end\n}\n\nstep :validate_referral_code, -&gt;(result) {\n  code = result.value[:referral_code]\n  return result.continue(result.value) if code.nil?\n\n  referrer = User.find_by(referral_code: code)\n  if referrer\n    result.with_context(:referrer, referrer).continue(result.value)\n  else\n    result.halt.with_error(:referral, \"Invalid referral code\")\n  end\n}\n</code></pre>"},{"location":"guides/validation-patterns/#sanitization-and-normalization","title":"Sanitization and Normalization","text":""},{"location":"guides/validation-patterns/#data-cleaning","title":"Data Cleaning","text":"<pre><code>step :sanitize_input, -&gt;(result) {\n  data = result.value\n\n  sanitized = {\n    name: data[:name]&amp;.strip&amp;.gsub(/\\s+/, ' '),\n    email: data[:email]&amp;.downcase&amp;.strip,\n    phone: data[:phone]&amp;.gsub(/[^\\d+]/, ''),\n    bio: data[:bio]&amp;.strip&amp;.slice(0, 500)\n  }\n\n  result.continue(sanitized)\n}\n</code></pre>"},{"location":"guides/validation-patterns/#data-normalization","title":"Data Normalization","text":"<pre><code>step :normalize_address, -&gt;(result) {\n  address = result.value\n\n  normalized = {\n    street: address[:street]&amp;.upcase,\n    city: address[:city]&amp;.titleize,\n    state: address[:state]&amp;.upcase,\n    zip: address[:zip]&amp;.gsub(/[^\\d-]/, ''),\n    country: address[:country]&amp;.upcase\n  }\n\n  result.continue(normalized)\n}\n</code></pre>"},{"location":"guides/validation-patterns/#validation-middleware","title":"Validation Middleware","text":""},{"location":"guides/validation-patterns/#automatic-validation-middleware","title":"Automatic Validation Middleware","text":"<pre><code>class ValidationMiddleware\n  def initialize(callable, validator:)\n    @callable = callable\n    @validator = validator\n  end\n\n  def call(result)\n    validation_result = @validator.call(result)\n\n    if validation_result.errors.any?\n      validation_result.halt(validation_result.value)\n    else\n      @callable.call(validation_result)\n    end\n  end\nend\n\npipeline = SimpleFlow::Pipeline.new do\n  use_middleware ValidationMiddleware, validator: EmailValidator\n\n  step -&gt;(result) {\n    # Only executes if email validation passes\n    result.continue(\"Email validated: #{result.value[:email]}\")\n  }\nend\n</code></pre>"},{"location":"guides/validation-patterns/#complete-example","title":"Complete Example","text":"<pre><code>class UserRegistrationPipeline\n  def self.build\n    SimpleFlow::Pipeline.new do\n      # Sanitize inputs\n      step :sanitize, -&gt;(result) {\n        data = result.value\n        sanitized = {\n          name: data[:name]&amp;.strip,\n          email: data[:email]&amp;.downcase&amp;.strip,\n          phone: data[:phone]&amp;.gsub(/[^\\d+]/, ''),\n          password: data[:password]\n        }\n        result.continue(sanitized)\n      }, depends_on: []\n\n      # Parallel validations\n      step :validate_name, -&gt;(result) {\n        if result.value[:name].nil? || result.value[:name].empty?\n          result.with_error(:name, \"Name is required\")\n        else\n          result.continue(result.value)\n        end\n      }, depends_on: [:sanitize]\n\n      step :validate_email, EmailValidator, depends_on: [:sanitize]\n      step :validate_password, PasswordValidator, depends_on: [:sanitize]\n      step :validate_phone, -&gt;(result) {\n        phone = result.value[:phone]\n        unless phone =~ /\\A\\+?\\d{10,15}\\z/\n          result.with_error(:phone, \"Invalid phone format\")\n        end\n        result.continue(result.value)\n      }, depends_on: [:sanitize]\n\n      # Check uniqueness\n      step :check_uniqueness, -&gt;(result) {\n        if User.exists?(email: result.value[:email])\n          result.with_error(:email, \"Email already registered\")\n        end\n        result.continue(result.value)\n      }, depends_on: [:validate_email]\n\n      # Verify all validations passed\n      step :verify, -&gt;(result) {\n        if result.errors.any?\n          result.halt(result.value)\n        else\n          result.continue(result.value)\n        end\n      }, depends_on: [:validate_name, :validate_email, :validate_password, :validate_phone, :check_uniqueness]\n\n      # Create user\n      step :create_user, -&gt;(result) {\n        user = User.create!(result.value)\n        result.continue(user)\n      }, depends_on: [:verify]\n    end\n  end\nend\n\n# Usage\nresult = UserRegistrationPipeline.build.call_parallel(\n  SimpleFlow::Result.new(user_params)\n)\n\nif result.continue?\n  redirect_to dashboard_path, notice: \"Welcome!\"\nelse\n  render :new, errors: result.errors\nend\n</code></pre>"},{"location":"guides/validation-patterns/#related-documentation","title":"Related Documentation","text":"<ul> <li>Error Handling - Comprehensive error handling strategies</li> <li>Complex Workflows - Building sophisticated pipelines</li> <li>Result API - Result class reference</li> </ul>"}]}